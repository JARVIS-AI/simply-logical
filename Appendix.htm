---
layout: paper
part: Appendix
---

<!-- <body bgcolor=white lang=EN-GB style='tab-interval:28.0pt'> -->

<div class=WordSection1>

<p id="appendices" class=romeinscijfer><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<div style='mso-element:para-border-div;border:none;border-bottom:solid windowtext 1.5pt;
padding:0cm 0cm 0cm 0cm;margin-left:1.0cm;margin-right:0cm'>

<h1 id="h_appendices" style='margin-left:0cm'><span lang=EN-US>Appendices</span></h1>

</div>

<p class=sektie1><span lang=EN-US>Appendix A describes a number of built-in
Prolog predicates, and lists a library of utility programs. These predicates
are used in various programs throughout the book. </span></p>

<p class=sektie><span lang=EN-US>Appendix B gives two programs converting to
and from clausal logic. The first program transforms a formula in first-order
Predicate Logic to clausal form, as described in section 2.5. The second
program completes a given set of general clauses by means of Predicate
Completion (section 8.2). The output of this program is a formula in Predicate
Logic, which can be transformed back to clausal form by means of the first
program. </span></p>

<p class=sektie><span lang=EN-US>Appendix C gives detailed answers to selected
exercises. </span></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:48.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection2>

<p id="a_catalogue_of_useful_predicates" class=cijfer><span lang=EN-US>A</span></p>

<h2 id="h_a_catalogue_of_useful_predicates"><span lang=EN-US>A catalogue of useful predicates</span></h2>

<p class=sektie1><span lang=EN-US>Appendix A.1 describes a number of built-in
Prolog</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:built-in
predicates&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>predicates. Appendix A.2
comprises a small library of utility predicates that are used by programs in
this book. </span></p>

<h3 id="built_in_predicates"><span lang=EN-US>A.1<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Built-in
predicates</span></h3>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Term
manipulation<o:p></o:p></span></i></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>Term1 = Term2</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Term1</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>Term2</span><span lang=EN-US> are
unified.</span><!--[if supportFields]><span lang=EN-US style='font-family:Courier;
display:none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US
style='font-family:Courier'><o:p></o:p></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>Term1 \= Term2</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Term1</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>Term2</span><span lang=EN-US> cannot be
unified.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;\\=/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>Term1 == Term2</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Term1</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>Term2</span><span lang=EN-US> are bound
to the same term.</span><!--[if supportFields]><span lang=EN-US
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;==/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US
style='font-family:Courier'><o:p></o:p></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>Term1 \== Term2</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Term1</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>Term2</span><span lang=EN-US> are bound
to different terms.</span><!--[if supportFields]><span lang=EN-US
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;\\==/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US
style='font-family:Courier'><o:p></o:p></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>var(V)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>V</span><span lang=EN-US> is an unbound
variable.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;var/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>arg(N,T,A)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US> is the </span><span
lang=EN-US style='font-family:Courier'>N</span><span lang=EN-US>-th argument of
term </span><span lang=EN-US style='font-family:Courier'>T</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;arg/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>functor(T,F,N)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>T</span><span lang=EN-US> is a term with
functor </span><span lang=EN-US style='font-family:Courier'>F</span><span
lang=EN-US> and arity </span><span lang=EN-US style='font-family:Courier'>N</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;functor/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>Term =.. List</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>List</span><span lang=EN-US> is a list
starting with the functor of </span><span lang=EN-US style='font-family:Courier'>Term</span><span
lang=EN-US>, followed by its arguments.</span><span lang=EN-US
style='font-family:Courier;display:none;mso-hide:all'>../2</span><span
lang=EN-US style='display:none;mso-hide:all'>;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=../2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>varsin(Term,Vs)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Vs</span><span lang=EN-US> is a list of
the variables in </span><span lang=EN-US style='font-family:Courier'>Term</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;varsin/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>numbervars(T,N,M)</span><span
lang=EN-US><span style='mso-tab-count:1'>&nbsp;&nbsp; </span>the variables in
term </span><span lang=EN-US style='font-family:Courier'>T</span><span
lang=EN-US> are instantiated to terms of the form </span><span lang=EN-US
style='font-family:Courier'>'$VAR'(</span><i style='mso-bidi-font-style:normal'><span
lang=EN-US>n</span></i><span lang=EN-US style='font-family:Courier'>)</span><span
lang=EN-US>, where <i style='mso-bidi-font-style:normal'>n</i> is an integer
which has a different value for each distinct variable. The variables will be
numbered starting from </span><span lang=EN-US style='font-family:Courier'>N</span><span
lang=EN-US>, and </span><span lang=EN-US style='font-family:Courier'>M</span><span
lang=EN-US> is the next unused number.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;numbervars/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Database
manipulation</span></i></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>assert(Clause)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Clause</span><span lang=EN-US> is added
at the end of the database (can also be a single atom, without a body).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;assert/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>asserta(Clause)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Clause</span><span lang=EN-US> is added
at the <i style='mso-bidi-font-style:normal'>top</i> of the database.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;asserta/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>clause(H,B)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>H:-B</span><span lang=EN-US> is a clause
in the database (</span><span lang=EN-US style='font-family:Courier'>H</span><span
lang=EN-US> must be instantiated).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;clause/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>retract(Clause)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>the first
clause unifying with </span><span lang=EN-US style='font-family:Courier'>Clause</span><span
lang=EN-US> is removed from the database.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;retract/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>retractall(Head)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>all clauses with head
unifying with </span><span lang=EN-US style='font-family:Courier'>Head</span><span
lang=EN-US> are removed from the database.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;retractall/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>kill(Predicate)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>all clauses
defining </span><span lang=EN-US style='font-family:Courier'>Predicate</span><span
lang=EN-US> are removed from the database.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;kill/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>save(File)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>save
the clauses in the database to </span><span lang=EN-US style='font-family:Courier'>File</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;save/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>consult(File)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>load
the clauses in </span><span lang=EN-US style='font-family:Courier'>File</span><span
lang=EN-US> into the database.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;consult/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>op(P,Type,Name)<span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp; </span></span><span lang=EN-US>declare an operator </span><span
lang=EN-US style='font-family:Courier'>Name</span><span lang=EN-US> with
priority </span><span lang=EN-US style='font-family:Courier'>P</span><span
lang=EN-US> (a number between 0 and 1200, lower priority binds stronger); </span><span
lang=EN-US style='font-family:Courier'>Type</span><span lang=EN-US> is </span><span
lang=EN-US style='font-family:Courier'>fx</span><span lang=EN-US> or </span><span
lang=EN-US style='font-family:Courier'>fy</span><span lang=EN-US> for prefix, </span><span
lang=EN-US style='font-family:Courier'>xfx</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>xfy</span><span lang=EN-US> or </span><span
lang=EN-US style='font-family:Courier'>yfx</span><span lang=EN-US> for infix,
and </span><span lang=EN-US style='font-family:Courier'>xf</span><span
lang=EN-US> or </span><span lang=EN-US style='font-family:Courier'>yf</span><span
lang=EN-US> for postfix. </span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;op/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Control</span></i></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>call(Goal)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>call
</span><span lang=EN-US style='font-family:Courier'>Goal</span><span
lang=EN-US> (must be instantiated to a goal).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;call/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>not(Goal)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Goal</span><span lang=EN-US> is not
provable (must be instantiated to a goal).<br>
</span><span lang=EN-US style='font-family:Courier'>not/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;not/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>could be defined as<br>
</span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>not(Goal):-call(Goal),!,fail.<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>not(Goal).<o:p></o:p></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>fail</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>false</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>forces
failure.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;fail/0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;false/0&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>true</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>otherwise</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>always
succeeds.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;otherwise/0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><br>
</span><span lang=EN-US style='font-family:Courier'>true/0</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;true/0&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>could be defined as<br>
</span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>true.<o:p></o:p></span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>repeat</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>succeeds
indefinitely many times on backtracking.<br>
</span><span lang=EN-US style='font-family:Courier'>repeat/0</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;repeat/0&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>could be defined as<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>repeat.<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>repeat:-repeat.</span></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>findall(X,G,L)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>L</span><span lang=EN-US> is a list of </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US>&rsquo;s, one for
each solution of </span><span lang=EN-US style='font-family:Courier'>G</span><span
lang=EN-US> (succeeds with the empty list if no solutions are found).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;findall/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>bagof(X,G,L)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>L</span><span lang=EN-US> is a list of </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US>&rsquo;s, one for
each solution of </span><span lang=EN-US style='font-family:Courier'>G</span><span
lang=EN-US>, which may be preceded by existential variables (fails if no
solutions are found).</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;bagof/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>setof(X,G,L)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>as
</span><span lang=EN-US style='font-family:Courier'>bagof/3</span><span
lang=EN-US>, but </span><span lang=EN-US style='font-family:Courier'>L</span><span
lang=EN-US> is a sorted list without duplicates.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;setof/3&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>forall(G,C)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>for
all the solutions of </span><span lang=EN-US style='font-family:Courier'>G</span><span
lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>C</span><span
lang=EN-US> is true.<br>
</span><span lang=EN-US style='font-family:Courier'>forall/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;forall/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>could be defined as<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>forall(G,C):-not((G,not(C))).<o:p></o:p></span></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Interaction<o:p></o:p></span></i></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>read(Term)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>Term</span><span lang=EN-US> is
instantiated to the next line typed by the user (must be a Prolog term).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;read/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>write(Term)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>write
</span><span lang=EN-US style='font-family:Courier'>Term</span><span
lang=EN-US> to the screen.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;write/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>tab(N)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>write
</span><span lang=EN-US style='font-family:Courier'>N</span><span lang=EN-US>
spaces to the screen.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tab/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>nl</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>write
a newline to the screen.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;nl/0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>get(C)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>C</span><span lang=EN-US> is ASCII code
of next character typed by the user.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;get/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>put(C)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>write
character with ASCII code </span><span lang=EN-US style='font-family:Courier'>C</span><span
lang=EN-US> to the screen.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;put/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>tell(File)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>redirect
output to </span><span lang=EN-US style='font-family:Courier'>File</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tell/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>told</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>stop
redirecting output.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;told/0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>see(File)</span><span lang=EN-US><span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>redirect
input from </span><span lang=EN-US style='font-family:Courier'>File</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;see/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:0cm;margin-right:.9pt;margin-bottom:0cm;
margin-left:113.0pt;margin-bottom:.0001pt;text-indent:-112.35pt'><span
lang=EN-US style='font-family:Courier'>seen</span><span lang=EN-US>.<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>stop
redirecting input.</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;seen/0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:12.0pt;
mso-bidi-font-size:10.0pt;font-family:"Avant Garde";mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:"Avant Garde";mso-ansi-language:EN-US;
mso-fareast-language:EN-US;mso-bidi-language:AR-SA'><br clear=all
style='page-break-before:always'>
</span></b>

<h3 id="a_library_of_utility_predicates"><span lang=EN-US>A.2<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>A
library of utility predicates</span></h3>

<p class=sektie1><span lang=EN-US>What follows is a small collection of
predicates that are used by various programs throughout the book. </span></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Lists
and sets</span></i><span lang=EN-US>.<span style="mso-spacerun:yes">&nbsp;
</span><span style="mso-spacerun:yes">&nbsp;</span>We start with a couple of
simple list predicates. </span></p>

<p class=oms-eerst><span lang=EN-US>% element(X,Ys) &lt;- X is an element of
the list Ys</span></p>

<p class=pi><span lang=EN-US>element</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;element/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,[X|Ys]).</span></p>

<p class=pi-laatst><span lang=EN-US>element(X,[Y|Ys]):-<br>
element(X,Ys).</span></p>

<p class=oms><span lang=EN-US>% append(Xs,Ys,Zs) &lt;- list Zs is Xs followed
by Ys</span></p>

<p class=pi><span lang=EN-US>append</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;append/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Ys,Ys).</span></p>

<p class=pi-laatst><span lang=EN-US>append([X|Xs],Ys,[X|Zs]):-<br>
append(Xs,Ys,Zs).</span></p>

<p class=oms><span lang=EN-US>% remove_one(X,Ys,Zs) &lt;- Zs is list Ys minus <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>one occurrence of X</span></p>

<p class=pi><span lang=EN-US>remove_one</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;remove_one/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,[X|Ys],Ys).</span></p>

<p class=pi-laatst><span lang=EN-US>remove_one(X,[Y|Ys],[Y|Zs]):-<br>
remove_one(X,Ys,Zs).</span></p>

<p class=tekst><span lang=EN-US>The difference between lists and sets is that
the order of elements in a set is not important. Thus, a <i style='mso-bidi-font-style:
normal'>subset</i> is different from a <i style='mso-bidi-font-style:normal'>sublist</i>.
The predicate </span><span lang=EN-US style='font-family:Courier'>proper_subset/2</span><span
lang=EN-US> works only if the first argument is a list without duplicates! </span></p>

<p class=oms-eerst><span lang=EN-US>% subset(Xs,Ys) &lt;- every element of Xs occurs
in Ys</span></p>

<p class=pi><span lang=EN-US>subset</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;subset/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Ys).</span></p>

<p class=pi-laatst><span lang=EN-US>subset([X|Xs],Ys):-<br>
element(X,Ys),<br>
subset(Xs,Ys).</span></p>

<p class=oms><span lang=EN-US>% proper_subset(Xs,Ys) &lt;- Xs is a subset of
Ys, and Ys <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>has more elements than Xs</span></p>

<p class=pi><span lang=EN-US>proper_subset</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;proper_subset/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Ys):-<br>
Ys \= [].</span></p>

<p class=pi-laatst><span lang=EN-US>proper_subset([X|Xs],Ys):-<br>
remove_one(X,Ys,Ys1),<br>
proper_subset(Xs,Ys1).</span></p>

<p class=tekst><span lang=EN-US>The following three predicates use syntactic
identity rather than unification, which is useful for lists containing
variables. </span></p>

<p class=pi-eerst><span lang=EN-US>var_element</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;var_element/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,[Y|Ys]):-<br>
X == Y.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% syntactic
identity</span></p>

<p class=pi-laatst><span lang=EN-US>var_element(X,[Y|Ys]):-<br>
var_element(X,Ys).</span></p>

<p class=pi><span lang=EN-US>var_remove_one</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;var_remove_one/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,[Y|Ys],Ys):-<br>
X == Y.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% syntactic
identity</span></p>

<p class=pi-laatst><span lang=EN-US>var_remove_one(X,[Y|Ys],[Y|Zs]):-<br>
var_remove_one(X,Ys,Zs).</span></p>

<p class=pi><span lang=EN-US>var_proper_subset</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;var_proper_subset/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Ys):-<br>
Ys \= [].</span></p>

<p class=pi-laatst><span lang=EN-US>var_proper_subset([X|Xs],Ys):-<br>
var_remove_one(X,Ys,Zs),<br>
var_proper_subset(Xs,Zs).</span></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Conjunctions
and disjunctions.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></span></i><span
lang=EN-US>Conjunction</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Conjunction&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s and disjunction</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;disjunction&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s are recursive datastructures, just like lists. However, whereas a
single-element list such </span><span lang=EN-US style='font-family:Courier'>[1]</span><span
lang=EN-US> is a complex term </span><span lang=EN-US style='font-family:Courier'>.(1,[])</span><span
lang=EN-US>, a single-element conjunction or disjunction is a simple term.
Therefore, each of the following predicates needs an extra clause for the
single-element case. Note that </span><span lang=EN-US style='font-family:Courier'>true</span><span
lang=EN-US> is the empty conjunction, while </span><span lang=EN-US
style='font-family:Courier'>false</span><span lang=EN-US> represents the empty
disjunction. </span></p>

<p class=pi-eerst style='tab-stops:199.0pt'><span lang=EN-US>disj_element</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;disj_element/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,X):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
single-element disjunction<br>
not X=false, <br>
not X=(One;TheOther).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>disj_element(X,(X;Ys)).</span></p>

<p class=pi-laatst style='tab-stops:199.0pt'><span lang=EN-US>disj_element(X,(Y;Ys)):-<br>
disj_element(X,Ys).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>conj_append</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;conj_append/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(true,Ys,Ys).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>conj_append(X,Ys,(X,Ys)):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% single-element conjunction<br>
not X=true, <br>
not X=(One,TheOther).</span></p>

<p class=pi-laatst style='tab-stops:199.0pt'><span lang=EN-US>conj_append((X,Xs),Ys,(X,Zs)):-<br>
conj_append(Xs,Ys,Zs).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>disj_append</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;disj_append/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(false,Ys,Ys).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>disj_append(X,Ys,(X;Ys)):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% single-element disjunction<br>
not X=false, <br>
not X=(One;TheOther).</span></p>

<p class=pi-laatst style='tab-stops:199.0pt'><span lang=EN-US>disj_append((X;Xs),Ys,(X;Zs)):-<br>
disj_append(Xs,Ys,Zs).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>conj_remove_one</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;conj_remove_one/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,X,true):-<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
single-element conjunction<br>
not X=true, <br>
not X=(One,TheOther).</span></p>

<p class=pi style='tab-stops:199.0pt'><span lang=EN-US>conj_remove_one(X,(X,Ys),Ys).</span></p>

<p class=pi-laatst style='tab-stops:199.0pt'><span lang=EN-US>conj_remove_one(X,(Y,Ys),(Y,Zs)):-<br>
conj_remove_one(X,Ys,Zs).</span></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Preventing
variables from getting instantiated.<span style="mso-spacerun:yes">&nbsp;&nbsp;
</span></span></i><span lang=EN-US>Whenever Prolog reads a clause from its
internal database, fresh copies of the variables in the clause are created.
When a meta-interpreter uses an internal list of clauses, this is desirable as
well. The predicate </span><span lang=EN-US style='font-family:Courier'>copy_term/2</span><span
lang=EN-US> uses the internal database to create a fresh copy of any term. </span><span
lang=EN-US style='font-family:Courier'>copy_element/2</span><span lang=EN-US>
uses </span><span lang=EN-US style='font-family:Courier'>copy_term/2</span><span
lang=EN-US> to create a fresh copy of an item in a list. </span></p>

<p class=oms-eerst><span lang=EN-US>% copy_term(Old,New) &lt;- New is a copy of
Old <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>with new variables</span></p>

<p class=pi style='tab-stops:216.0pt'><span lang=EN-US>copy_term</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;copy_term/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Old,New):-<br>
asserta('$copy'(Old)),<br>
retract('$copy'(New)),!.</span></p>

<p class=pi-laatst style='tab-stops:163.0pt'><span lang=EN-US>copy_term(Old,New):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% in case Old and New don&rsquo;t
unify<br>
retract('$copy'(Old)),<br>
!,fail.</span></p>

<p class=oms-eerst><span lang=EN-US>% copy_element(X,L) &lt;- X is an element
of L <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>with new variables</span></p>

<p class=pi-laatst style='tab-stops:216.0pt'><span lang=EN-US>copy_element</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;copy_element/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,Ys):-<br>
element(X1,Ys),<br>
copy_term(X1,X).</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>try/1</span><span
lang=EN-US> is a meta-predicate which tests whether a goal succeeds, without
returning an answer-substitution. This is achieved by taking advantage of the
difference between negation as failure and logical negation. </span></p>

<p class=oms-eerst><span lang=EN-US>% try(Goal) &lt;- Goal succeeds, but
variables <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>don&rsquo;t get instantiated</span></p>

<p class=pi-laatst><span lang=EN-US>try</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;try/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Goal):-<br>
not not Goal.</span></p>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Various.<span
style="mso-spacerun:yes">&nbsp;&nbsp; </span></span></i><span lang=EN-US>The
remaining predicates speak for themselves. </span></p>

<p class=oms-eerst><span lang=EN-US>% variant of setof/3 which succeeds with
the empty list<br>
% if no solutions can be found</span></p>

<p class=pi><span lang=EN-US>setof0</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;setof0/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,G,L):-<br>
setof(X,G,L),!.</span></p>

<p class=pi-laatst><span lang=EN-US>setof0(X,G,[]).</span></p>

<p class=oms><span lang=EN-US>% same_predicate(L1,L2) &lt;- literals L1 and L2
have <br>
%<span style="mso-spacerun:yes">&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>the
same predicate and arity</span></p>

<p class=pi-laatst><span lang=EN-US>same_predicate</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;same_predicate/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(L1,L2):-<br>
functor(L1,P,N),<br>
functor(L2,P,N).</span></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:48.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection3>

<p id="two_programs_for_logical_conversion" class=cijfer><span lang=EN-US>B</span></p>

<h2 id="h_two_programs_for_logical_conversion"><span lang=EN-US>Two programs for logical conversion</span></h2>

<p class=sektie1><span lang=EN-US>The program in appendix B.1 transforms a
formula in first-order Predicate Logic to clausal form, as described in section
2.5. The program in appendix B.2 completes a given set of general clauses by
means of Predicate Completion (section 8.2). The output of this program is a
formula in Predicate Logic, which can be transformed back to clausal form by
means of the first program. </span></p>

<h3 id="from_predicate_logic_to_clausal_logic"><span lang=EN-US>B.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>From
Predicate Logic to clausal logic</span></h3>

<p class=sektie1><span lang=EN-US>In section 2.5 we discussed a method for
transforming a formula in Predicate Logic to an &lsquo;almost&rsquo; equivalent set of
clauses (reread this section if you don&rsquo;t recall in what sense the clauses
differ from the Predicate Logic formula). Below, a Prolog program implementing
this method is given. </span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Logic:translation to
clausal logic&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie><span lang=EN-US>The logical symbols used in Predicate Logic
formulas are defined as operators:</span></p>

<p class=pi-eerst><span lang=EN-US>% logical symbols used in Predicate Logic
formulas</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>:-op(900,xfx,'=&gt;').<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
implication</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>:-op(800,xfy,&amp;).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
conjunction</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>:-op(800,xfy,v).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
disjunction</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>:-op(400,fy,-).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
negation</span></p>

<p class=tekst><span lang=EN-US>In addition, a universally quantified formula
of the form </span><span lang=EN-US style='font-family:Symbol'>&forall;</span><span
lang=EN-US style='font-family:Courier'>X:F</span><span lang=EN-US> is
represented by the term </span><span lang=EN-US style='font-family:Courier'>forall(X,F)</span><span
lang=EN-US>. For instance, the formula</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&forall;</span><span
lang=EN-US>S: student_of(S,peter)</span><span lang=EN-US style='font-family:
Symbol'>&rarr;</span><span lang=EN-US>likes(peter,S)</span></p>

<p class=tekst><span lang=EN-US>is represented by </span></p>

<p class=p-el><span lang=EN-US>forall(S,student_of(peter)=&gt;likes(peter,S)). </span></p>

<p class=tekst><span lang=EN-US>Likewise, an existentially quantified formula
of the form </span><span lang=EN-US style='font-family:Symbol'>&exist;</span><span
lang=EN-US style='font-family:Courier'>X:F</span><span lang=EN-US> is
represented by the term </span><span lang=EN-US style='font-family:Courier'>exists(X,F)</span><span
lang=EN-US>. </span></p>

<p class=sektie style='page-break-after:avoid'><span lang=EN-US>The
tranformation from Predicate Logic to clausal logic requires six steps:</span></p>

<p class=opsomming style='margin-top:6.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>i</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>replace
implications by disjunction and negation;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>push negations inside, so that each
of them immediately precedes a literal;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iii</i>)<span
style='mso-tab-count:1'>&nbsp; </span>move quantifiers to the front (the result
is said to be in <i style='mso-bidi-font-style:normal'>prenex normal form</i>);</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iv</i>)<span
style='mso-tab-count:1'>&nbsp; </span>replace existentially quantified
variables by Skolem functors;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>v</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>rewrite into <i style='mso-bidi-font-style:
normal'>conjunctive normal form</i>, i.e. a conjunction of disjunctions of
literals;</span></p>

<p class=opsomming style='margin-bottom:6.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>vi</i>)<span style='mso-tab-count:1'>&nbsp; </span>rewrite
each conjunct to a clause.</span></p>

<p class=tekst><span lang=EN-US>The main predicate </span><span lang=EN-US
style='font-family:Courier'>transform/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;transform/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>carries out these six
steps: </span></p>

<p class=pi-el><span lang=EN-US>transform(Formula,Clauses):-<br>
rewrite_implications(Formula,F1),<br>
negations_inside(F1,F2),<br>
prenex_normal_form(F2,F3),<br>
skolemise(F3,F4),<br>
conjunctive_normal_form(F4,F5),<br>
clausal_form(F5,Clauses).</span></p>

<p class=tekst><span lang=EN-US>Predicates for each of these steps are defined
below.</span></p>

<p class=sektie><span lang=EN-US>The first two predicates contain one clause
for each possible form a formula could have.</span></p>

<p class=oms-eerst><span lang=EN-US>% rewrite_implications(F1,F2) &lt;- F2 is a
PL formula <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>without implications, <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>log. equivalent with F1</span></p>

<p class=pi style='tab-stops:250.0pt'><span lang=EN-US>rewrite_implications(A,A):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
base case<br>
literal(A).</span></p>

<p class=pi style='tab-stops:250.0pt'><span lang=EN-US>rewrite_implications(A
=&gt; B, -C v D):-<span style='mso-tab-count:1'> </span>% implication<br>
rewrite_implications(A,C),<br>
rewrite_implications(B,D).</span></p>

<p class=pi style='tab-stops:250.0pt'><span lang=EN-US>rewrite_implications(A
&amp; B, C &amp; D):-<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>% no
change;<br>
rewrite_implications(A,C),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
try rest of <br>
rewrite_implications(B,D).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
formula</span></p>

<p class=pi style='tab-stops:273.0pt'><span lang=EN-US>rewrite_implications(A v
B, C v D):-<br>
rewrite_implications(A,C),<br>
rewrite_implications(B,D).</span></p>

<p class=pi style='tab-stops:273.0pt'><span lang=EN-US>rewrite_implications(-A,-C):-<br>
rewrite_implications(A,C).</span></p>

<p class=pi style='tab-stops:273.0pt'><span lang=EN-US>rewrite_implications(forall(X,B),
forall(X,D)):-<br>
rewrite_implications(B,D).</span></p>

<p class=pi-laatst><span lang=EN-US>rewrite_implications(exists(X,B),
exists(X,D)):-<br>
rewrite_implications(B,D).</span></p>

<p class=oms><span lang=EN-US>% negations_inside(F1,F2) &lt;- F2 is a PL
formula with <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>negs. only preceding literals<br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>log. equivalent with F1</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(A,A):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
base case<br>
literal(A).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(-(A &amp; B), C v D):-<span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp; </span>% De Morgan (1)<br>
negations_inside(-A,C),<br>
negations_inside(-B,D).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(-(A v B), C &amp;<span
style="mso-spacerun:yes">&nbsp; </span>D):-<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
De Morgan (2)<br>
negations_inside(-A,C),<br>
negations_inside(-B,D).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(-(-A),B):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
double negation<br>
negations_inside(A,B).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(-exists(X,A),forall(X,B)):-<span style='mso-tab-count:
1'>&nbsp; </span>% quantifiers<br>
negations_inside(-A,B).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(-forall(X,A),exists(X,B)):-<br>
negations_inside(-A,B).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:249.0pt 292.0pt'><span
lang=EN-US>negations_inside(A &amp; B, C &amp; D):-<span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% no change;<br>
negations_inside(A,C),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
try rest of <br>
negations_inside(B,D).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
formula</span></p>

<p class=pi style='page-break-after:auto;tab-stops:292.0pt'><span lang=EN-US>negations_inside(A
v B, C v<span style="mso-spacerun:yes">&nbsp; </span>D):-<br>
negations_inside(A,C),<br>
negations_inside(B,D).</span></p>

<p class=pi style='tab-stops:292.0pt'><span lang=EN-US>negations_inside(exists(X,A),exists(X,B)):-<br>
negations_inside(A,B).</span></p>

<p class=pi-laatst style='tab-stops:292.0pt'><span lang=EN-US>negations_inside(forall(X,A),forall(X,B)):-<br>
negations_inside(A,B).</span></p>

<p class=sektie><span lang=EN-US>In step (<i style='mso-bidi-font-style:normal'>iii</i>),
the quantifiers found at different positions in the formula are moved to the
front, preserving their order. This is achieved by means of an auxiliary
predicate </span><span lang=EN-US style='font-family:Courier'>pnf/4</span><span
lang=EN-US>, which separates the quantifiers from the rest of the formula
(referred to below as the </span><span lang=EN-US style='font-family:Courier'>Body</span><span
lang=EN-US>). An additional argument </span><span lang=EN-US style='font-family:
Courier'>V</span><span lang=EN-US> acts as a pointer to the place of the body
in the quantifier structure. For instance, the query </span></p>

<p class=p-el><span lang=EN-US>?-pnf(forall(X,p(X,X)) &amp;
forall(Y,exists(Z,p(Y,Z))),Q,V,B)</span></p>

<p class=tekst><span lang=EN-US>has the following answers:</span></p>

<p class=p-el><span lang=EN-US>Q = forall(X,forall(Y,exists(Z,V)))<br>
B = p(X,X)&amp;p(Y,Z)</span></p>

<p class=tekst><span lang=EN-US>Unifying </span><span lang=EN-US
style='font-family:Courier'>V</span><span lang=EN-US> with </span><span
lang=EN-US style='font-family:Courier'>B</span><span lang=EN-US> gives the required
formula in prenex normal form: </span></p>

<p class=oms-eerst><span lang=EN-US>% prenex_normal_form(F1,F2) &lt;- F2 is a
PL formula <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>with all quant.s in front, <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>log. equivalent with F1</span></p>

<p class=pi-laatst><span lang=EN-US>prenex_normal_form(F,PNF):-<br>
pnf(F,PNF,B,B).</span></p>

<p class=pi style='tab-stops:197.0pt'><span lang=EN-US>pnf(A,V,V,A):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
base case<br>
literal(A).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:197.0pt'><span lang=EN-US>pnf(forall(X,F),forall(X,Quants),V,Body):-<br>
pnf(F,Quants,V,Body).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:197.0pt'><span lang=EN-US>pnf(exists(X,F),exists(X,Quants),V,Body):-<br>
pnf(F,Quants,V,Body).</span></p>

<p class=pi style='tab-stops:197.0pt'><span lang=EN-US>pnf(A &amp;
B,Quants,V,BodyA &amp; BodyB):-<br>
pnf(A,Quants,QB,BodyA),<br>
pnf(B,QB,V,BodyB).</span></p>

<p class=pi-laatst><span lang=EN-US>pnf(A v B,Quants,V,BodyA v BodyB):-<br>
pnf(A,Quants,QB,BodyA),<br>
pnf(B,QB,V,BodyB).</span></p>

<p class=sektie><span lang=EN-US>Step (<i style='mso-bidi-font-style:normal'>iv</i>)
is called <i style='mso-bidi-font-style:normal'>Skolemisation</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Skolemisation&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. It involves introducing a Skolem functor</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Skolem
functor&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>for each existentially
quantified variable. The Skolem functors are named </span><span lang=EN-US
style='font-family:Courier'>sk1</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>sk2</span><span lang=EN-US>, etc. The
arguments of the Skolem functors are given by the universally quantified
variables found before the existentially quantified one. Since all remaining
variables are universally quantified, the universal quantifiers can be dropped.
(Strictly speaking, the formula is now neither in Predicate Logic form, nor in
clausal form.)</span></p>

<p class=oms-eerst><span lang=EN-US>% skolemise(F1,F2) &lt;- F2 is obtained
from F1 by replacing <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>all existentially quantified <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>variables by Skolem terms</span></p>

<p class=pi-laatst><span lang=EN-US>skolemise(F1,F2):-<br>
skolemise(F1,[],1,F2).</span></p>

<p class=pi style='tab-stops:265.0pt'><span lang=EN-US>skolemise(forall(X,F1),VarList,N,F2):-!,<span
style='mso-tab-count:1'> </span>% remove univ. <br>
skolemise(F1,[X|VarList],N,F2).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
quantifier</span></p>

<p class=pi style='tab-stops:265.0pt'><span lang=EN-US>skolemise(exists(X,F1),VarList,N,F2):-!,<br>
skolem_term(X,VarList,N),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
unify with <br>
N1 is N+1,<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
Skolem term<br>
skolemise(F1,VarList,N1,F2).</span></p>

<p class=pi-laatst style='tab-stops:199.0pt'><span lang=EN-US>skolemise(F,V,N,F).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
copy rest of formula</span></p>

<p class=pi-laatst style='tab-stops:226.0pt'><span lang=EN-US>skolem_term(X,VarList,N):-<br>
C is N+48,<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
number -&gt; character<br>
name(Functor,[115,107,C]),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
Skolem functor skN<br>
X =.. [Functor|VarList].</span></p>

<p class=sektie><span lang=EN-US>We now have a formula containing only
conjunction, disjunction and positive and negative literals. Such a formula can
uniquely be rewritten to a conjunction of disjunctions of literals, by
distributing disjunction over conjunction. The result is said to be in <i
style='mso-bidi-font-style:normal'>conjunctive normal form</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;conjunctive normal form&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(CNF): </span></p>

<p class=pi-eerst style='tab-stops:286.0pt'><span lang=EN-US>conjunctive_normal_form(A,A):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
base case<br>
disjunction_of_literals(A),!.</span></p>

<p class=pi style='page-break-after:auto;tab-stops:286.0pt'><span lang=EN-US>conjunctive_normal_form((A
&amp; B) v C, D &amp; E ):-!,<br>
conjunctive_normal_form(A v C,D),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
distribution<br>
conjunctive_normal_form(B v C,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:286.0pt'><span lang=EN-US>conjunctive_normal_form(A
v (B &amp; C), D &amp; E ):- !,<br>
conjunctive_normal_form(A v B,D),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
distribution<br>
conjunctive_normal_form(A v C,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:286.0pt'><span lang=EN-US>conjunctive_normal_form(A
&amp; B,C &amp; D):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
conjuction<br>
conjunctive_normal_form(A,C),<br>
conjunctive_normal_form(B,D).</span></p>

<p class=pi-laatst style='tab-stops:286.0pt'><span lang=EN-US>conjunctive_normal_form(A
v B,E):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
other cases<br>
conjunctive_normal_form(A,C),<br>
conjunctive_normal_form(B,D),<br>
conjunctive_normal_form(C v D,E).</span></p>

<p class=sektie><span lang=EN-US>Finally, the CNF-formula is rewritten to a
list of clauses. For simplicity, body and head of each clause are represented
by lists: </span></p>

<p class=pi-eerst><span lang=EN-US>clausal_form(A,[Clause]):-<br>
disjunction_of_literals(A),<br>
make_clause(A,Clause).</span></p>

<p class=pi-laatst><span lang=EN-US>clausal_form(A &amp; B,Clauses):-<br>
clausal_form(A,ClausesA),<br>
clausal_form(B,ClausesB),<br>
append(ClausesA,ClausesB,Clauses).</span></p>

<p class=pi><span lang=EN-US>make_clause(P,([P]:-[])):-<br>
logical_atom(P).</span></p>

<p class=pi><span lang=EN-US>make_clause(-N,([]:-[N])):-<br>
logical_atom(N).</span></p>

<p class=pi-laatst><span lang=EN-US>make_clause(A v B,(HeadAB:-BodyAB)):-<br>
make_clause(A,(HeadA:-BodyA)),<br>
make_clause(B,(HeadB:-BodyB)),<br>
append(HeadA,HeadB,HeadAB),<br>
append(BodyA,BodyB,BodyAB).</span></p>

<p class=tekst><span lang=EN-US>The program is completed by a number of simple
utility predicates: </span></p>

<p class=pi-eerst><span lang=EN-US>disjunction_of_literals(A):-<br>
literal(A).</span></p>

<p class=pi-laatst><span lang=EN-US>disjunction_of_literals(C v D):-<br>
disjunction_of_literals(C),<br>
disjunction_of_literals(D).</span></p>

<p class=pi><span lang=EN-US>literal(A):-<br>
logical_atom(A).</span></p>

<p class=pi-laatst><span lang=EN-US>literal(-A):-<br>
logical_atom(A).</span></p>

<p class=pi-laatst><span lang=EN-US>logical_atom(A):-<br>
functor(A,P,N),<br>
not logical_symbol(P).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(=&gt;).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(&lt;=&gt;).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(-).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(&amp;).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(v).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(exists).</span></p>

<p class=pi><span lang=EN-US>logical_symbol(forall).</span></p>

<h3 id="predicate_completion"><span lang=EN-US>B.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Predicate
Completion</span></h3>

<p class=sektie1><span lang=EN-US>In section 8.2, we presented Predicate
Completion</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate
Completion:implementation of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as a technique for explicitly
handling negative information. A logic program is viewed as a set of predicate
definitions, where the only-if part</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;predicate
definition:only-if part&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s are implicitly assumed. Below, a program is given which constructs
additional clauses representing the only-if parts.</span></p>

<p class=sektie><span lang=EN-US>A program is represented as a list of clauses,
where head and body of each clause are lists of atoms, as in the program in the
previous section. The output of the Predicate Completion program is a formula
in first-order Predicate Logic, which can be transformed to clausal logic by
means of the aforementioned program, if desired. Definitions for different
predicates are handled separately, so the first step is to partition the
program into separate predicate definitions. After completing each of these
definitions we add appropriate formulas for each of the undefined predicates. </span></p>

<p class=oms-eerst><span lang=EN-US>% complete(P,F) &lt;- P is a list of
predicate definitions, <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>and F is a Predicate Logic formula <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>representing the only-if parts of P</span></p>

<p class=pi-laatst><span lang=EN-US>complete</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;complete/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Program,Comp):-<br>
separate_definitions(Program,Definitions),<br>
complete_definitions(Definitions,CompDefs,Heads),<br>
handle_undefined(Program,Heads,CompDefs,Comp).</span></p>

<p class=pi><span lang=EN-US>separate_definitions([],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>separate_definitions([([H]:-B)|Cls],[[([H]:-B)|D]|Ds]):-<br>
get_definition(Cls,H,D,Rest),<br>
separate_definitions(Rest,Ds).</span></p>

<p class=pi><span lang=EN-US>get_definition([],Head,[],[]).</span></p>

<p class=pi><span lang=EN-US>get_definition([([H]:-B)|Cls],Head,[([H]:-B)|Def],Rest):-<br>
same_predicate(H,Head),<br>
get_definition(Cls,Head,Def,Rest).</span></p>

<p class=pi-laatst><span lang=EN-US>get_definition([([H]:-B)|Cls],Head,Def,[([H]:-B)|Rest]):-<br>
not same_predicate(H,Head),<br>
get_definition(Cls,Head,Def,Rest).</span></p>

<p class=sektie><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Completion:handling
undefined predicates&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>Undefined predicates are those which occur in bodies of clauses
without occurring in any head. The list </span><span lang=EN-US
style='font-family:Courier'>Heads</span><span lang=EN-US> of defined predicates
is obtained while completing each predicate definition. Care must be taken to
avoid considering </span><span lang=EN-US style='font-family:Courier'>not/1</span><span
lang=EN-US> as an undefined predicate, and also to check the negated literal
itself. After constructing the list of undefined literals occuring in clause
bodies, each of them is transformed into a formula of the form </span><span
lang=EN-US style='font-family:Symbol'>&forall;</span><span lang=EN-US
style='font-family:Courier'>X1</span><span lang=EN-US>&hellip;</span><span lang=EN-US
style='font-family:Symbol'>&forall;</span><span lang=EN-US style='font-family:
Courier'>Xn: </span><span lang=EN-US>&not;</span><span lang=EN-US style='font-family:
Courier'>p(X1,&hellip;,Xn)</span><span lang=EN-US>: </span></p>

<p class=pi-el style='tab-stops:248.0pt 286.0pt'><span lang=EN-US>handle_undefined(Program,Heads,CompDefs,Comp):-<br>
findall(L,<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>( member((H:-B),Program),<span style='mso-tab-count:1'> </span>% pick a
clause body<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>( (member(L,B),not L=not(X))<span style='mso-tab-count:1'>&nbsp; </span>%
unneg. lit.<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>; member(not L,B) ),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
or a negated one<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>not member(L,Heads) ),<span style='mso-tab-count:1'>&nbsp; </span>%
which is undefined<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Undefs),<br>
undef_formulas(Undefs,CompDefs,Comp).</span></p>

<p class=pi><span lang=EN-US>undef_formulas([],Comp,Comp).</span></p>

<p class=pi-laatst><span lang=EN-US>undef_formulas([L|Ls],Comp0,Comp):-<br>
quantify(L,F),<br>
undef_formulas(Ls,F &amp; Comp0,Comp).</span></p>

<p class=pi-laatst style='tab-stops:170.0pt'><span lang=EN-US>quantify(L,F):-<br>
L =.. [P|As],<br>
variablise(As,Vs,F,-NewL),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
NB. negation symbol!<br>
NewL =.. [P|Vs].<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>%
turn arguments into variables</span></p>

<p class=pi><span lang=EN-US>% add quantifiers</span></p>

<p class=pi><span lang=EN-US>variablise([],[],L,L).</span></p>

<p class=pi-laatst><span lang=EN-US>variablise([A|As],[V|Vs],forall(V,F),L):-<br>
variablise(As,Vs,F,L).</span></p>

<p class=sektie><span lang=EN-US>The main task in Predicate Completion is the
completion of each separate predicate definition. The main steps are</span></p>

<p class=opsomming style='margin-top:6.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>i</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>adding
explicit unifications to the body of clauses;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>adding existential quantifiers for
those variables occurring in the body of a clause but not in its head;</span></p>

<p class=opsomming style='margin-bottom:6.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>iii</i>)<span style='mso-tab-count:1'>&nbsp; </span>combining
the clauses into one formula, and adding universal quantifiers for the head
variables.</span></p>

<p class=tekst><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>unifications_and_quantifiers/2</span><span
lang=EN-US> takes care of the first two steps, and the third step is carried
out by the predicate </span><span lang=EN-US style='font-family:Courier'>complete_formula/3</span><span
lang=EN-US>. These predicates are relatively self-explanatory: </span></p>

<p class=oms-eerst><span lang=EN-US>% complete_definitions(D,C,H) &lt;- C is
the complement of <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>definitions D, and H is <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>list of variablised heads</span></p>

<p class=pi><span lang=EN-US>complete_definitions([Def],Comp,[Head]):-!,<br>
complete_definition(Def,Comp,Head).</span></p>

<p class=pi-laatst><span lang=EN-US>complete_definitions([Def|Defs],Comp &amp;
Comps,[H|Hs]):-<br>
complete_definition(Def,Comp,H),<br>
complete_definitions(Defs,Comps,Hs).</span></p>

<p class=pi-laatst><span lang=EN-US>complete_definition(Definition,Comp,Head):-<br>
unifications_and_quantifiers(Definition,F),<br>
complete_formula(F,Comp,Head).</span></p>

<p class=pi><span lang=EN-US>unifications_and_quantifiers([],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>unifications_and_quantifiers([Clause|Clauses],[C|Cs]):-<br>
unifs_and_quants(Clause,C),<br>
unifications_and_quantifiers(Clauses,Cs).</span></p>

<p class=pi-laatst><span lang=EN-US>unifs_and_quants(([Head]:-Body),([NewHead]:-NewBody)):-<br>
Head=..[Pred|Args],<br>
explicit_unifications(Args,NewArgs,Body,TmpBody),<br>
existential_quantifiers(TmpBody,NewArgs,NewBody),<br>
NewHead=..[Pred|NewArgs].</span></p>

<p class=oms-eerst><span lang=EN-US>% explicit_unifications(A,NA,B,NB) &lt;- NA
is list A with <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>non-var. terms replaced by new <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>var.s; NB is body B extended <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>with explicit unifications</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>explicit_unifications([],[],Body,Body).</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>explicit_unifications([T|As],[V|NewAs],B,[V=T|NewB]):-<br>
nonvar(T),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
add explicit unification<br>
explicit_unifications(As,NewAs,B,NewB).</span></p>

<p class=pi-laatst style='tab-stops:198.0pt'><span lang=EN-US>explicit_unifications([Var|As],[Var|NewAs],Body,NewBody):-<br>
var(Var),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
no expl. unific. needed<br>
explicit_unifications(Args,NewArgs,Body,NewBody).</span></p>

<p class=oms><span lang=EN-US>% existential_quantifiers(B,V,NB) &lt;- NB is
conj. of lit.s <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>in B, extended by ex. quant.s <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>for var.s in B but not in V</span></p>

<p class=pi-laatst style='tab-stops:226.0pt 293.0pt 320.0pt'><span lang=EN-US>existential_quantifiers(Body,HeadVars,NewBody):-<br>
varsin(Body,BodyVars),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
built-in predicate<br>
body_form(Body,Conj),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
list -&gt; conjunction<br>
body_quants(BodyVars,HeadVars,Conj,NewBody).</span></p>

<p class=pi style='tab-stops:255.0pt'><span lang=EN-US>body_form([not
Lit],-Lit):-!.</span></p>

<p class=pi style='tab-stops:255.0pt'><span lang=EN-US>body_form([Lit],Lit):-!.</span></p>

<p class=pi style='tab-stops:255.0pt'><span lang=EN-US>body_form([not
Lit|List],-Lit &amp; Conj):-!,<br>
body_form(List,Conj).</span></p>

<p class=pi-laatst style='tab-stops:255.0pt'><span lang=EN-US>body_form([Lit|List],Lit
&amp; Conj):-<br>
body_form(List,Conj).</span></p>

<p class=oms style='page-break-after:auto'><span lang=EN-US>%
body_quants(BV,HV,C,QC) &lt;- QC is conj. C extended with <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>existential quant.s for all <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>variables in BV but not in HV</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>body_quants([],HeadVars,Conj,Conj).</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>body_quants([BVar|BVars],HeadVars,Conj,exists(BVar,F)):-<br>
not var_element(BVar,HeadVars),<br>
body_quants(BVars,HeadVars,Conj,F).</span></p>

<p class=pi-laatst><span lang=EN-US>body_quants([BVar|BVars],HeadVars,Conj,F):-<br>
var_element(BVar,HeadVars),<br>
body_quants(BVars,HeadVars,Conj,F).</span></p>

<p class=oms><span lang=EN-US>% complete_formula(C,F,H) &lt;- F is disjunction
of bodies <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>of
clauses in C, and univ. <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>quantified head H</span></p>

<p class=pi-laatst><span lang=EN-US>complete_formula(C,Formula,Head):-<br>
combine_clauses(C,Head,Body),<br>
varsin(Head,HeadVars),<br>
head_quants(HeadVars,Head =&gt; Body,Formula).</span></p>

<p class=pi><span lang=EN-US>combine_clauses([([Head]:-Body)],Head,Body):- !.</span></p>

<p class=pi-laatst><span lang=EN-US>combine_clauses([([Head]:-Body)|R],Head,Body
v RBody):-<br>
combine_clauses(R,Head,RBody).</span></p>

<p class=pi><span lang=EN-US>head_quants([],Formula,Formula).</span></p>

<p class=pi-laatst><span lang=EN-US>head_quants([HVar|HVars],Formula,forall(HVar,F)):-<br>
head_quants(HVars,Formula,F).</span></p>

<p class=sektie><span lang=EN-US>The following query illustrates the operation
of the program, and shows also how it can be combined with the program for
conversion to clausal form presented in the previous section.</span></p>

<p class=query><span lang=EN-US>?-P=[([bird(tweety)]:-[]),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp; </span>([flies(X)]:-[bird(X),not
abnormal(X)])],<br>
complete(P,F),<br>
transform(F,C).</span></p>

<p class=query><span lang=EN-US>F=forall(Y,-abnormal(Y)) &amp; <br>
forall(Z,bird(Z) =&gt; Z=tweety) &amp; <br>
forall(X,flies(X) =&gt; bird(X) &amp; -abnormal(X))</span></p>

<p class=query><span lang=EN-US>C=[([]:-[abnormal(Y)]),<br>
<span style="mso-spacerun:yes">&nbsp;</span>([Z=tweety]:-[bird(Z)]),<br>
<span style="mso-spacerun:yes">&nbsp;</span>([bird(X)]:-[flies(X)]),<br>
<span style="mso-spacerun:yes">&nbsp;</span>([]:-[flies(X),abnormal(X)])]</span></p>

</div>

<span lang=EN-US style='font-size:10.0pt;font-family:Courier;mso-fareast-font-family:
"Times New Roman";mso-bidi-font-family:Courier;mso-ansi-language:EN-US;
mso-fareast-language:EN-US;mso-bidi-language:AR-SA'><br clear=all
style='page-break-before:right;mso-break-type:section-break'>
</span>

<div class=WordSection4>

<p id="answers_to_selected_exercises" class=cijfer><span lang=EN-US>C</span></p>

<h2 id="h_answers_to_selected_exercises"><span lang=EN-US>Answers to selected exercises</span></h2>

<p class=sektie1><span lang=EN-US>Below, answers to selected exercises can be
found. Not all answers have been included, due to two reasons. Some of the
questions only lead to a new insight when the answer is actually constructed,
and the student is encouraged to do so. Furthermore, some other questions
embody small programming projects, and don&rsquo;t have straightforward answers. </span></p>

<p class=sektie><span lang=EN-US>The remaining questions have been constructed
to highlight a particular point in the discussion (which, incidentally, is the
reason that they are printed throughout the text, and not at the end of each
chapter). They are most advantageous when addressed as soon as they are
encountered. The answers provided here can then be used to check and assess
one&rsquo;s own solution. Most of the answers contain additional explanatory remarks.
</span></p>

<p class=sektie><span lang=EN-US>Alternatively, this appendix can be read
separately, after the previous chapters have been studied. To this end, some of
the questions have been reformulated so as to minimise references to the
original text. </span></p>

<h3 id="a_brief_introduction_to_clausal_logic_c"><span lang=EN-US>C.1<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>A
brief introduction to clausal logic</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 1.2.</span></i><span lang=EN-US> Construct the proof
  trees for the query <br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>?-nearby(W,charing_cross)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>There are six answers to this query:</span></p>

<p class=p-el><span lang=EN-US style='font-family:Times'>{</span><span
lang=EN-US>W</span><span lang=EN-US style='font-family:Symbol'>&rarr;</span><span
lang=EN-US>green_park</span><span lang=EN-US style='font-family:Times'>}</span><span
lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>W</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US>piccadilly_circus</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>W</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US>leicester_square</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>W</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US>bond_street</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>W</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US>oxford_circus</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>W</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US>tottenham_court_road</span><span
lang=EN-US style='font-family:Times'>}<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>The proof trees for the first three answers are
analogous to fig. 1.2. The proof tree for the fourth answer is given below (the
two remaining proof trees are similar): </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="Picture_x0020_1" o:spid="_x0000_i1039" type="#_x0000_t75"
 style='width:330pt;height:165pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image001.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image002.svg" v:shapes="Picture_x0020_1"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 1.4.</span></i><span lang=EN-US> A list is either the
  empty list </span><span lang=EN-US style='font-family:Courier'>[]</span><span
  lang=EN-US>, or a non-empty list </span><span lang=EN-US style='font-family:
  Courier'>[First|Rest]</span><span lang=EN-US> where </span><span lang=EN-US
  style='font-family:Courier'>Rest</span><span lang=EN-US> is a list. Define a
  relation </span><span lang=EN-US style='font-family:Courier'>list(L)</span><span
  lang=EN-US>, which checks whether </span><span lang=EN-US style='font-family:
  Courier'>L</span><span lang=EN-US> is a list. Adapt it such that it succeeds
  only for lists of (<i style='mso-bidi-font-style:normal'>i</i>) even length
  and (<i style='mso-bidi-font-style:normal'>ii</i>) odd length.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The first specification can immediately be
translated to Prolog: </span></p>

<p class=pi-eerst><span lang=EN-US>list</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;list/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([]).</span></p>

<p class=pi-laatst><span lang=EN-US>list([First|Rest]):-list(Rest).</span></p>

<p class=tekst><span lang=EN-US>A list of even length is either the empty list,
or a non-empty list with two more elements than the next shorter list of even
length: </span></p>

<p class=pi-eerst><span lang=EN-US>evenlist</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;evenlist/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([]).</span></p>

<p class=pi-laatst><span lang=EN-US>evenlist([First,Second|Rest]):-evenlist(Rest).</span></p>

<p class=tekst><span lang=EN-US>In order to adapt this definition for lists of
odd length, only the non-recursive clause needs to be changed: </span></p>

<p class=pi-eerst><span lang=EN-US>oddlist</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;oddlist/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([One]).</span></p>

<p class=pi-laatst><span lang=EN-US>oddlist([First,Second|Rest]):-oddlist(Rest).</span></p>

<p class=tekst><span lang=EN-US>Notice that </span><span lang=EN-US
style='font-family:Courier'>oddlist</span><span lang=EN-US> can also be defined
in terms of </span><span lang=EN-US style='font-family:Courier'>evenlist</span><span
lang=EN-US> (or <i style='mso-bidi-font-style:normal'>vice versa</i>): </span></p>

<p class=p-el><span lang=EN-US>oddlist([First|Rest]):-evenlist(Rest).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 1.5.</span></i><span lang=EN-US> Construct a query asking
  for a route from Bond Street to Piccadilly Circus with at least two
  intermediate stations.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=p-el><span lang=EN-US>?-reachable(bond_street,piccadilly_circus,[S1,S2|Rest]).</span></p>

<h3 id="clausal_logic_and_resolution_theoretical_backgrounds_c"><span lang=EN-US>C.2<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Clausal
logic and resolution: theoretical backgrounds</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.1.</span></i><span lang=EN-US> Translate the following
  statements into clauses, using the atoms </span><span lang=EN-US
  style='font-family:Courier'>person</span><span lang=EN-US>, </span><span
  lang=EN-US style='font-family:Courier'>sad</span><span lang=EN-US> and </span><span
  lang=EN-US style='font-family:Courier'>happy</span><span lang=EN-US>:<br>
  (<i style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>persons
  are happy or sad;<br>
  (<i style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>no
  person is both happy and sad;<br>
  (<i style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>sad
  persons are not happy;<br>
  (<i style='mso-bidi-font-style:normal'>d</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>non-happy
  persons are sad.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The statements should be read as &lsquo;<b
style='mso-bidi-font-weight:normal'>if</b> &hellip; <b style='mso-bidi-font-weight:
normal'>then</b> &hellip;&rsquo; statements. Thus, the first statement reads &lsquo;<b
style='mso-bidi-font-weight:normal'>if</b> somebody is a person, <b
style='mso-bidi-font-weight:normal'>then</b> she is happy or sad&rsquo;: </span></p>

<p class=opsomming style='tab-stops:225.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>happy;sad:-person<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>The second statement reads &lsquo;<b
style='mso-bidi-font-weight:normal'>if</b> somebody is a person, <b
style='mso-bidi-font-weight:normal'>then</b> she is not both happy and sad&rsquo;. In
clausal logic, only positive conclusions can be drawn; negative conclusions are
turned into positive conditions, as follows: &lsquo;<b style='mso-bidi-font-weight:
normal'>if</b> somebody is a person, and she is happy and sad, <b
style='mso-bidi-font-weight:normal'>then</b> contradiction&rsquo;. A contradictory
conclusion is signalled by the empty head: </span></p>

<p class=opsomming style='tab-stops:225.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>:-person,happy,sad<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>Following the same recipe, the third statement
expresses that &lsquo;<b style='mso-bidi-font-weight:normal'>if</b> somebody is a
person who is sad, and she is happy, <b style='mso-bidi-font-weight:normal'>then</b>
contradiction&rsquo;: </span></p>

<p class=opsomming style='tab-stops:225.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>:-person,sad,happy<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>Thus, sentences (<i style='mso-bidi-font-style:
normal'>b</i>) and (<i style='mso-bidi-font-style:normal'>c</i>) convey the
same logical meaning.</span></p>

<p class=sektie><span lang=EN-US>Finally, the fourth sentence reads &lsquo;<b
style='mso-bidi-font-weight:normal'>if</b> somebody is a person who is not
happy, <b style='mso-bidi-font-weight:normal'>then</b> she is sad&rsquo;. In clausal
logic, only positive conditions can be used; therefore, this negative condition
should be turned into a positive conclusion: &lsquo;<b style='mso-bidi-font-weight:
normal'>if</b> somebody is a person, <b style='mso-bidi-font-weight:normal'>then</b>
she is sad or happy&rsquo;. We thus obtain the same clause as in case (<i
style='mso-bidi-font-style:normal'>a</i>): </span></p>

<p class=opsomming style='tab-stops:225.0pt'><span lang=EN-US>(<i
style='mso-bidi-font-style:normal'>d</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>sad;happy:-person<o:p></o:p></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.2.</span></i><span lang=EN-US> Given the program<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>married;bachelor:-man,adult.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>man.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>:-bachelor.</span><span
  lang=EN-US><br>
  determine which of the following clauses are logical consequences of this
  program:<br>
  (<i style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>married:-adult</span><span lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>married:-bachelor</span><span
  lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>bachelor:-man</span><span lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>d</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>bachelor:-bachelor</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>a</i>)
Any model of the first clause, which additionally makes </span><span
lang=EN-US style='font-family:Courier'>man</span><span lang=EN-US> <b
style='mso-bidi-font-weight:normal'>true</b>, is also a model of the clause </span><span
lang=EN-US style='font-family:Courier'>married;bachelor:-adult</span><span
lang=EN-US>. Likewise, any model of this clause which additionally makes </span><span
lang=EN-US style='font-family:Courier'>bachelor</span><span lang=EN-US> <b
style='mso-bidi-font-weight:normal'>false</b> is also a model of the clause </span><span
lang=EN-US style='font-family:Courier'>married:-adult</span><span lang=EN-US>,
which is therefore a logical consequence of the program. </span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>b</i>)
The body of this clause is <b style='mso-bidi-font-weight:normal'>false</b> in
any model of the program, and therefore the clause is <b style='mso-bidi-font-weight:
normal'>true</b> in any such model. </span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>c</i>)
The body of this clause is <b style='mso-bidi-font-weight:normal'>true</b> in
any model of the program, while its head is <b style='mso-bidi-font-weight:
normal'>false</b>. The clause is therefore not a logical consequence of the
program (on the contrary, it is <b style='mso-bidi-font-weight:normal'>false</b>
in every model of the program, not just in some). </span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>d</i>)
This clause is a <i style='mso-bidi-font-style:normal'>tautology</i>: it is <b
style='mso-bidi-font-weight:normal'>true</b> in any interpretation, and
therefore a logical consequence of any program. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.3.</span></i><span lang=EN-US> Write down the six
  Herbrand interpretations that are not models of the program <br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>married;bachelor:-man,adult.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>has_wife:-man,married.<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The six interpretations are: </span></p>

<p class=p-el><span lang=EN-US style='font-family:Times'>{</span><span
lang=EN-US>man</span><span lang=EN-US style='font-family:Times'>, </span><span
lang=EN-US>adult</span><span lang=EN-US style='font-family:Times'>}</span><span
lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>man</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>adult</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>has_wife</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>man</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>married</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>man</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>married</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>adult</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>man</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>married</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>bachelor</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>man</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>married</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>adult</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>bachelor</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>The first two interpretations satisfy the body
of the first clause but violate its head; the remaining four interpretations
satisfy the body of the second clause but violate its head. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.4.</span></i><span lang=EN-US> Give a derivation of </span><span
  lang=EN-US style='font-family:Courier'>friendly</span><span lang=EN-US> from
  the following program:<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>happy;friendly:-teacher.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly:-teacher,happy.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher;wise.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher:-wise.<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This requires derivations of the clauses </span><span
lang=EN-US style='font-family:Courier'>friendly:-teacher</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>teacher</span><span
lang=EN-US>: </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_2" o:spid="_x0000_i1038" type="#_x0000_t75" style='width:340pt;
 height:87pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image003.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image004.svg" v:shapes="Picture_x0020_2"><![endif]></span></p>

<p class=tekst><span lang=EN-US>Notice that this derivation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;derivation&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>can not be recast in the
form of a linear tree, where each resolvent is obtained from the previous
resolvent and a given clause, as in Chapter 1. This is due to the fact that
some clauses are indefinite</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;clause:indefinite&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(have more than one
positive literal). </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.5.</span></i><span lang=EN-US> Prove by refutation that
  </span><span lang=EN-US style='font-family:Courier'>friendly:-has_friends</span><span
  lang=EN-US> is a logical consequence of the following clauses: <br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>happy:-has_friends.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly:-happy.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The negation of </span><span lang=EN-US
style='font-family:Courier'>friendly:-has_friends</span><span lang=EN-US>
consists of two clauses, </span><span lang=EN-US style='font-family:Courier'>:&#8209;friendly</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>has_friends</span><span
lang=EN-US>. Together, these four clauses are inconsistent: </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_3" o:spid="_x0000_i1037" type="#_x0000_t75" style='width:166pt;
 height:141pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image005.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image006.svg" v:shapes="Picture_x0020_3"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.6.</span></i><span lang=EN-US> How many models does the
  following clause have over the Herbrand universe {</span><span lang=EN-US
  style='font-family:Courier'>peter</span><span lang=EN-US>, </span><span
  lang=EN-US style='font-family:Courier'>maria</span><span lang=EN-US>}: <br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>likes(peter,S):-student_of(S,peter)</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The set of ground instances of this clause is</span></p>

<p class=p-el style='margin-left:24.0pt;text-indent:-7.0pt'><span lang=EN-US
style='font-family:Times'>{ </span><span lang=EN-US>likes(peter,maria):-student_of(maria,peter)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US><br>
likes(peter,peter):-student_of(peter,peter)</span><span lang=EN-US
style='font-family:Times'> }<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>and the Herbrand base is </span></p>

<p class=p-el style='margin-left:28.0pt;text-indent:-11.0pt'><span lang=EN-US
style='font-family:Times'>{<span style='mso-tab-count:1'>&nbsp; </span></span><span
lang=EN-US>likes(peter,peter)</span><span lang=EN-US style='font-family:Times'>,
</span><span lang=EN-US>likes(peter,maria)</span><span lang=EN-US
style='font-family:Times'>, <br>
</span><span lang=EN-US>likes(maria,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>likes(maria,maria)</span><span
lang=EN-US style='font-family:Times'>, <br>
</span><span lang=EN-US>student_of(peter,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>student_of(peter,maria)</span><span
lang=EN-US style='font-family:Times'>, <br>
</span><span lang=EN-US>student_of(maria,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>student_of(maria,maria)</span><span
lang=EN-US style='font-family:Times'> }</span></p>

<p class=tekst><span lang=EN-US>Only the left four ground atoms are relevant
for determining whether an interpretation is a model. 9 out of 16 truth-value
assignments to these ground atoms result in a model. Because of the 4
irrelevant ground atoms, this yields 9*2</span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:-3.0pt;mso-text-raise:3.0pt'>4</span><span
lang=EN-US>=144 models. Notice that this is a rather large number of models for
such a modest Herbrand universe, and such a simple clause! This illustrates
that <i style='mso-bidi-font-style:normal'>less knowledge leads to more models</i>.
</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.7</span></i><span lang=EN-US>. Write a clause
  expressing that Peter teaches all the first-year courses, and apply
  resolution to this clause and the clause<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>likes(peter,maria):-follows(maria,C),teaches(peter,C)</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This is expressed by the clause</span></p>

<p class=p-el><span lang=EN-US>teaches(peter,C):-first_year_course(C)</span></p>

<p class=tekst><span lang=EN-US>Resolution with the above clause yields </span></p>

<p class=p-el><span lang=EN-US>likes(peter,maria):-follows(maria,C),first_year_course(C)</span></p>

<p class=tekst><span lang=EN-US>In words: &lsquo;Peter likes Maria <b
style='mso-bidi-font-weight:normal'>if</b> Maria follows a first-year course&rsquo;. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.9</span></i><span lang=EN-US>. Translate to clausal
  logic:<br>
  (<i style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>every
  mouse has a tail;<br>
  (<i style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>somebody
  loves everybody;<br>
  (<i style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>every
  two numbers have a maximum.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>a</i>)
This statement should be read as &lsquo;<b style='mso-bidi-font-weight:normal'>if</b>
<i style='mso-bidi-font-style:normal'>X</i> is a mouse, <b style='mso-bidi-font-weight:
normal'>then</b> there exists something which is <i style='mso-bidi-font-style:
normal'>X</i>&rsquo;s tail&rsquo;. Giving <i style='mso-bidi-font-style:normal'>X</i>&rsquo;s
tail the abstract name </span><span lang=EN-US style='font-family:Courier'>tail(X)</span><span
lang=EN-US>, we obtain the following clause: </span></p>

<p class=p-el><span lang=EN-US>tail_of(tail(X),X):-mouse(X)</span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>b</i>)
Here we need to give the person who loves everybody an abstract name. Since
this person does not depend on anybody else, it can simply be a constant: </span></p>

<p class=p-el><span lang=EN-US>loves(person_who_loves_everybody,X)</span></p>

<p class=tekst><span lang=EN-US>Notice the difference with the statement
&lsquo;everybody loves somebody&rsquo;: </span></p>

<p class=p-el><span lang=EN-US>loves(X,person_loved_by(X))</span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>c</i>)
This statement should be read as &lsquo;<b style='mso-bidi-font-weight:normal'>if</b>
<i style='mso-bidi-font-style:normal'>X</i> and <i style='mso-bidi-font-style:
normal'>Y</i> are numbers, then there exists a number which is their maximum&rsquo;.
Giving this maximum the abstract name </span><span lang=EN-US style='font-family:
Courier'>max(X,Y)</span><span lang=EN-US> yields the clause </span></p>

<p class=p-el><span lang=EN-US>maximum(X,Y,max(X,Y)):-number(X),number(Y)</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.10</span></i><span lang=EN-US>. Determine the Herbrand
  universe of the following program:<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>length([],0).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>length([X|Y],s(L)):-length(Y,L).<br>
  </span><span lang=EN-US>(Hint: recall that </span><span lang=EN-US
  style='font-family:Courier'>[]</span><span lang=EN-US> is a constant, and
  that </span><span lang=EN-US style='font-family:Courier'>[X|Y]</span><span
  lang=EN-US> is an alternative notation for the complex term </span><span
  lang=EN-US style='font-family:Courier'>.(X,Y)</span><span lang=EN-US> with
  binary functor &lsquo;</span><span lang=EN-US style='font-family:Courier'>.</span><span
  lang=EN-US>&rsquo;!)</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>In the intended interpretation, </span><span
lang=EN-US style='font-family:Courier'>s</span><span lang=EN-US> is restricted
to numbers and &lsquo;</span><span lang=EN-US style='font-family:Courier'>.</span><span
lang=EN-US>&rsquo; is restricted to lists; however, variables are untyped in clausal
logic, and the two sets of terms may be mixed.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;variable:type&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>Thus, the Herbrand
universe</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand universe&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>will contain terms
denoting numbers, such as </span></p>

<p class=p-el><span lang=EN-US>0</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>s(0)</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>s(s(0))</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>s(s(s(0)))</span><span
lang=EN-US style='font-family:Times'>, &hellip;<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>and terms denoting lists of numbers, such as</span></p>

<p class=p-el><span lang=EN-US>[]</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>[0]</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>[s(0),0]</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>[s(s(0)),s(0),0]</span><span
lang=EN-US style='font-family:Times'>, &hellip;<o:p></o:p></span></p>

<p class=tekst><span lang=EN-US>but also &lsquo;strange&rsquo; terms like</span></p>

<p class=p-el><span lang=EN-US>[[[0]]]</span><span lang=EN-US style='font-family:
Times'> or </span><span lang=EN-US>.(.(.(0,[]),[]),[])<br>
[s(0)|0]</span><span lang=EN-US style='font-family:Times'> or </span><span
lang=EN-US>.(s(0),0)<br>
[s([[]|0])]</span></p>

<p class=tekst><span lang=EN-US>and so on. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.11</span></i><span lang=EN-US>. If possible, unify the
  following pairs of terms:<br>
  (<i style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>plus(X,Y,s(Y))</span><span lang=EN-US>
  and </span><span lang=EN-US style='font-family:Courier'>plus(s(V),W,s(s(V)))</span><span
  lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>length([X|Y],s(0))</span><span
  lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>length([V],V)</span><span
  lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>larger(s(s(X)),X)</span><span
  lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>larger(V,s(V))</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>a</i>) </span><span
lang=EN-US style='font-family:Courier'>plus(s(V),s(V),s(s(V)))</span><span
lang=EN-US>.</span></p>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>b</i>) </span><span
lang=EN-US style='font-family:Courier'>length([s(0)],s(0))</span><span
lang=EN-US>.</span></p>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>c</i>)
Not unifiable.</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.13.</span></i><span lang=EN-US> Write a clause for the
  statement &lsquo;somebody is innocent unless proven guilty&rsquo;, and give its intended
  model (supposing that </span><span lang=EN-US style='font-family:Courier'>john</span><span
  lang=EN-US> is the only individual in the Herbrand universe).</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The clause is </span></p>

<p class=p-el><span lang=EN-US>innocent(X):-not guilty(X) </span></p>

<p class=tekst><span lang=EN-US>with intended model {</span><span lang=EN-US
style='font-family:Courier'>innocent(john)</span><span lang=EN-US>}.</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 2.14</span></i><span lang=EN-US>. Translate to clausal
  logic:<br>
  (<i style='mso-bidi-font-style:normal'>a</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Symbol'>&forall;</span><span lang=EN-US
  style='font-family:Courier'>X</span><span lang=EN-US style='font-family:Symbol'>&exist;</span><span
  lang=EN-US style='font-family:Courier'>Y: mouse(X)</span><span lang=EN-US
  style='font-family:Symbol'>&rarr;</span><span lang=EN-US style='font-family:Courier'>tail_of(Y,X)</span><span
  lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>b</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Symbol'>&forall;</span><span lang=EN-US
  style='font-family:Courier'>X</span><span lang=EN-US style='font-family:Symbol'>&exist;</span><span
  lang=EN-US style='font-family:Courier'>Y: loves(X,Y)</span><span lang=EN-US
  style='font-family:Symbol'>&and;</span><span lang=EN-US style='font-family:Courier'>(</span><span
  lang=EN-US style='font-family:Symbol'>&forall;</span><span lang=EN-US
  style='font-family:Courier'>Z: loves(Y,Z))</span><span lang=EN-US>;<br>
  (<i style='mso-bidi-font-style:normal'>c</i>)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Symbol'>&forall;</span><span lang=EN-US
  style='font-family:Courier'>X</span><span lang=EN-US style='font-family:Symbol'>&forall;</span><span
  lang=EN-US style='font-family:Courier'>Y</span><span lang=EN-US
  style='font-family:Symbol'>&exist;</span><span lang=EN-US style='font-family:Courier'>Z:
  number(X)</span><span lang=EN-US style='font-family:Symbol'>&and;</span><span
  lang=EN-US style='font-family:Courier'>number(Y)</span><span lang=EN-US
  style='font-family:Symbol'>&rarr;</span><span lang=EN-US style='font-family:Courier'>maximum(X,Y,Z)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>a</i>)
This statement translates almost immediately into a clause, replacing the
existential quantifier by a Skolem functor</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Skolem
functor&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span></span><span lang=EN-US
style='font-family:Courier'>tail</span><span lang=EN-US>: </span></p>

<p class=p-el style='margin-left:56.0pt'><span lang=EN-US>tail_of(tail(X),X):-mouse(X)</span></p>

<p class=answer><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>b</i>)
This formula is already in conjunctive normal form, and each conjunct yields a
separate clause. After replacing the existential quantifier by a Skolem functor
</span><span lang=EN-US style='font-family:Courier'>person_loved_by</span><span
lang=EN-US>, we obtain </span></p>

<p class=p-el style='margin-left:56.0pt'><span lang=EN-US>loves(X,person_loved_by(X)).<br>
loves(person_loved_by(X),Z).</span></p>

<p class=tekst><span lang=EN-US>Notice that the two clauses are &lsquo;linked&rsquo; by the
Skolem functor. </span></p>

<p class=sektie><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>c</i>)
Here, the Skolem functor has two arguments: </span></p>

<p class=p-el style='margin-left:56.0pt'><span lang=EN-US>maximum(X,Y,max(X,Y)):-number(X),number(Y)</span></p>

<p class=tekst><span lang=EN-US>See also Exercise 2.9. </span></p>

<h3 id="logic_programming_and_prolog_c"><span lang=EN-US>C.3<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Logic
Programming and Prolog</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.2.</span></i><span lang=EN-US> Draw the SLD-tree for
  the following program:<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>list([]).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>list([H|T]):-list(T).</span><span
  lang=EN-US><br>
  and the query </span><span lang=EN-US style='font-family:Courier'>?-list(L)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This is one of the simplest infinite
SLD-trees: </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_4" o:spid="_x0000_i1036" type="#_x0000_t75" style='width:181pt;
 height:137pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image007.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image008.svg" v:shapes="Picture_x0020_4"><![endif]></span></p>

<p class=tekst><span lang=EN-US>The query succeeds infinitely often, producing
the answers: </span></p>

<p class=p-el><span lang=EN-US>L = [];<br>
L = [X1,X2];<br>
L = [Y1,Y2,Y3];<br>
L = [Z1,Z2,Z3,Z4];</span></p>

<p class=tekst><span lang=EN-US>and so on. Note that reversing the order of the
clauses means that Prolog gives no answer at all. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.3.</span></i><span lang=EN-US> Draw the SLD-tree for
  the query </span><span lang=EN-US style='font-family:Courier'>?-likes(A,B)</span><span
  lang=EN-US>, given the following program:<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>likes(peter,Y):-friendly(Y).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>likes(T,S):-student_of(S,T).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>student_of(maria,peter).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>student_of(paul,peter).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly(maria).<br>
  </span><span lang=EN-US>Add a cut in order to prune away one of the answers {</span><span
  lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US
  style='font-family:Symbol'>&rarr;</span><span lang=EN-US style='font-family:Courier'>peter</span><span
  lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>B</span><span
  lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US
  style='font-family:Courier'>maria</span><span lang=EN-US>}, and indicate the
  result in the SLD-tree. Can this be done without pruning away the third
  answer?</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This program produces three answers: </span></p>

<p class=answer><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_5" o:spid="_x0000_i1035" type="#_x0000_t75" style='width:169pt;
 height:84pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image009.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image010.svg" v:shapes="Picture_x0020_5"><![endif]></span></p>

<p class=tekst><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=tekst><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=tekst><span lang=EN-US>Adding a cut to the first clause (before or
after </span><span lang=EN-US style='font-family:Courier'>friendly(Y)</span><span
lang=EN-US>) will prune away two answers (left figure). Adding a cut to the
second clause can be done in two places: placing it just before the literal </span><span
lang=EN-US style='font-family:Courier'>student_of(S,T)</span><span lang=EN-US>
has no effect, while placing it at the end will only prune the answer {</span><span
lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US
style='font-family:Symbol'>&rarr;</span><span lang=EN-US style='font-family:Courier'>peter</span><span
lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>B</span><span
lang=EN-US style='font-family:Symbol'>&rarr;</span><span lang=EN-US
style='font-family:Courier'>paul</span><span lang=EN-US>} (right figure). </span></p>

<p class=sektie><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_6" o:spid="_x0000_i1034" type="#_x0000_t75" style='width:166pt;
 height:120pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image011.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image012.svg" v:shapes="Picture_x0020_6"><![endif]></span><span
lang=EN-US><span style='mso-tab-count:1'> </span><span style='mso-no-proof:
yes'><!--[if gte vml 1]><v:shape id="Picture_x0020_7" o:spid="_x0000_i1033"
 type="#_x0000_t75" style='width:171pt;height:118pt;visibility:visible;
 mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image013.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image014.svg" v:shapes="Picture_x0020_7"><![endif]></span></span></p>

<p class=tekst><span lang=EN-US><o:p>&nbsp;</o:p></span></p>

<p class=tekst><span lang=EN-US>If in addition the two </span><span lang=EN-US
style='font-family:Courier'>student_of</span><span lang=EN-US> clauses are
swapped, only the second answer {</span><span lang=EN-US style='font-family:
Courier'>A</span><span lang=EN-US style='font-family:Symbol'>&rarr;</span><span
lang=EN-US style='font-family:Courier'>peter</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>B</span><span lang=EN-US
style='font-family:Symbol'>&rarr;</span><span lang=EN-US style='font-family:Courier'>maria</span><span
lang=EN-US>} is pruned. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.5.</span></i><span lang=EN-US> Given the program<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>bachelor(X):-not(married(X)),man(X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>man(fred).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>man(peter).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>married(fred).<br>
  </span><span lang=EN-US>draw the SLD-trees for the queries </span><span
  lang=EN-US style='font-family:Courier'>?-bachelor(fred)</span><span
  lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>?&#8209;bachelor(peter)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_8" o:spid="_x0000_i1032" type="#_x0000_t75" style='width:363pt;
 height:132pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image015.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image016.svg" v:shapes="Picture_x0020_8"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.6.</span></i><span lang=EN-US> Change the first clause
  to<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>bachelor(X):-not(married(X)),man(X)<br>
  </span><span lang=EN-US>and show that the modified program produces the right
  answer, by drawing the SLD-tree for the query </span><span lang=EN-US
  style='font-family:Courier'>?-bachelor(X)</span><span lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_9" o:spid="_x0000_i1031" type="#_x0000_t75" style='width:286pt;
 height:157pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image017.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image018.svg" v:shapes="Picture_x0020_9"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  0cm;margin-left:0cm;margin-bottom:.0001pt'><i style='mso-bidi-font-style:
  normal'><span lang=EN-US>Exercise 3.7.</span></i><span lang=EN-US> Given the
  program<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>p:-q,r,s,!,t.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p:-q,r,u.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>q.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>r.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>u.<br>
  </span><span lang=EN-US>show that the query </span><span lang=EN-US
  style='font-family:Courier'>?-p</span><span lang=EN-US> succeeds, but that </span><span
  lang=EN-US style='font-family:Courier'>q</span><span lang=EN-US> and </span><span
  lang=EN-US style='font-family:Courier'>r</span><span lang=EN-US> are tried
  twice.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_10" o:spid="_x0000_i1030" type="#_x0000_t75" style='width:103pt;
 height:128pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image019.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image020.svg" v:shapes="Picture_x0020_10"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.8.</span></i><span lang=EN-US> Given the equivalent
  program with if-then-else<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>p:-q,r,if_s_then_t_else_u.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if_s_then_t_else_u:-s,!,t.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if_s_then_t_else_u:-u.<br>
  show</span><span lang=EN-US> that </span><span lang=EN-US style='font-family:
  Courier'>q</span><span lang=EN-US> and </span><span lang=EN-US
  style='font-family:Courier'>r</span><span lang=EN-US> are now tried only
  once.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_11" o:spid="_x0000_i1029" type="#_x0000_t75" style='width:116pt;
 height:156pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image021.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=35%
src="Appendix_files/image022.svg" v:shapes="Picture_x0020_11"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.9.</span></i><span lang=EN-US> Write a predicate </span><span
  lang=EN-US style='font-family:Courier'>zero(A,B,C,X)</span><span lang=EN-US>
  which, given the coefficients <i style='mso-bidi-font-style:normal'>a</i>, <i
  style='mso-bidi-font-style:normal'>b</i> and <i style='mso-bidi-font-style:
  normal'>c</i>, calculates both values of <i style='mso-bidi-font-style:normal'>x</i>
  for which <i style='mso-bidi-font-style:normal'>ax</i></span><span
  lang=EN-US style='font-size:7.0pt;position:relative;top:-3.0pt;mso-text-raise:
  3.0pt'>2</span><span lang=EN-US>+<i style='mso-bidi-font-style:normal'>bx</i>+<i
  style='mso-bidi-font-style:normal'>c</i>=0.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=pi-eerst><span lang=EN-US>zero(A,B,C,X):-<br>
X is (-B + sqrt(B*B - 4*A*C)) / 2*A.</span></p>

<p class=pi-laatst><span lang=EN-US>zero(A,B,C,X):-<br>
X is (-B - sqrt(B*B - 4*A*C)) / 2*A.</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.10.</span></i><span lang=EN-US> Given the program<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>length([],0).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>length([H|T],N):-length(T,M),N
  is M+1.<br>
  </span><span lang=EN-US>draw the proof tree for the query </span><span
  lang=EN-US style='font-family:Courier'>?-length([a,b,c],N)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_12" o:spid="_x0000_i1028" type="#_x0000_t75" style='width:264pt;
 height:290pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image023.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image024.svg" v:shapes="Picture_x0020_12"><![endif]></span></p>

<p class=tekst><span lang=EN-US>Notice that the maximum number of literals in
the resolvent is proportional to the depth of the recursion, which is typical
for non-tail recursive predicates. When proofs are long, such programs will be
quite inefficient. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm;tab-stops:48.0pt 69.0pt'><i style='mso-bidi-font-style:
  normal'><span lang=EN-US>Exercise 3.11.</span></i><span lang=EN-US> Given the
  program<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>length_acc(L,N):-length_acc(L,0,N).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>length_acc([],N,N).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>length_acc([H|T],N0,N):-N1
  is N0+1,length_acc(T,N1,N).<br>
  </span><span lang=EN-US>draw the proof tree for the query </span><span
  lang=EN-US style='font-family:Courier'>?-length_acc([a,b,c],N)</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>In this program, the </span><span lang=EN-US
style='font-family:Courier'>is</span><span lang=EN-US> literals are solved
immediately after they are added to the resolvent: </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_13" o:spid="_x0000_i1027" type="#_x0000_t75" style='width:356pt;
 height:356pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image025.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image026.svg" v:shapes="Picture_x0020_13"><![endif]></span></p>

<p class=tekst><span lang=EN-US>Here, the length of the resolvent is
independent of the level of recursion, which makes tail-recursive loops very
similar to iterative loops with regard to memory requirements. </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;iteration&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;recursion:memory requirements&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tail recursion&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.13.</span></i><span lang=EN-US> In the </span><span
  lang=EN-US style='font-family:Courier'>naive_reverse</span><span lang=EN-US>
  predicate, represent the reversed list by a difference list, use </span><span
  lang=EN-US style='font-family:Courier'>append_dl</span><span lang=EN-US>
  instead of </span><span lang=EN-US style='font-family:Courier'>append</span><span
  lang=EN-US>, and show that this results in the predicate </span><span
  lang=EN-US style='font-family:Courier'>reverse_dl</span><span lang=EN-US> by
  unfolding the definition of </span><span lang=EN-US style='font-family:Courier'>append_dl</span><span
  lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The reversed lists are represented by
difference lists as follows: </span></p>

<p class=opsomming><span lang=EN-US>&bull;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(partly)
specified lists are extended with a variable representing the minus list, e.g. </span><span
lang=EN-US style='font-family:Courier'>[]</span><span lang=EN-US> becomes </span><span
lang=EN-US style='font-family:Courier'>R-R</span><span lang=EN-US>, and </span><span
lang=EN-US style='font-family:Courier'>[H]</span><span lang=EN-US> becomes </span><span
lang=EN-US style='font-family:Courier'>[H|Minus]-Minus</span><span lang=EN-US>;</span></p>

<p class=opsomming><span lang=EN-US>&bull;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>a
variable representing a list is replaced by two variables representing the plus
and minus lists, e.g. </span><span lang=EN-US style='font-family:Courier'>R</span><span
lang=EN-US> becomes </span><span lang=EN-US style='font-family:Courier'>RPlus-RMinus</span><span
lang=EN-US>.</span></p>

<p class=pi-eerst><span lang=EN-US>reverse([],R-R).</span></p>

<p class=pi-laatst style='margin-left:41.0pt;text-indent:-24.0pt'><span
lang=EN-US>reverse([H|T],RPlus-RMinus):-<br>
reverse(T,R1Plus-R1Minus),<br>
append_dl(R1Plus&#8209;R1Minus,[H|Minus]&#8209;Minus,RPlus&#8209;RMinus).</span></p>

<p class=tekst><span lang=EN-US>Unfolding the call to </span><span lang=EN-US
style='font-family:Courier'>append_dl/3</span><span lang=EN-US> means that </span><span
lang=EN-US style='font-family:Courier'>R1Plus</span><span lang=EN-US> should be
unified with </span><span lang=EN-US style='font-family:Courier'>RPlus</span><span
lang=EN-US>, </span><span lang=EN-US style='font-family:Courier'>R1Minus</span><span
lang=EN-US> with </span><span lang=EN-US style='font-family:Courier'>[H|Minus]</span><span
lang=EN-US>, and </span><span lang=EN-US style='font-family:Courier'>Minus</span><span
lang=EN-US> with </span><span lang=EN-US style='font-family:Courier'>RMinus</span><span
lang=EN-US>, which yields </span></p>

<p class=pi-eerst><span lang=EN-US>reverse([],R-R).</span></p>

<p class=pi-laatst><span lang=EN-US>reverse([H|T],RPlus-RMinus):-<br>
reverse(T,RPlus-[H|RMinus]).</span></p>

<p class=tekst><span lang=EN-US>Renaming the variables results in the same
definition as </span><span lang=EN-US style='font-family:Courier'>reverse_dl/2</span><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>This illustrates that the translation from
simple lists to difference lists can (to a large extent) be automated. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.14.</span></i><span lang=EN-US> Rewrite the program for
  </span><span lang=EN-US style='font-family:Courier'>rel</span><span
  lang=EN-US>, using </span><span lang=EN-US style='font-family:Courier'>=..<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=pi-eerst><span lang=EN-US>rel(R,[],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>rel(R,[X|Xs],[Y|Ys]):-<br>
Goal =.. [R,X,Y],<br>
call(Goal),<br>
rel(R,Xs,Ys).</span></p>

<p class=tekst><span lang=EN-US>Note that, in contrast with the original
program, this program conforms to the syntax of clausal logic: there are no
variables in functor or literal positions. </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable:in functor position&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable:in literal position&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.15.</span></i><span lang=EN-US> Write a program which
  sorts and removes duplicates from a list, using </span><span lang=EN-US
  style='font-family:Courier'>setof</span><span lang=EN-US>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The basic idea is to use </span><span
lang=EN-US style='font-family:Courier'>element/2</span><span lang=EN-US> to
generate the elements of the list on backtracking, and to collect and sort them
by means of </span><span lang=EN-US style='font-family:Courier'>setof/2</span><span
lang=EN-US>. </span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sorting a list&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=pi-el><span lang=EN-US>sort(List,SortedList):-<br>
setof(X,element(X,List),SortedList).</span></p>

<p class=pi><span lang=EN-US>element(X,[X|Ys]).</span></p>

<p class=pi-laatst><span lang=EN-US>element(X,[Y|Ys]):-<br>
element(X,Ys).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.18.</span></i><span lang=EN-US> Implement a predicate </span><span
  lang=EN-US style='font-family:Courier'>permutation/2</span><span lang=EN-US>,
  such that </span><span lang=EN-US style='font-family:Courier'>permutation(L,P)</span><span
  lang=EN-US> is true if </span><span lang=EN-US style='font-family:Courier'>P</span><span
  lang=EN-US> contains the same elements as the list </span><span lang=EN-US
  style='font-family:Courier'>L</span><span lang=EN-US> but (possibly) in a
  different order, following these steps. (One auxiliary predicate is needed.)</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>As usual, we start with the declarative
specification: </span></p>

<p class=p-el><span lang=EN-US>% permutation(L,P) &lt;- P contains the same
elements as L <br>
%<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>(possibly
in a different order)</span></p>

<p class=tekst><span lang=EN-US>Taking the first argument as the recursion
argument and the second as the output argument, we obtain the following
skeleton: </span></p>

<p class=pi-eerst><span lang=EN-US>permutation([],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>permutation([Head|Tail],?Permutation):-<br>
/* do something with Head */<br>
permutation(Tail,Permutation).</span></p>

<p class=tekst><span lang=EN-US>Inserting </span><span lang=EN-US
style='font-family:Courier'>Head</span><span lang=EN-US> somewhere in </span><span
lang=EN-US style='font-family:Courier'>Permutation</span><span lang=EN-US>
should yield </span><span lang=EN-US style='font-family:Courier'>?Permutation</span><span
lang=EN-US>:</span></p>

<p class=pi-eerst><span lang=EN-US>permutation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;permutation/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>permutation([Head|Tail],WholePermutation):-<br>
insert_somewhere(Head,Permutation,WholePermutation),<br>
permutation(Tail,Permutation).</span></p>

<p class=sektie><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>insert_somewhere/3</span><span lang=EN-US> can be
obtained in the same way as the predicate </span><span lang=EN-US
style='font-family:Courier'>insert/3</span><span lang=EN-US> (section 3.9) by
ignoring the arithmetic conditions:</span></p>

<p class=pi-eerst><span lang=EN-US>insert_somewhere(X,[],[X]).</span></p>

<p class=pi><span lang=EN-US>insert_somewhere(X,[Head|Tail],[Head|Inserted]):-<br>
insert_somewhere(X,Tail,Inserted).</span></p>

<p class=pi-laatst><span lang=EN-US>insert_somewhere(X,[Head|Tail],[X,Head|Tail]).</span></p>

<p class=tekst><span lang=EN-US>This program, which is declaratively and
procedurally correct, can be slightly improved by noting that the first and
third clauses can be combined into a single base case:</span></p>

<p class=pi-eerst><span lang=EN-US>insert_somewhere</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;insert_somewhere/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(X,List,[X|List]).</span></p>

<p class=pi-laatst><span lang=EN-US>insert_somewhere(X,[Head|Tail],[Head|Inserted]):-<br>
insert_somewhere(X,Tail,Inserted).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 3.19.</span></i><span lang=EN-US> Implement an
  alternative sorting method by using the </span><span lang=EN-US
  style='font-family:Courier'>partition/4</span><span lang=EN-US> predicate. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This predicate implements the famous <i
style='mso-bidi-font-style:normal'>quicksort</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;quicksort&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>algorithm, which is one
of the most efficient sorting algorithms: </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sorting a list&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=pi-eerst><span lang=EN-US>quicksort</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;quicksort/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],[]).</span></p>

<p class=pi-laatst><span lang=EN-US>quicksort([X|Xs],Sorted):-<br>
partition(Xs,X,Littles,Bigs),<br>
quicksort(Littles,SortedLittles),<br>
quicksort(Bigs,SortedBigs),<br>
append(SortedLittles,[X|SortedBigs],Sorted).</span></p>

<p class=tekst><span lang=EN-US>The program can still be improved by employing
difference lists. </span></p>

<h3 id="representing_structured_knowledge_c"><span lang=EN-US>C.4<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Representing
structured knowledge</span></h3>

<p class=sektie1><span lang=EN-US>The exercises in this chapter should not
provide major difficulties. </span></p>

<h3 id="searching_graphs_c"><span lang=EN-US>C.5<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Searching
graphs</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm;tab-stops:48.0pt 114.0pt'><i style='mso-bidi-font-style:
  normal'><span lang=EN-US>Exercise 5.3.</span></i><span lang=EN-US> Consider
  the following program:<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(peter,paul).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(adrian,paul).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(X,Y):-brother(Y,X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>brother(X,Y):-brother(X,Z),brother(Z,Y).<br>
  </span><span lang=EN-US>Compare and explain the behaviour of </span><span
  lang=EN-US style='font-family:Courier'>prove_bf/1</span><span lang=EN-US> and
  Prolog on the query </span><span lang=EN-US style='font-family:Courier'>?&#8209;brother(peter,adrian)</span><span
  lang=EN-US>. Can you re-order the clauses, such that Prolog succeeds? </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>Prolog will be trapped in an infinite loop,
regardless of the order of the clauses. This is so because a refutation of </span><span
lang=EN-US style='font-family:Courier'>?&#8209;brother(peter,adrian)</span><span
lang=EN-US> requires both recursive clauses, but whichever is found first will
also be tried before the second one in all the other refutation steps. In
contrast, </span><span lang=EN-US style='font-family:Courier'>prove_bf/1</span><span
lang=EN-US> will be able to construct a refutation. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 5.5</span></i><span lang=EN-US>. Give the models of the
  program<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>married(X);bachelor(X):-man(X),adult(X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>has_wife(X):-married(X),man(X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>man(paul).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>adult(paul).<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This program has four models (bachelors may
have a wife, and married man may be bachelors): </span></p>

<p class=p-el><span lang=EN-US style='font-family:Times'>{</span><span
lang=EN-US>man(paul)</span><span lang=EN-US style='font-family:Times'>, </span><span
lang=EN-US>adult(paul)</span><span lang=EN-US style='font-family:Times'>, </span><span
lang=EN-US>bachelor(paul)</span><span lang=EN-US style='font-family:Times'>}<br>
{</span><span lang=EN-US>man(paul)</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>adult(paul)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>bachelor(paul)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>has_wife(paul)</span><span
lang=EN-US style='font-family:Times'>}<br>
{</span><span lang=EN-US>man(paul)</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>adult(paul)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>married(paul)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>has_wife(paul)</span><span
lang=EN-US style='font-family:Times'>}<br>
{</span><span lang=EN-US>man(paul)</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>adult(paul)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>married(paul)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>bachelor(paul)</span><span
lang=EN-US style='font-family:Times'>, <br>
<span style="mso-spacerun:yes">&nbsp;</span></span><span lang=EN-US>has_wife(paul)</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>The second and fourth models are non-minimal. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 5.6</span></i><span lang=EN-US>. Are all minimal models
  always constructed by </span><span lang=EN-US style='font-family:Courier'>model/1</span><span
  lang=EN-US>? </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>Yes. The set of all Herbrand interpretations
can be seen as a search space, in which the models are to be found. This search
space is ordered by the subset relation. </span><span lang=EN-US
style='font-family:Courier'>model/1</span><span lang=EN-US> starts from the
empty interpretation, and repeatedly adds ground atoms until a model is
constructed. Since one atom is added at a time, the procedure will never jump
over a model. Since, on backtracking, all possible ways to satisfy a violated
clause are considered, </span><span lang=EN-US style='font-family:Courier'>model/1</span><span
lang=EN-US> performs a breadth-first search (which is complete). </span></p>

<h3 id="informed_search_c"><span lang=EN-US>C.6<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Informed
search</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 6.1.</span></i><span lang=EN-US> Suppose the call </span><span
  lang=EN-US style='font-family:Courier'>children(Current,Children)</span><span
  lang=EN-US> results in an ordered list of children. Write a predicate </span><span
  lang=EN-US style='font-family:Courier'>merge/3</span><span lang=EN-US> which
  directly merges this list with the current agenda.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>This predicate is a little bit special because
it requires <b style='mso-bidi-font-weight:normal'>two</b> recursion arguments.
Therefore, there are two recursive clauses and two base cases. Note that in the
second clause the first argument is required to be a non-empty list. This is
done to prevent the query </span><span lang=EN-US style='font-family:Courier'>?&#8209;merge([],[],L)</span><span
lang=EN-US> from succeeding twice. </span></p>

<p class=pi-eerst><span lang=EN-US>merge</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;merge/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>([],Agenda,Agenda).</span></p>

<p class=pi style='tab-stops:286.0pt'><span lang=EN-US>merge([Child|Children],[],[Child|Children]).<span
style='mso-tab-count:1'> </span>% empty agenda</span></p>

<p class=pi><span lang=EN-US>merge([Child|Children],[Node|Agenda],[Child|NewAgenda]):-<br>
eval(Child,ChildValue),<br>
eval(Node,NodeValue),<br>
ChildValue &lt; NodeValue,<span style='mso-tab-count:1'>&nbsp; </span>% Child
is better than Node<br>
merge(Children,[Node|Agenda],NewAgenda).</span></p>

<p class=pi-laatst><span lang=EN-US>merge([Child|Children],[Node|Agenda],[Node|NewAgenda]):-<br>
eval(Child,ChildValue),<br>
eval(Node,NodeValue),<br>
ChildValue &gt;= NodeValue,<span style='mso-tab-count:1'> </span>% Child not
better than Node<br>
merge([Child|Children],Agenda,NewAgenda).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 6.4.</span></i><span lang=EN-US> Find a position for
  which the third heuristic is too pessimistic.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>It is too pessimistic for the starting
position (minimal cost 15, estimate 18). </span></p>

<h3 id="reasoning_with_natural_language_c"><span lang=EN-US>C.7<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Reasoning
with natural language</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 7.1</span></i><span lang=EN-US>. Redraw the parse tree of
  fig. 7.1 in the manner of an SLD proof tree, where &lsquo;resolvents&rsquo; are partially
  parsed sentences such as <br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>[the],[rapid],noun,verb_phrase</span><span
  lang=EN-US><br>
  and &lsquo;clauses&rsquo; are grammar rules. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_14" o:spid="_x0000_i1026" type="#_x0000_t75" style='width:341pt;
 height:224pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image027.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image028.svg" v:shapes="Picture_x0020_14"><![endif]></span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 7.2</span></i><span lang=EN-US>. Draw the search space
  generated by the grammar in section 7.1 for a top-down parse, if grammar rules
  are applied to sentences from left to right. Discuss the similarities and
  differences with SLD-trees. </span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The search space is partly drawn below; the
lower part, which contains all possible verb phrases, re-appears at three other
nodes as indicated. </span></p>

<p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
 id="Picture_x0020_15" o:spid="_x0000_i1025" type="#_x0000_t75" style='width:323pt;
 height:398pt;visibility:visible;mso-wrap-style:square'>
 <v:imagedata src="Appendix_files/image029.emz" o:title=""/>
</v:shape><![endif]--><![if !vml]><img width=70%
src="Appendix_files/image030.svg" v:shapes="Picture_x0020_15"><![endif]></span></p>

<p class=tekst><span lang=EN-US>This search space is basically a propositional
SLD-tree, with fully parsed sentences corresponding to success branches
(failure branches occur only when for some syntactic category no grammar rules
are specified). </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm;tab-stops:48.0pt 70.0pt 4.0cm 154.0pt'><i
  style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise 7.4</span></i><span
  lang=EN-US>. Extend the following grammar rules with arguments expressing
  their interpretation: <br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>verb_phrase<span
  style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
  transitive_verb,proper_noun.<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>transitive_verb<span
  style='mso-tab-count:1'>&nbsp; </span>--&gt; [likes].<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The transitive verb defines a binary mapping </span><span
lang=EN-US style='font-family:Courier'>Y=&gt;X=&gt;L</span><span lang=EN-US>,
which is applied to the meaning of the proper noun: </span></p>

<p class=grammar style='tab-stops:113.0pt 5.0cm 197.0pt 226.0pt 9.0cm 11.0cm 13.0cm'><span
lang=EN-US>verb_phrase(M)<span style='mso-tab-count:1'>&nbsp; </span>--&gt;
transitive_verb(Y=&gt;M),proper_noun(Y).<br>
transitive_verb(Y=&gt;X=&gt;likes(X,Y))<span style='mso-tab-count:1'>&nbsp; </span>--&gt;
[likes].</span></p>

<h3 id="reasoning_with_incomplete_information_c"><span lang=EN-US>C.8<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Reasoning
with incomplete information</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 8.1</span></i><span lang=EN-US>. Give the models of the
  program <br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>bird(tweety).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>ostrich(tweety).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>flies(X):-bird(X),not
  abnormal(X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>abnormal(X):-ostrich(X).<br>
  </span><span lang=EN-US>(interpreting the general clause as the corresponding
  indefinite clause). Which one is the intended model (see section 2.4)?</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The models are</span></p>

<p class=p-el><span lang=EN-US style='font-family:Times'>{</span><span
lang=EN-US>bird(tweety)</span><span lang=EN-US style='font-family:Times'>, </span><span
lang=EN-US>ostrich(tweety)</span><span lang=EN-US style='font-family:Times'>, </span><span
lang=EN-US>abnormal(tweety)</span><span lang=EN-US style='font-family:Times'>}</span><span
lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>bird(tweety)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>ostrich(tweety)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>abnormal(tweety)</span><span
lang=EN-US style='font-family:Times'>, <br>
<span style="mso-spacerun:yes">&nbsp;</span></span><span lang=EN-US>flies(tweety)</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>i.e. Tweety, being an ostrich, is an abnormal
bird which may or may not fly. The intended model is the first one, since we
have no reason to assume that ostriches fly. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 8.2</span></i><span lang=EN-US>. Give the models of the
  program<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>likes(peter,S):-student_of(S,peter).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>student_of(paul,peter).<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The Herbrand base of this program is </span></p>

<p class=p-el style='margin-left:28.0pt;text-indent:-11.0pt'><span lang=EN-US
style='font-family:Times'>{<span style='mso-tab-count:1'>&nbsp; </span></span><span
lang=EN-US>likes(peter,peter)</span><span lang=EN-US style='font-family:Times'>,
</span><span lang=EN-US>likes(peter,paul)</span><span lang=EN-US
style='font-family:Times'>, <br>
</span><span lang=EN-US>likes(paul,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>likes(paul,paul)</span><span
lang=EN-US style='font-family:Times'>, <br>
</span><span lang=EN-US>student_of(peter,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>student_of(peter,paul)</span><span
lang=EN-US style='font-family:Times'>, <br>
</span><span lang=EN-US>student_of(paul,peter)</span><span lang=EN-US
style='font-family:Times'>, </span><span lang=EN-US>student_of(paul,paul)</span><span
lang=EN-US style='font-family:Times'> }</span></p>

<p class=tekst><span lang=EN-US>The atoms </span><span lang=EN-US
style='font-family:Courier'>student_of(paul,peter)</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>likes(peter,paul)</span><span
lang=EN-US> are <b style='mso-bidi-font-weight:normal'>true</b> in every model.
If the atom </span><span lang=EN-US style='font-family:Courier'>student_of(peter,peter)</span><span
lang=EN-US> is <b style='mso-bidi-font-weight:normal'>true</b>, then so is the
atom </span><span lang=EN-US style='font-family:Courier'>likes(peter,peter)</span><span
lang=EN-US> (three possibilities). Disregarding the other four atoms, we obtain
the following models: </span></p>

<p class=p-eerst style='page-break-after:auto'><span lang=EN-US
style='font-family:Times'>{<span style='mso-tab-count:1'>&nbsp; </span></span><span
lang=EN-US>student_of(paul,peter)</span><span lang=EN-US style='font-family:
Times'>, </span><span lang=EN-US>likes(peter,paul)</span><span lang=EN-US
style='font-family:Times'><span style="mso-spacerun:yes">&nbsp; </span>}<o:p></o:p></span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US
style='font-family:Times'>{<span style='mso-tab-count:1'>&nbsp; </span></span><span
lang=EN-US>student_of(paul,peter)</span><span lang=EN-US style='font-family:
Times'>, <br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US>likes(peter,paul)</span><span lang=EN-US style='font-family:Times'>,
</span><span lang=EN-US>likes(peter,peter)</span><span lang=EN-US
style='font-family:Times'><span style="mso-spacerun:yes">&nbsp; </span>}<o:p></o:p></span></p>

<p class=p-laatst><span lang=EN-US style='font-family:Times'>{<span
style='mso-tab-count:1'>&nbsp; </span></span><span lang=EN-US>student_of(paul,peter)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>student_of(peter,peter)</span><span
lang=EN-US style='font-family:Times'>, <br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US>likes(peter,paul)</span><span lang=EN-US style='font-family:Times'>,
</span><span lang=EN-US>likes(peter,peter)</span><span lang=EN-US
style='font-family:Times'><span style="mso-spacerun:yes">&nbsp; </span>}</span></p>

<p class=tekst><span lang=EN-US>Taking the four remaining atoms into account,
we obtain 3*2</span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:-3.0pt;mso-text-raise:3.0pt'>4</span><span lang=EN-US>=48 models. (See also
Exercise 2.6.) </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 8.3</span></i><span lang=EN-US>. Apply Predicate
  Completion to the program<br>
  </span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
  2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>wise(X):-not
  teacher(X).<br>
  <span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher(peter):-wise(peter).<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=answer><span lang=EN-US>The completion of this program is</span></p>

<p class=pi-eerst><span lang=EN-US style='font-family:Symbol'>&forall;</span><span
lang=EN-US>X: wise(X)</span><span lang=EN-US style='font-family:Symbol'>&harr;</span><span
lang=EN-US> &not;teacher(X)</span></p>

<p class=pi-laatst><span lang=EN-US style='font-family:Symbol'>&forall;</span><span
lang=EN-US>X: teacher(X)</span><span lang=EN-US style='font-family:Symbol'>&harr; </span><span
lang=EN-US>(X=peter </span><span lang=EN-US style='font-family:Symbol'>&and;</span><span
lang=EN-US> wise(peter))</span></p>

<p class=tekst><span lang=EN-US>The first formula states that somebody is wise
if and only if he is not a teacher; the second formula says that Peter is wise
if and only if he is a teacher. Together, these two statements are
inconsistent. </span></p>

<h3 id="inductive_reasoning_c"><span lang=EN-US>C.9<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>Inductive
reasoning</span></h3>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  12.0pt;margin-left:0cm'><i style='mso-bidi-font-style:normal'><span
  lang=EN-US>Exercise 9.3. </span></i><span lang=EN-US>Determine the </span><span
  lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG of the
  following two clauses: <br>
  <span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
  lang=EN-US style='font-family:Courier'>reverse([2,1],[3],[1,2,3]):-reverse([1],[2,3],[1,2,3])<br>
  <span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>reverse([a],[],[a]):-reverse([],[a],[a])<o:p></o:p></span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=p-el><span lang=EN-US>reverse([H|T],A,[RH|RT]):-reverse(T,[H|A],[RH|RT])</span></p>

<p class=tekst><span lang=EN-US>This is the recursive clause in the version
with accumulator</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;accumulator&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the </span><span
lang=EN-US style='font-family:Courier'>reverse/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;reverse/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>predicate (section 3.6),
with one small difference: here, the third argument is required to be a
non-empty list (which it always is). Notice that this clause is not strictly
constrained</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;constrained clause&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and cannot be inferred by the induction programs in sections 9.2
and 9.3 (see als Exercise 9.4). </span></p>

</div>

<!-- </body> -->

<!-- </html> -->
