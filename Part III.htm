---
layout: paper
part: Part%20III
---

<!-- <body bgcolor=white lang=EN-GB style='tab-interval:28.0pt'> -->

<div class=WordSection1>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;name of default rule,&quot; \t
&quot;see default rule&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;abductive meta-interpreter,&quot;
\t &quot;see meta-interpreter&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inductive meta-interpreter,&quot;
\t &quot;see meta-interpreter&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;default rule:see
also:meta-interpreter&quot; \t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;intensional coverage:see
also:meta-interpreter&quot; \t &quot;&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;DCG,&quot; \t &quot;see Definite
Clause Grammar&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;CWA,&quot; \t &quot;see Closed
World Assumption&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;LGG,&quot; \t &quot;see least
general generalisation&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;RLGG,&quot; \t &quot;see relative
least general generalisation&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;type,&quot; \t &quot;see
variable&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;constrained clause,&quot; \t
&quot;see clause&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;circular clause,&quot; \t &quot;see
clause&quot; \i </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=MsoNormal><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;stratified program,&quot; \t
&quot;see program&quot; \i </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'><o:p></o:p></span></p>

<p class=romeinscijfer><span lang=EN-US>III</span></p>

<div style='mso-element:para-border-div;border:none;border-bottom:solid windowtext 1.5pt;
padding:0cm 0cm 0cm 0cm;margin-left:1.0cm;margin-right:0cm'>

<h1 id="advanced_reasoning_techniques" style='margin-left:0cm'><span lang=EN-US>Advanced <br>
reasoning techniques</span></h1>

</div>

<p class=sektie1><span lang=EN-US>In Part I, we introduced the formalism of
clausal logic and showed how it can be used in practice to perform logical
inferences. In Part II, we discussed the basic issues one encounters when
writing a program to solve some reasoning task: how to represent the knowledge
needed to solve the task, and how to search the space of possible solutions. In
Part III, we will go beyond the power of clausal logic in a number of ways. </span></p>

<p class=sektie><span lang=EN-US>Why would one want to have a formalism more
powerful than first-order clausal logic? One reason could be that we want to
perform inferences that are simply not expressible in first-order clausal
logic. We might want to express knowledge such as ‘he inherited all his
father’s bad characteristics’, which is a second-order statement</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;second-order
statement&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(section 2.5). We might
want to express statements like ‘Peter believes his boss knows he is writing a
book’, where ‘Peter’s boss knows’ is a <i style='mso-bidi-font-style:normal'>modality</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;modality&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the formula ‘Peter is
writing a book’, and ‘Peter believes’ is a modality of the formula ‘Peter’s
boss knows Peter is writing a book’. We might want to reason about sequences of
events happening over time. Each of these examples requires a specialised logic
extending the syntax of first-order logic. Needless to say, this increased
expressiveness also requires more powerful semantics and proof theory. </span></p>

<p class=sektie><span lang=EN-US>There are also reasoning tasks which use the
language of clausal logic, but differ nonetheless from standard clausal logic
in the validity of the conclusions drawn. For instance, the truth of a
conclusion might not be guaranteed but only plausible, given the premises.
Alternatively, a conclusion might be a general theory derived from a number of
specific observations, a theory which might be falsified by new contradicting
evidence. Typically, such non-standard reasoning tasks require a more elaborate
semantic and proof-theoretic characterisation than required for standard
logical inference. </span></p>

<p class=sektie><span lang=EN-US>Thirdly, the knowledge required for the
reasoning task might be available in non-logical form only: think of pictures,
spoken or written text, or video images. In such cases, the reasoning task
requires pre- and postprocessing stages, in which the non-logical data are
converted to and from logical formulas. </span></p>

<p class=sektie><span lang=EN-US>In the following three chapters, we will
encounter each of these three types of reasoning. Chapter 7 is devoted to
reasoning with knowledge expressed in natural language. We demonstrate how to
translate sentences like ‘Socrates is human’ and ‘all humans are mortal’, and
questions like ‘is Socrates mortal?’ into clausal logic, and how to obtain a
natural language sentence as the answer. In Chapter 8, we discuss a number of
approaches to reasoning with incomplete information. Most of these approaches
are of the second type, extending semantics and proof theory but not syntax of
clausal logic; one approach extends syntax as well. We provide a detailed
discussion of how these approaches are related. Finally, inductive reasoning is
discussed in Chapter 9. Induction aims at completing partial knowledge about
specific instances of a theory, and is therefore, although related to, much
harder than the forms of reasoning with incomplete knowledge discussed in
Chapter 8. We give an in-depth analysis of the problem, and develop two Prolog
programs that can inductively infer simple predicate definitions from exampes. </span></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection2>

<p class=cijfer><span lang=EN-US>7</span></p>

<h2 id="reasoning_with_natural_language"><span lang=EN-US>Reasoning with natural language</span></h2>

<p class=sektie1><span lang=EN-US>A language which is used for communication
between humans is commonly called a <i style='mso-bidi-font-style:normal'>natural
language</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;natural language&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, in order to distinguish it from an artificial computer language.
Despite their apparent differences, artificial and natural language can be
described by the same tools, some of which will be studied in this chapter.</span></p>

<p class=sektie><span lang=EN-US>Natural language can be described on a number
of different levels:</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span><i style='mso-bidi-font-style:
normal'>Prosody</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Prosody&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: rhythm and intonation of spoken language;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span><i style='mso-bidi-font-style:normal'>Phonology</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Phonology&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: how to combine simple sounds (<i style='mso-bidi-font-style:normal'>phonemes</i>)
in spoken language;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iii</i>)<span
style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:normal'>Morphology</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Morphology&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: how to build words from meaningful components (<i
style='mso-bidi-font-style:normal'>morphemes</i>);</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iv</i>)<span
style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:normal'>Syntax</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Syntax</span></i><span lang=EN-US>:
of natural language<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: how to build sentences from words;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>v</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span><i style='mso-bidi-font-style:normal'>Semantics</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Semantics</span></i><span
lang=EN-US>: of natural language<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: how to assign meaning to words and sentences;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>vi</i>)<span
style='mso-tab-count:1'>&nbsp; </span><i style='mso-bidi-font-style:normal'>Pragmatics</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Pragmatics&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: how to use sentences in communication.</span></p>

<p class=tekst><span lang=EN-US>Here, we are mainly concerned with written
language, so we will not talk about prosody and phonology. Morphology tells us,
for instance, that in English the plural of many nouns can be obtained by
adding the suffix -s (house&#8211;houses, chair&#8211;chairs). Syntax allows us
to distinguish well-formed sentences (like ‘I sleep’) from ill-formed ones
(like ‘me sleeps’), and to discover their grammatical structure. Semantics
allows us to understand sentences like ‘time flies like an arrow, but fruit
flies like a banana’. Pragmatics tells us that ‘yes’ is in general not a very
helpful answer to questions of the form ‘do you know …?’.</span></p>

<p class=sektie><span lang=EN-US>It should be noted that this distinction
between different levels is not as clear-cut as it may seem. For instance, the
sentences ‘time flies like an arrow’ and ‘fruit flies like a banana’ look very
similar; yet, semantic analysis shows that they have a different grammatical
structure: ‘time (noun) flies (verb) like an arrow’ in the first case, and
‘fruit flies (noun) like (verb) a banana (noun phrase)’ in the second. That is,
both sentences have at least two possible grammatical structures, and we need
semantics to prefer one over the other.</span></p>

<p class=sektie><span lang=EN-US>Without doubt, the language level which has
been formalised most successfully is the syntactic level. The process of
deriving the grammatical structure of a sentence is called <i style='mso-bidi-font-style:
normal'>parsing</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;parsing&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. The outcome of the parsing process is a <i style='mso-bidi-font-style:
normal'>parse tree</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;parse tree&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, showing the grammatical constituents of the sentence, like verb
phrase and noun phrase. This grammatical structure can be further used in the
semantic analyis of the sentence. The reverse process, starting from a semantic
representation and producing a sentence, is called <i style='mso-bidi-font-style:
normal'>sentence generation</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sentence generation&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. It is applied in dialogue systems, where answers to queries must
be formulated in natural language.</span></p>

<h3 id="grammars_and_parsing"><span lang=EN-US>7.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Grammars
and parsing</span></h3>

<p class=sektie1><span lang=EN-US>The syntax of a language is specified by a <i
style='mso-bidi-font-style:normal'>grammar</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;grammar&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which is a set of <i style='mso-bidi-font-style:normal'>grammar
rule</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;grammar rule&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> of the form</span></p>

<p class=p-eerst><span lang=EN-US>Category1 --&gt; Category2,Category3</span></p>

<p class=p-laatst><span lang=EN-US>Category2 --&gt; [Terminal]</span></p>

<p class=tekst><span lang=EN-US>Here, </span><span lang=EN-US style='font-family:
Courier'>CategoryX</span><span lang=EN-US> denotes a <i style='mso-bidi-font-style:
normal'>syntactic category</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;syntactic category&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, specifying the type of a sentence part (e.g. noun, noun phrase,
etc.). The first rule states that a </span><span lang=EN-US style='font-family:
Courier'>Category2</span><span lang=EN-US> followed by a </span><span
lang=EN-US style='font-family:Courier'>Category3</span><span lang=EN-US> is a </span><span
lang=EN-US style='font-family:Courier'>Category1</span><span lang=EN-US>. For
instance, the fact that a sentence may consist of a noun phrase followed by a
verb phrase is expressed by the rule</span></p>

<p class=p-el><span lang=EN-US>sentence --&gt; noun_phrase,verb_phrase</span></p>

<p class=tekst><span lang=EN-US>A <i style='mso-bidi-font-style:normal'>terminal</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;terminal&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is any word which occurs
in the language. The second rule above assigns a syntactic category to a word.
For instance:</span></p>

<p class=p-el><span lang=EN-US>noun --&gt; [bicycle]</span></p>

<p class=tekst><span lang=EN-US>Syntactic categories are also called <i
style='mso-bidi-font-style:normal'>non-terminal</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;non-terminal&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>.</span></p>

<p class=sektie><span lang=EN-US>A grammar which specifies a tiny bit of the
English language is given below. As in clausal logic, grammar rules are
separated by periods. </span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.1.1"  query-text="?- phrase(sentence,[achilles,beats,the,lazy,turtle])." style="display: block;">
sentence             --> noun_phrase,verb_phrase.
noun_phrase          --> proper_noun.
noun_phrase          --> article,adjective,noun.
noun_phrase          --> article,noun.
verb_phrase          --> intransitive_verb.
verb_phrase          --> transitive_verb,noun_phrase.
article              --> [the].
adjective            --> [lazy].
adjective            --> [rapid].
proper_noun          --> [achilles].
noun                 --> [turtle].
intransitive_verb    --> [sleeps].
transitive_verb      --> [beats].
</pre>

<p class=tekst><span lang=EN-US>Some sentences generated by this grammar are:
‘the lazy turtle sleeps’, ‘Achilles beats the turtle’, and ‘the rapid turtle
beats Achilles’. The grammatical structure of these sentences can be described
by a <i style='mso-bidi-font-style:normal'>parse tree</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;parse tree&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which is a tree containing the words of the sentence as leaves,
and the syntactic categories assigned to parts of the sentence as nodes (fig.
7.1). </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
   id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
   path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
   <v:stroke joinstyle="miter"/>
   <v:formulas>
    <v:f eqn="if lineDrawn pixelLineWidth 0"/>
    <v:f eqn="sum @0 1 0"/>
    <v:f eqn="sum 0 0 @1"/>
    <v:f eqn="prod @2 1 2"/>
    <v:f eqn="prod @3 21600 pixelWidth"/>
    <v:f eqn="prod @3 21600 pixelHeight"/>
    <v:f eqn="sum @0 0 1"/>
    <v:f eqn="prod @6 1 2"/>
    <v:f eqn="prod @7 21600 pixelWidth"/>
    <v:f eqn="sum @8 21600 0"/>
    <v:f eqn="prod @7 21600 pixelHeight"/>
    <v:f eqn="sum @10 21600 0"/>
   </v:formulas>
   <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:shapetype><v:shape id="Picture_x0020_1" o:spid="_x0000_i1031" type="#_x0000_t75"
   style='width:352pt;height:155pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image001.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=354 height=157
  src="Part%20III_files/image002.png" v:shapes="Picture_x0020_1"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  7.1.</span></b><span lang=EN-US> Parse tree for the sentence ‘the rapid
  turtle beats Achilles’.</span></p>
  </td>
 </tr>
</table>

</div>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
7.1</span></i><span lang=EN-US>. Redraw this parse tree in the manner of an SLD
proof tree, where ‘resolvents’ are partially parsed sentences such as <br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>[the],[rapid],noun,verb_phrase</span><span
lang=EN-US><br>
and ‘clauses’ are grammar rules. </span><span lang=EN-US style='font-family:
Courier'><o:p></o:p></span></p>

</div>

<p class=sektie><span lang=EN-US>Such a parse tree can be constructed by
starting with the non-terminal </span><span lang=EN-US style='font-family:Courier'>sentence</span><span
lang=EN-US>, and repeatedly replacing non-terminals by the righthand side of an
applicable rule, until the given sentence is obtained as a sequence of
terminals. This method is called <i style='mso-bidi-font-style:normal'>top-down</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;parsing:<i
style='mso-bidi-font-style:normal'>top-down</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>parsing</span></i><span lang=EN-US>.
Alternatively, we could start with the sentence and look for parts of it which
occur on the righthand side of a rule, and replace that part of the sentence
with the non-terminal on the lefthand side of the rule, until we obtain the
single non-terminal </span><span lang=EN-US style='font-family:Courier'>sentence</span><span
lang=EN-US>. This procedure is called <i style='mso-bidi-font-style:normal'>bottom-up</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;parsing:<i
style='mso-bidi-font-style:normal'>bottom-up</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>parsing</span></i><span lang=EN-US>. It
should be noted that both methods require search: at any stage, several rules
might be applicable.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
7.2</span></i><span lang=EN-US>. Draw the search space generated by the above
grammar for a top-down parse, if grammar rules are applied to sentences from
left to right. Discuss the similarities and differences with SLD-trees. </span><span
lang=EN-US style='font-family:Courier'><o:p></o:p></span></p>

</div>

<p class=sektie><span lang=EN-US>In general, grammar rules are allowed to be
recursive. For instance, a noun phrase can contain several adjectives, as
described by the following rules:</span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.1.2"  query-text="?- phrase(sentence,[the,lazy,rapid,turtle])." style="display: block;">
sentence             --> noun_phrase.
noun_phrase          --> article,noun_phrase2.
noun_phrase2         --> noun.
noun_phrase2         --> adjective,noun_phrase2.
article              --> [the].
adjective            --> [lazy].
adjective            --> [rapid].
noun                 --> [turtle].
</pre>

<p class=tekst><span lang=EN-US>This set of rules allows ‘the lazy rapid
turtle’ as a noun phrase. Recursion extends the descriptive power of a grammar
considerably, by allowing repetitive structures.</span></p>

<p class=sektie><span lang=EN-US>Grammars like the ones we have seen are called
<i style='mso-bidi-font-style:normal'>context-free grammar</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;context-free grammar&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>. This name derives from the fact that only one non-terminal is
allowed on the left of a grammar rule. A grammar rule which contains several
non-terminals on its lefthand side is called <i style='mso-bidi-font-style:
normal'>context-sensitive</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;context-sensitive</span></i><span
lang=EN-US> grammar<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: some of those non-terminals act as a <i style='mso-bidi-font-style:
normal'>context</i> for the others, allowing the rule to be used only when that
context is present. As an example, consider a grammar which would rule out
sentences like ‘the turtles sleeps’, in which the ‘plurality</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;plurality
of nouns and verbs&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>’ (singular, plural) of noun and verb disagree. A candidate would
be: </span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.1.3" style="display: block;">
noun_phrase 			--> article,noun.
plurality 			--> singular.
plurality			--> plural.
verb_phrase			--> intransitive_verb.
article				--> [the].
noun,singular			--> [turtle],singular.
noun,plural			--> [turtles],plural.
singular,intransitive_verb	--> [sleeps].
plural,intransitive_verb	--> [sleep].
</pre>

<p class=tekst><span lang=EN-US>In this grammar, the non-terminal </span><span
lang=EN-US style='font-family:Courier'>plurality</span><span lang=EN-US>
creates a context for the applicability of the rewrite rules for noun and
intransitive verb. Procedural programming languages like Pascal are also, to
some extent, context-sensitive: statements like </span><span lang=EN-US
style='font-family:Courier'>X:=10</span><span lang=EN-US> can only be parsed in
the context created by the declaration of the variable </span><span lang=EN-US
style='font-family:Courier'>X</span><span lang=EN-US> (if it is declared to be
a Boolean, the statement is illegal). Apart from this, such programming
languages are context-free: each statement can be parsed without referring to
its context.</span></p>

<p class=sektie><span lang=EN-US>Context-sensitive grammars greatly increase
the complexity of the parsing task; moreover, the grammatical structure of
sentences cannot be simply described by a parse tree. In this chapter, we will
restrict attention to context-free grammars, extended with some Prolog-specific
features. The resulting grammars are called <i style='mso-bidi-font-style:normal'>Definite
Clause Grammars</i>, and will be introduced in the next section.</span></p>

<h3 id="definite_clause_grammars"><span lang=EN-US>7.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Definite
Clause Grammars</span></h3>

<p class=sektie1><span lang=EN-US>If we want to build a parser in Prolog, we
need a representation</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:representation
of sentences&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>for sentences. Ignoring
capitals and punctuation marks, a sentence can simply be represented by the
list of its words in the same order, for instance</span></p>

<p class=p-el><span lang=EN-US>[the,rapid,turtle,beats,achilles]</span></p>

<p class=tekst><span lang=EN-US>Given this representation, a grammar rule like</span></p>

<p class=p-el><span lang=EN-US>sentence --&gt; noun_phrase,verb_phrase</span></p>

<p class=tekst><span lang=EN-US>has the following meaning: a list of words
representes a sentence, if some first part of it represents a noun phrase, and
the rest represents a verb phrase. This statement can easily be expressed as a
Prolog clause:</span></p>

<p class=pi-el><span lang=EN-US>sentence(S):-<br>
noun_phrase(NP),<br>
verb_phrase(VP),<br>
append(NP,VP,S)</span></p>

<p class=tekst><span lang=EN-US>Similarly, a grammar rule containing a terminal</span></p>

<p class=p-el><span lang=EN-US>verb --&gt; [sleeps]</span></p>

<p class=tekst><span lang=EN-US>means: a list of words represents a verb if it
is the list consisting of the single word ‘sleeps’. Translated to Prolog:</span></p>

<p class=p-el><span lang=EN-US>verb([sleeps])</span></p>

<p class=tekst><span lang=EN-US>Obviously, there is a very close relationship
between context-free grammar rules and definite clauses, and any context-free
grammar</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;context-free
grammar:translation to clauses&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>can easily be translated
to a set of Prolog clauses. The exciting thing about this is that these Prolog
clauses are nothing less than a parsing program: for instance, we could ask the
query </span></p>

<p class=p-el><span lang=EN-US>?-sentence([the,rapid,turtle,beats,achilles]). </span></p>

<p class=tekst><span lang=EN-US>and get an affirmative answer.</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_2" o:spid="_x0000_i1030" type="#_x0000_t75" style='width:242pt;
   height:106pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image003.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=244 height=108
  src="Part%20III_files/image004.png" v:shapes="Picture_x0020_2"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  7.2.</span></b><span lang=EN-US> The use of difference lists in grammar
  rules.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>We can actually push the correspondence
between grammar rule</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;grammar
rule:correspondence with definite clause&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s and definite clause</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;definite
clause:correspondence with grammar rule&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s further by employing difference list</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;difference
list:in grammar rules&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s (section 3.6). This allows us to get rid of the </span><span
lang=EN-US style='font-family:Courier'>append</span><span lang=EN-US> literals:</span></p>

<p class=pi-el><span lang=EN-US>sentence(NP1-VP2):-<br>
noun_phrase(NP1-VP1),<br>
verb_phrase(VP1-VP2)</span></p>

<p class=tekst><span lang=EN-US>This clause should be read as follows: </span><span
lang=EN-US style='font-family:Courier'>NP1</span><span lang=EN-US> is a
sentence followed by </span><span lang=EN-US style='font-family:Courier'>VP2</span><span
lang=EN-US>, if </span><span lang=EN-US style='font-family:Courier'>NP1</span><span
lang=EN-US> is a noun phrase followed by </span><span lang=EN-US
style='font-family:Courier'>VP1</span><span lang=EN-US>, and </span><span
lang=EN-US style='font-family:Courier'>VP1</span><span lang=EN-US> is a verb
phrase followed by </span><span lang=EN-US style='font-family:Courier'>VP2</span><span
lang=EN-US> (fig. 7.2). Queries now should take the form </span></p>

<p class=p-el><span lang=EN-US>?-sentence([the,rapid,turtle,beats,achilles]-[])
</span></p>

<p class=tekst><span lang=EN-US>(after parsing the initial part of the list as
a sentence, nothing should be left).</span></p>

<p class=sektie><span lang=EN-US>We have shown that there is a one-to-one correspondence
between context-free grammars and Prolog programs interpreting those grammars.
In fact, the translation from the first to the second is so straightforward
that it is built into Prolog. That is, meta-level</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-level&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>grammar rules like</span></p>

<p class=p-el><span lang=EN-US>sentence --&gt; noun_phrase,verb_phrase</span></p>

<p class=tekst><span lang=EN-US>are allowed in Prolog programs. When
interpreting these rules, Prolog will invisibly convert them to object-level</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;object-level&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>program clauses like</span></p>

<p class=pi-el><span lang=EN-US>sentence(L,L0):-<br>
noun_phrase(L,L1),<br>
verb_phrase(L1,L0)</span></p>

<p class=tekst><span lang=EN-US>in which the additional variable is an
accumulator</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;accumulator&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>rather than the minus
list</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;minus list&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of a difference list
(section 3.6). Furthermore, Prolog provides the meta-level predicate </span><span
lang=EN-US style='font-family:Courier'>phrase/2</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;phrase/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, such that the object-level query </span><span lang=EN-US
style='font-family:Courier'>?-sentence(L,[])</span><span lang=EN-US> can be
replaced by the meta-level query </span><span lang=EN-US style='font-family:
Courier'>?-phrase(sentence,L)</span><span lang=EN-US> (fig. 7.3). </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_3" o:spid="_x0000_i1029" type="#_x0000_t75" style='width:327pt;
   height:151pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image005.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=329 height=153
  src="Part%20III_files/image006.png" v:shapes="Picture_x0020_3"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  7.3.</span></b><span lang=EN-US> Meta-level and object-level in Definite
  Clause Grammars.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>These Prolog grammars are known as <i
style='mso-bidi-font-style:normal'>Definite Clause Grammar</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Definite Clause Grammar&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> (DCG’s). They are an excellent illustration of the power of
declarative programming: <i style='mso-bidi-font-style:normal'>specifying a
grammar gives you the parser for free</i>. That is, a grammar is a declarative
specification of the corresponding parser</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;parser&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and Prolog directly converts this specification into an executable
parser. Moreover, since a grammar is purely declarative, the program is also a
sentence</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;sentence
generation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span><b style='mso-bidi-font-weight:
normal'>generator</b>: for instance, it is possible to generate every sentence
starting with ‘Achilles’ by means of the query </span><span lang=EN-US
style='font-family:Courier'>?-phrase(sentence,[achilles|Rest])</span><span
lang=EN-US>.</span></p>

<p class=sektie><span lang=EN-US>Definite Clause Grammars further extend the
power of context-free grammars in two ways: </span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>arguments can be added to
non-terminal</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;non-terminal:argument
of&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s; </span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>Prolog goals can be added to the
body of grammar rules. </span></p>

<p class=tekst><span lang=EN-US>As an illustration of the first feature, we
show how plurality</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;plurality
of nouns and verbs&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>agreement can be
achieved by means of a DCG instead of a context-sensitive grammar</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;context-sensitive
grammar&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: </span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Definite Clause Grammar:adding
arguments to non-terminals&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;argument:of a non-terminal&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.2.1" style="display: block;" query-text="?- phrase(sentence,L).">
sentence                      --> noun_phrase(N),verb_phrase(N).
noun_phrase(N)                --> article(N),noun(N).
verb_phrase(N)                --> intransitive_verb(N).
article(singular)             --> [a].
article(singular)             --> [the].
article(plural)               --> [the].
noun(singular)                --> [turtle].
noun(plural)                  --> [turtles].
intransitive_verb(singular)   --> [sleeps].
intransitive_verb(plural)     --> [sleep].
</pre>

<p class=tekst><span lang=EN-US>The first rule states that the pluralities of
noun phrase and verb phrase should correspond. The second rule states that the
plurality of a noun phrase is determined by both article and noun, which should
have corresponding pluralities as well. The remaining rules assign pluralities
to specific articles, nouns and verbs.</span></p>

<p class=sektie><span lang=EN-US>We can also use this feature to construct a
parse tree</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;parse
tree:construction of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>while parsing a
sentence. Parse trees can be represented by Prolog terms (section 4.1): </span></p>

<p class=opsomming style='margin-left:28.0pt;text-indent:-10.15pt'><span
lang=EN-US>•<span style='mso-tab-count:1'>&nbsp; </span>a parse tree for a
terminal </span><span lang=EN-US style='font-family:Courier'>T</span><span
lang=EN-US> of syntactic category </span><span lang=EN-US style='font-family:
Courier'>S</span><span lang=EN-US> is represented by the term </span><span
lang=EN-US style='font-family:Courier'>S(T)</span><span lang=EN-US>;</span></p>

<p class=opsomming style='margin-left:28.0pt;text-indent:-10.15pt'><span
lang=EN-US>•<span style='mso-tab-count:1'>&nbsp; </span>a parse tree for a
sequence </span><span lang=EN-US style='font-family:Courier'>N1</span><span
lang=EN-US>…</span><span lang=EN-US style='font-family:Courier'>Nk</span><span
lang=EN-US> of non-terminals of syntactic category </span><span lang=EN-US
style='font-family:Courier'>S</span><span lang=EN-US> is represented by the
term </span><span lang=EN-US style='font-family:Courier'>S(N1,</span><span
lang=EN-US>…</span><span lang=EN-US style='font-family:Courier'>,Nk)</span><span
lang=EN-US>.</span></p>

<p class=tekst><span lang=EN-US>Thus, a parse tree for the verb ‘sleeps’ is
represented by the term </span><span lang=EN-US style='font-family:Courier'>verb(sleeps)</span><span
lang=EN-US>, and a parse tree for the sentence ‘the turtle sleeps’ is
represented by the term </span></p>

<p class=p-el><span lang=EN-US>s(np(art(the),n(turtle)),vp(iv(sleeps)))</span></p>

<p class=tekst><span lang=EN-US>(for brevity, syntactic categories are
abbreviated). The following grammar indicates how parse trees are built up from
their constituents. </span></p>


<pre class="source swish" data-variant-id="group-2" id="swish.7.2.1" style="display: block;" query-text="?- s(np(art(the),n(turtle)),vp(iv(sleeps))).">
sentence(s(NP,VP))            --> noun_phrase(NP),
                                  verb_phrase(VP).
noun_phrase(np(N))            --> proper_noun(N).
noun_phrase(np(Art,Adj,N))    --> article(Art),
                                  adjective(Adj),
                                  noun(N).
noun_phrase(np(Art,N))        --> article(Art),noun(N).
verb_phrase(vp(IV))           --> intransitive_verb(IV).
verb_phrase(vp(TV,NP))        --> transitive_verb(TV),
                                  noun_phrase(NP).
article(art(the))             --> [the].
adjective(adj(lazy))          --> [lazy].
adjective(adj(rapid))         --> [rapid].
proper_noun(pn(achilles))     --> [achilles].
noun(n(turtle))               --> [turtle].
intransitive_verb(iv(sleeps)) --> [sleeps].
transitive_verb(tv(beats))    --> [beats].
</pre>



<p class=grammar style='margin-bottom:0cm;margin-bottom:.0001pt;tab-stops:197.0pt 9.0cm 11.0cm 13.0cm'><span
lang=EN-US>sentence(s(NP,VP))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
noun_phrase(NP),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>verb_phrase(VP).<br>
noun_phrase(np(N))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
proper_noun(N).<br>
noun_phrase(np(Art,Adj,N))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>--&gt;
article(Art),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>adjective(Adj),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>noun(N).<br>
noun_phrase(np(Art,N))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
article(Art),noun(N).<br>
verb_phrase(vp(IV))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
intransitive_verb(IV).</span></p>

<p class=grammar style='margin-top:0cm;tab-stops:197.0pt 9.0cm 11.0cm 13.0cm'><span
lang=EN-US>verb_phrase(vp(TV,NP))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
transitive_verb(TV),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>noun_phrase(NP).<br>
article(art(the))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[the].<br>
adjective(adj(lazy))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[lazy].<br>
adjective(adj(rapid))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[rapid].<br>
proper_noun(pn(achilles))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[achilles].<br>
noun(n(turtle))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[turtle].<br>
intransitive_verb(iv(sleeps))<span style='mso-tab-count:1'> </span>--&gt;
[sleeps].<br>
transitive_verb(tv(beats))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>--&gt;
[beats].</span></p>

<p class=tekst style='page-break-after:avoid'><span lang=EN-US>In the query,
the argument of the non-terminal </span><span lang=EN-US style='font-family:
Courier'>sentence</span><span lang=EN-US> will be instantiated to the final
parse tree: </span></p>

<p class=query style='margin-bottom:6.0pt'><span lang=EN-US>?-phrase(sentence(T),[achilles,beats,the,lazy,turtle]).<br>
T = s(np(pn(achilles)),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>vp(tv(beats),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>np(art(the),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>adj(lazy),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>n(turtle))))</span></p>

<p class=tekst><span lang=EN-US>If we use the predicate </span><span
lang=EN-US style='font-family:Courier'>term_write/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;term_write/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>given in section 4.1, a
nice tree-like output is obtained: </span></p>

<p class=query style='margin-bottom:6.0pt'><span lang=EN-US>?-phrase(sentence(T),[achilles,beats,the,lazy,turtle]),<br>
term_write(T).</span></p>

<p class=p-laatst><span lang=EN-US>---------s--------np--------pn--achilles<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>--------vp--------tv-----beats<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>--------np-------art-------the<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>-------adj------lazy<br>
<span style="mso-spacerun:yes">&nbsp;</span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>---------n----turtle</span></p>

<p class=sektie><span lang=EN-US>These examples show one way to use arguments
of non-terminals: to collect information coming out of the parsing process. In
addition, we might want to express that arguments of different non-terminals in
a rule are related in some way. To this end, we can add Prolog goals to the
body of grammar rules, by enclosing them in curly brackets </span><span
lang=EN-US style='font-family:Courier'>{}</span><span lang=EN-US>. For
instance, suppose we have a grammar for English numerals like ‘one hundred
twenty three’, and we want to calculate the number represented by such numerals
during parsing. We could write the following DCG: </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Definite Clause Grammar:adding
goals to grammar rules&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;goal:in a grammar rule&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>
<pre class="source swish" data-variant-id="group-2" id="swish.7.2.2" style="display: block;" >
numeral(N) --> n1_999(N).
numeral(N) --> n1_9(N1),[thousand],n1_999(N2),{N is N1*1000+N2}.

n1_999(N)  --> n1_99(N).
n1_999(N)  --> n1_9(N1),[hundred],n1_99(N2),{N is N1*100+N2}.

n1_99(N)   --> n0_9(N).
n1_99(N)   --> n10_19(N).
n1_99(N)   --> n20_90(N).
n1_99(N)   --> n20_90(N1),n1_9(N2),{N is N1+N2}.

n0_9(0)    --> [].
n0_9(N)    --> n1_9(N).

n1_9(1)    --> [one].
n1_9(2)    --> [two].
n1_9(3)    --> [three].
n1_9(4)    --> [four].
n1_9(5)    --> [five].
n1_9(6)    --> [six].
n1_9(7)    --> [seven].
n1_9(8)    --> [eight].
n1_9(9)    --> [nine].

n10_19(10) --> [ten].
n10_19(11) --> [eleven].
n10_19(12) --> [twelve].
n10_19(13) --> [thirteen].
n10_19(14) --> [fourteen].
n10_19(15) --> [fifteen].
n10_19(16) --> [sixteen].
n10_19(17) --> [seventeen].
n10_19(18) --> [eighteen].
n10_19(19) --> [nineteen].

n20_90(20) --> [twenty].
n20_90(30) --> [thirty].
n20_90(40) --> [fourty].
n20_90(50) --> [fifty].
n20_90(60) --> [sixty].
n20_90(70) --> [seventy].
n20_90(80) --> [eighty].
n20_90(90) --> [ninety].
</pre>

<p class=tekst><span lang=EN-US>We could use this DCG for parsing a given
numeral, but also for generating the numeral corresponding to a given number: </span></p>

<pre class="swish query" id="query7.2.1">
?- phrase(numeral(2211),N).
</pre>
<p class=query style='margin-bottom:6.0pt'><span lang=EN-US>N = [two,thousand,two,hundred,eleven]</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
7.3.</span></i><span lang=EN-US> Write a DCG that parses time indications like
‘twenty minutes to four’, and converts them to terms like </span><span
lang=EN-US style='font-family:Courier'>3:40</span><span lang=EN-US>. </span><span
lang=EN-US style='font-family:Courier'><o:p></o:p></span></p>

</div>

<p class=sektie><span lang=EN-US>In this section, we have seen that writing
parsers in Prolog is easy: just write the context-free grammar, possibly
extended by arguments to non-terminals and Prolog goals in the body of grammar
rules, and you have a program for parsing and sentence generation. However,
parsing is not an end in itself: we want to assign an interpretation to a
sentence. This is the topic of the following section.</span></p>

<h3 id="interpretation_of_natural_language"><span lang=EN-US>7.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Interpretation
of natural language</span></h3>

<p class=sektie1><span lang=EN-US>Suppose we want to build a rulebase</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;rulebase&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>consisting of rules like
‘every human is mortal’ and ‘Socrates is a human’. A small grammar for rules of
this form is given below.</span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.3.1" style="display: block;" query-text="?- phrase(sentence,[every,human,is,mortal]). ?- phrase(sentence,[socrates,is,a,human]).">
sentence      --> determiner,noun,verb_phrase.
sentence      --> proper_noun,verb_phrase.
verb_phrase   --> [is],property.
property      --> [a],noun.
property      --> [mortal].
determiner    --> [every].
proper_noun   --> [socrates].
noun          --> [human].
</pre>
<p class=tekst><span lang=EN-US>If the rulebase consists of Prolog clauses,
then we need a way to convert natural language rules to clauses. For instance,
‘every man is human’ must be translated to the clause </span><span lang=EN-US
style='font-family:Courier'>human(X):-man(X)</span><span lang=EN-US>. The
clause represents the <i style='mso-bidi-font-style:normal'>meaning</i> of the
sentence, and assigning clauses to sentences can be seen as <i
style='mso-bidi-font-style:normal'>interpreting</i> the sentences.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;natural
language:interpretation as clauses&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie><span lang=EN-US>We will build such an interpreter by extending
each non-terminal in the above grammar with one or more arguments, which give
the meaning of that non-terminal. We start with the simplest case: the meaning
of the proper noun ‘Socrates’ is the term </span><span lang=EN-US
style='font-family:Courier'>socrates</span><span lang=EN-US>:</span></p>

<p class=p-el><span lang=EN-US>proper_noun(socrates) --&gt; [socrates]</span></p>

<p class=tekst><span lang=EN-US>Proper nouns occur in the second rule for
sentences:</span></p>

<p class=p-el><span lang=EN-US>sentence --&gt; proper_noun,verb_phrase</span></p>

<p class=tekst><span lang=EN-US>which can be used to construct the sentence
‘Socrates is a human’. The meaning of this sentence is the clause </span><span
lang=EN-US style='font-family:Courier'>human(socrates):-true</span><span
lang=EN-US>, which can be constructed as follows:</span></p>

<p class=p-el><span lang=EN-US>sentence((P(X):-true)) --&gt; proper_noun(X),verb_phrase(P)</span></p>

<p class=tekst><span lang=EN-US>This rule states: </span><span lang=EN-US
style='font-family:Courier'>P(X):-true</span><span lang=EN-US> is the meaning
of a sentence if it is composed of a proper noun with meaning </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> followed by a
verb phrase with meaning </span><span lang=EN-US style='font-family:Courier'>P</span><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>However, there are several problems with this
grammar rule. For one thing, not every Prolog interpreter allows a variable in
functor position</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;variable:
in functor position&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, as in </span><span lang=EN-US style='font-family:Courier'>P(X)</span><span
lang=EN-US>. This could be solved by constructing the literal </span><span
lang=EN-US style='font-family:Courier'>P(X)</span><span lang=EN-US> separately
by means of a Prolog goal: </span></p>

<p class=grammar><span lang=EN-US>sentence((L:-true))<span style='mso-tab-count:
1'>&nbsp; </span>--&gt; proper_noun(X),verb_phrase(P),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>{L=..[P,X]}</span></p>

<p class=tekst><span lang=EN-US>A more serious problem, however, is that verb
phrases are not necessarily interpreted as unary predicates. For instance,
transitive verbs are interpreted as binary predicates, and the meaning of the
verb phrase ‘likes Achilles’ is the literal </span><span lang=EN-US
style='font-family:Courier'>likes(X,achilles)</span><span lang=EN-US>, where </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> is the meaning
of the proper noun preceding the verb phrase. </span></p>

<p class=sektie><span lang=EN-US>In general, a verb phrase defines a <i
style='mso-bidi-font-style:normal'>mapping</i> from a term </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> to a literal </span><span
lang=EN-US style='font-family:Courier'>L</span><span lang=EN-US>: </span></p>

<p class=grammar><span lang=EN-US>sentence((L:-true))<span style='mso-tab-count:
1'>&nbsp; </span>--&gt; proper_noun(X),verb_phrase(X=&gt;L)</span></p>

<p class=tekst><span lang=EN-US>The declarative reading of this rule is: a
sentence is interpreted as </span><span lang=EN-US style='font-family:Courier'>L:-true</span><span
lang=EN-US> if it starts with a proper noun with meaning </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US>, and it ends
with a verb phrase whose meaning is <i style='mso-bidi-font-style:normal'>applied</i>
to </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> to yield </span><span lang=EN-US style='font-family:Courier'>L</span><span
lang=EN-US>. The meaning of the verb phrase is a mapping from terms to literals
indicated as </span><span lang=EN-US style='font-family:Courier'>X=&gt;L</span><span
lang=EN-US>, where ‘</span><span lang=EN-US style='font-family:Courier'>=&gt;</span><span
lang=EN-US>’ is a user-defined operator. In our case, the mapping is determined
by the property in the verb phrase: </span></p>

<p class=grammar style='tab-stops:197.0pt 9.0cm 11.0cm 13.0cm'><span
lang=EN-US>verb_phrase(M)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[is],property(M).<br>
property(M)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[a],noun(M).<br>
property(X=&gt;mortal(X))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[mortal].<br>
noun(X=&gt;human(X))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[human].</span></p>

<p class=tekst><span lang=EN-US>For instance, the declarative reading of the
last rule is: the meaning of the noun ‘human’ is a mapping from </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> to </span><span
lang=EN-US style='font-family:Courier'>human(X)</span><span lang=EN-US>. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm;tab-stops:48.0pt 70.0pt 4.0cm 154.0pt'><i style='mso-bidi-font-style:
normal'><span lang=EN-US>Exercise 7.4</span></i><span lang=EN-US>. Extend the
following grammar rules with arguments expressing their interpretation: <br>
</span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>verb_phrase<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
transitive_verb,proper_noun.<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>transitive_verb<span
style='mso-tab-count:1'>&nbsp; </span>--&gt; [likes].<o:p></o:p></span></p>

</div>

<p class=sektie><span lang=EN-US>It remains to consider the first rule for
sentences: </span></p>

<p class=grammar style='tab-stops:99.0pt 5.0cm 197.0pt 9.0cm 11.0cm 13.0cm'><span
lang=EN-US>sentence<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
determiner,noun,verb_phrase</span></p>

<p class=tekst><span lang=EN-US>which constructs sentences like ‘every human is
mortal’. As explained above, the meaning of the noun in this sentence is the
mapping from </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> to </span><span lang=EN-US style='font-family:Courier'>human(X)</span><span
lang=EN-US>, and the meaning of the verb phrase is the mapping from </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> to </span><span
lang=EN-US style='font-family:Courier'>mortal(X)</span><span lang=EN-US>. These
two mappings are ‘glued together’ by the non-terminal </span><span lang=EN-US
style='font-family:Courier'>determiner</span><span lang=EN-US>: </span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.7.3.2" style="display: block;" query-text="?- phrase(sentence(C),S)."
source-text-start=
":-op(600,xfy,'=>').
sentence((L:-true))  --> proper_noun(X),verb_phrase(X=>L).
"
source-text-end=
"verb_phrase(M)   --> [is],property(M).
property(M) --> [a],noun(M).
property(X=>mortal(X)) --> [mortal].
noun(X=>human(X)) --> [human].
proper_noun(socrates) --> [socrates]."
>
sentence(C)   			--> 	determiner(M1,M2,C), noun(M1),verb_phrase(M2).
determiner(X=>B,X=>H,(H:-B))  	--> 	[every].
</pre>

<p class=tekst><span lang=EN-US>One could say that the meaning of the
determiner ‘every’ is a <i style='mso-bidi-font-style:normal'>second-order
mapping</i> which, given the mappings defined by the noun and verb phrase,
determines a clause. Note that the noun determines the body literal, while the
verb phrase determines the head; note also that the variables in the two
literals are unified in the determiner rule. </span></p>

<p class=sektie><span lang=EN-US>With this DCG, the query </span><span
lang=EN-US style='font-family:Courier'>?-phrase(sentence(C),S)</span><span
lang=EN-US> now produces the following answers:</span></p>

<p class=p-el style='mso-pagination:widow-orphan;page-break-after:avoid'><span
lang=EN-US>C = human(X):-human(X)<br>
S = [every,human,is,a,human];<br>
C = mortal(X):-human(X)<br>
S = [every,human,is,mortal];<br>
C = human(socrates):-true<br>
S = [socrates,is,a,human];<br>
C = mortal(socrates):-true<br>
S = [socrates,is,mortal]</span></p>

<p class=tekst><span lang=EN-US>Note that this very simple language already
allows some form of reasoning: for instance, given the second and third
sentence, we could conclude the fourth. We will implement a program which
performs this kind of reasoning, taking sentences and questions in natural language,
converting them to clausal logic, and converting the answers back to natural
language. In order to make the program a bit more interesting, we will extend
the grammar with existentially quantified sentences. </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;existential quantifier:in natural
language&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie><span lang=EN-US>Consider the sentence ‘some living beings are
mortal’, where ‘some’ is a determiner. The meaning of this sentence is ‘some
things are living beings, and they are mortal’, which can be expressed by two
clauses: </span></p>

<p class=p-el><span lang=EN-US>living_being(sk):-true <br>
mortal(sk):-true.</span></p>

<p class=tekst><span lang=EN-US>where </span><span lang=EN-US style='font-family:
Courier'>sk</span><span lang=EN-US> is a Skolem constant</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Skolem
constant&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>introducing a new name
for the things known to exist (see section 2.5). The two head literals in these
clauses are determined by the noun and the verb phrase, and the only thing we
have to do is to substitute the Skolem constant and add the empty body: </span></p>

<p class=p-el style='tab-stops:right 367.0pt'><span lang=EN-US>determiner(sk=&gt;H1,sk=&gt;H2,[(H1:-true),(H2:-true)])--> [some]</span></p>

<p class=sektie><span lang=EN-US>The complete DCG is given below. Since the
determiner ‘some’ requires a plural form of noun and verb phrase, an argument
for plurality</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;plurality of nouns
and verbs&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(</span><span
lang=EN-US style='font-family:Courier'>s</span><span lang=EN-US> for singular, </span><span
lang=EN-US style='font-family:Courier'>p</span><span lang=EN-US> for plural)
has been added to each non-terminal. Furthermore, since the determiner ‘some’
results in a list of clauses, the other rules for determiner and sentence have
been changed accordingly. </span></p>

<pre class="source swish temp" data-variant-id="group-2" id="swish.7.3.3" style="display: block;" query-text="?- phrase(sentence(C),S). ?- phrase(sentence([(mortal(socrates):-true)]),Answer).">
:-op(600,xfy,'=>').
sentence(C)                   --> determiner(N,M1,M2,C), noun(N,M1), verb_phrase(N,M2).
sentence([(L:-true)])         --> proper_noun(N,X), verb_phrase(N,X=>L).
verb_phrase(s,M)              --> [is],property(s,M).
verb_phrase(p,M)              --> [are],property(p,M).
property(s,M)                 --> [a],noun(s,M).
property(p,M)                 --> noun(p,M).
property(N,X=>mortal(X))      --> [mortal].
determiner(s,X=>B,X=>H,[(H:-B)]) --> [every].
determiner(p,sk=>H1,sk=>H2,[(H1:-true),(H2:-true)]) --> [some].
proper_noun(s,socrates)       --> [socrates].
noun(s,X=>human(X))           --> [human].
noun(p,X=>human(X))           --> [humans].
noun(s,X=>living_being(X))    --> [living],[being].
noun(p,X=>living_being(X))    --> [living],[beings].
</pre>
<p class=tekst><span lang=EN-US>In addition, we give a small grammar for
allowable questions, which are of the form ‘who is mortal?’, ‘is Socrates
mortal?’, and ‘are some living beings mortal?’: </span></p>


<pre class="source swish inherit" data-variant-id="group-2" inherit-id="swish.7.3.3" id="swish.7.3.4" style="display: block;" 
query-text="?- phrase(question(human(L)),[is,socrates,a,human]).">
question(Q)          --> [who],[is],property(s,X=>Q).
question(Q)          --> [is],proper_noun(N,X),
                         property(N,X=>Q).
question((Q1,Q2))    --> [are],[some],noun(p,sk=>Q1),
                         property(p,sk=>Q2).
</pre>
<p class=grammar><span lang=EN-US>question(Q)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[who],[is],property(s,X=&gt;Q).<br>
question(Q)<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>--&gt;
[is],proper_noun(N,X),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>property(N,X=&gt;Q).<br>
question((Q1,Q2))<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>--&gt;
[are],[some],noun(p,sk=&gt;Q1),<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>property(p,sk=&gt;Q2).</span></p>

<p class=sektie><span lang=EN-US>The program below is a shell for interactively
building up and querying a small rulebase. User inputs are handled by the
predicate </span><span lang=EN-US style='font-family:Courier'>handle_input/2</span><span
lang=EN-US>; possible inputs are ‘stop’, ‘show’, a new rule, or a question. For
the latter to be answered, we use a simple depth-first meta-interpreter</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:for
natural language query answering&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which possibly instantiates variables in the query. For instance,
the question ‘who is mortal’ is interpreted as the goal </span><span
lang=EN-US style='font-family:Courier'>mortal(X)</span><span lang=EN-US>, which
is instantiated by the meta-interpreter to </span><span lang=EN-US
style='font-family:Courier'>mortal(socrates)</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>Interestingly, for transforming this answer
back to natural language we do not need a separate grammar for answers: we can
use the existing grammar for sentences! For instance, we can <b
style='mso-bidi-font-weight:normal'>generate</b> the answer ‘Socrates is mortal’
by means of the query </span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sentence generation&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=p-el><span lang=EN-US>?-phrase(sentence([(mortal(socrates):-true)]),Answer)<br>
Answer = [socrates,is,mortal]</span></p>

<p class=tekst><span lang=EN-US>Therefore, the only thing we have to do after
the meta-interpreter has found an answer is to transform the instantiated query
(a conjunction of literals) to a list of clauses with empty body (see predicate
</span><span lang=EN-US style='font-family:Courier'>transform/2</span><span
lang=EN-US>). Again, we encounter the declarative power of DCG’s, which can at
the same time be used for interpreting natural language sentences, and for
constructing sentences that express a certain logical meaning. </span></p>

<p class=oms-eerst><span lang=EN-US>% natural language shell</span></p>

<p class=pi-laatst><span lang=EN-US>nl_shell</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;nl_shell/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Rulebase):-<br>
get_input(Input),<br>
handle_input(Input,Rulebase).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% handle input from user</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>handle_input(stop,Rulebase):-!.</span></p>

<p class=pi style='page-break-after:auto;tab-stops:256.0pt'><span lang=EN-US>handle_input(show,Rulebase):-!,<br>
show_rules(Rulebase),<br>
nl_shell(Rulebase).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:256.0pt'><span lang=EN-US>handle_input(Sentence,Rulebase):-<br>
phrase(sentence(Rule),Sentence),!,<span style='mso-tab-count:1'> </span>% new
rule<br>
nl_shell([Rule|Rulebase]).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:256.0pt'><span lang=EN-US>handle_input(Question,Rulebase):-<br>
phrase(question(Query),Question),<span style='mso-tab-count:1'>&nbsp; </span>%
question<br>
prove_rb(Query,Rulebase),!,<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
it can be solved<br>
transform(Query,Clauses),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
transform to <br>
phrase(sentence(Clauses),Answer),<span style='mso-tab-count:1'>&nbsp; </span>%
answer<br>
show_answer(Answer),<br>
nl_shell(Rulebase).</span></p>

<p class=pi-laatst style='tab-stops:232.0pt'><span lang=EN-US>handle_input(Question,Rulebase):-<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>% illegal sentence or<br>
show_answer('No'),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
no answer found<br>
nl_shell(Rulebase).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% show current rulebase</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>show_rules([]).</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>show_rules([Rule|Rules]):-<br>
phrase(sentence(Rule),Sentence),<br>
show_answer(Sentence),<br>
show_rules(Rules).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% meta-interpreter</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>prove_rb</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_rb/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(true,Rulebase):-!.</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>prove_rb((A,B),Rulebase):-!,<br>
prove_rb(A,Rulebase),<br>
prove_rb(B,Rulebase).</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>prove_rb(A,Rulebase):-<br>
find_clause((A:-B),Rulebase),<br>
prove_rb(B,Rulebase).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% find applicable clause
in rulebase</span></p>

<p class=pi style='tab-stops:219.0pt'><span lang=EN-US>find_clause(Clause,[Rule|Rules]):-<br>
copy_element(Clause,Rule).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
don’t instantiate Rule</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>find_clause(Clause,[Rule|Rules]):-<br>
find_clause(Clause,Rules).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% copy_element/2: see Appendix A.2</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% transform query to
answer</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>transform((A,B),[(A:-true)|Rest]):-!,<br>
transform(B,Rest).</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>transform(A,[(A:-true)]).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% get input from user</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>get_input(Input):-<br>
write('? '),read(Input).</span></p>

<p class=pi style='tab-stops:256.0pt'><span lang=EN-US>% show answer to user</span></p>

<p class=pi-laatst style='tab-stops:256.0pt'><span lang=EN-US>show_answer(Answer):-<br>
write('! '),write(Answer),nl.</span></p>

<p class=tekst><span lang=EN-US>A conversation with this program might proceed
as follows (following </span><span lang=EN-US style='font-family:Courier'>?</span><span
lang=EN-US> is user input, following </span><span lang=EN-US style='font-family:
Courier'>!</span><span lang=EN-US> is program output): </span></p>

<p class=p-el><span lang=EN-US>? [every,human,is,mortal].<br>
? [socrates,is,a,human].<br>
? [who,is,mortal].<br>
! [socrates,is,mortal]<br>
? [some,living,beings,are,humans].<br>
? show.<br>
! [some,living,beings,are,humans]<br>
! [socrates,is,a,human]<br>
! [every,human,is,mortal]<br>
? [are,some,living,beings,mortal].<br>
! [some,living,beings,are,mortal]<br>
? stop.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm;tab-stops:48.0pt 86.0pt 4.0cm'><i style='mso-bidi-font-style:
normal'><span lang=EN-US>Exercise 7.5.</span></i><span lang=EN-US> The
predicates for user-interaction </span><span lang=EN-US style='font-family:
Courier'>nl_shell/1</span><span lang=EN-US> and </span><span lang=EN-US
style='font-family:Courier'>handle_input/2</span><span lang=EN-US> are mutually
recursive. This might cause memory <br>
problems in longer sessions. Rewrite the interactive loop into a <br>
so-called <i style='mso-bidi-font-style:normal'>failure-driven loop</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;failure-driven loop&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>:<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>shell:-repeat,get_input(X),handle_input(X).<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>handle_input(stop):-!.<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>handle_input(X):-
/* do something */,fail.<br>
handle_input/1</span><span lang=EN-US> is now a predicate which always fails,
unless the loop should be terminated. Upon its failure, the first clause will
backtrack to </span><span lang=EN-US style='font-family:Courier'>repeat</span><span
lang=EN-US>, which is a built-in predicate which succeeds an indefinite number
of times. Thus, </span><span lang=EN-US style='font-family:Courier'>get_input/1</span><span
lang=EN-US> will again be called. <br>
(NB. Since it is impossible to pass arguments on to the next iteration, the
changes to the rulebase have to be made through side-effects, i.e. by means of </span><span
lang=EN-US style='font-family:Courier'>assert/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;assert/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>and </span><span
lang=EN-US style='font-family:Courier'>retract/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;retract/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>.)</span></p>

</div>

<h3 id="further_reading_7"><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>(Pereira &amp; Warren, 1980) contains a
detailed discussion of the DCG formalism. More Prolog programs for natural
language processing can be found in (Gazdar &amp; Mellish, 1989) and (Pereira
&amp; Shieber, 1987). </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>G. Gazdar
&amp; C. Mellish (</span><span lang=EN-US>1989)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Natural Language Processing in Prolog</i>,
Addison-Wesley.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Gazdar,
G.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Mellish,
C.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>F.C.N.
Pereira &amp; D.H.D. Warren (</span><span lang=EN-US>1980)<span
style='font-variant:small-caps'>,</span> ‘Definite Clause Grammars for language
analysis: a survey of the formalism and a comparison with Augmented Transition
Networks’, <i style='mso-bidi-font-style:normal'>Artificial Intelligence</i> <b
style='mso-bidi-font-weight:normal'>13</b>: 231-278.<span style='display:none;
mso-hide:all'>.;</span></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
TC </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;N.&quot;
\l 1 </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Pereira, F.C.N.&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.H.D.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Warren,
D.H.D.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>F.C.N.
Pereira &amp; S.M. Shieber (</span><span lang=EN-US>1987)<span
style='font-variant:small-caps'>,</span> <i style='mso-bidi-font-style:normal'>Prolog
and Natural-language Analysis</i>, Center for the Study of Language and
Information, Menlo Park, CA.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
TC </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;N.&quot;
\l 1 </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Pereira, F.C.N.&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.M.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Shieber,
S.M.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection3>

<p class=cijfer><span lang=EN-US>8</span></p>

<h2 id="reasoning_with_incomplete_information"><span lang=EN-US>Reasoning with incomplete information</span></h2>

<p class=sektie1><span lang=EN-US>In everyday life, we use a surprising number
of different reasoning methods, exemplified by the following arguments: </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;common-sense reasoning&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming><span lang=EN-US>&#8212; ‘It is getting dark already, it
must be after five.’</span></p>

<p class=opsomming><span lang=EN-US>&#8212; ‘If I push this button, the light
in my room will switch on.’</span></p>

<p class=opsomming><span lang=EN-US>&#8212; ‘The light doesn’t switch on!? The
lightbulb must be broken!’</span></p>

<p class=tekst><span lang=EN-US>The first argument is based on general
knowledge about the regular hours of sunset. This knowledge is reached after
numerous observations, and it is embedded in a theory about the movements of
the heavenly bodies. We are pretty confident that this theory is <b
style='mso-bidi-font-weight:normal'>true</b>; that is, it accurately describes
the actual state of affairs. This justifies its use to predict events in the
future. However, it should be noted that we can never be <b style='mso-bidi-font-weight:
normal'>absolutely</b> sure that the theory is true: tomorrow the sun may set
at eleven in the morning, falsifying our theory. The theory is reached by <i
style='mso-bidi-font-style:normal'>induction</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;induction&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: given a number of distinct but similar observations, conclude that
they are governed by a general law. Induction is an important reasoning method
in the natural sciences, and it also underlies some forms of learning, like <i
style='mso-bidi-font-style:normal'>learning from examples</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;learning from examples&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Despite this common usage, it is surprisingly hard to formalise
inductive reasoning: in particular, what it takes to <i style='mso-bidi-font-style:
normal'>justify</i> an inductive hypothesis remains a largely unresolved
question.</span></p>

<p class=sektie><span lang=EN-US>The second argument above seems perfectly
alright, given knowledge about how the switch is connected to the lightbulb and
the power supply. However, this argument requires a lot of implicit
assumptions: the switch is not broken, the connections are in order, the
lightbulb is not broken, there is a supply of power, and so on. The argument is
not in general true, but it describes the normal case; there might be some
exceptional circumstance, invalidating the argument. Typically, we assume
things to be normal, unless there is evidence to the contrary. We call this <i
style='mso-bidi-font-style:normal'>default reasoning</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;default reasoning&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>.</span></p>

<p class=sektie><span lang=EN-US>In the third argument, we give an <i
style='mso-bidi-font-style:normal'>explanation</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abductive
<i style='mso-bidi-font-style:normal'>explanation</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>for the observation that
the light doesn’t switch on. It is a sort of reversed implication</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;implication&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: we know that if the lightbulb is broken, the light won’t switch
on; we observe that the light doesn’t work, so we conclude that the lightbulb must
be broken. This is but one of several possible explanations, however: the
switch might be broken, or the power supply might be down. This process of
finding explanations for observed facts is called <i style='mso-bidi-font-style:
normal'>abduction</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;abduction&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>The common characteristic of these three types
of reasoning is that their conclusions, however plausible they may seem, are
not guaranteed to be true in the intended interpretation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
interpretation&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, because the information we have is <i style='mso-bidi-font-style:
normal'>incomplete</i>. In default reasoning, the conclusion might be false
because the state of affairs is not so normal as it is assumed to be. In
abduction, there might be several alternative explanations, and we do not know
which one to choose. In induction, we typically base our conclusion on only a
fraction of the possible observations. Thus, the general rule (e.g. all swans
are white) might be invalidated by the next observation (a black swan). </span></p>

<p class=sektie><span lang=EN-US>In other words, such common-sense arguments
are <i style='mso-bidi-font-style:normal'>unsound</i>.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;common-sense
reasoning:unsoundness of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>Recall that an inference
rule is sound if the truth of its conclusion is guaranteed by the truth of its
premises. Sound reasoning is also called <i style='mso-bidi-font-style:normal'>deduction</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;deduction&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>; it is the only allowed form of reasoning in fields where rigorous
arguments are needed, like mathematics. However, deductive conclusions only
make explicit what is already implicitly present in the premises (e.g. the
mathematical axiom</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;axiom&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, or a logic program). In everyday reasoning we often want to reach
conclusions which contain <b style='mso-bidi-font-weight:normal'>new</b>
information, information that is not present in the premises. In this chapter,
we will take a closer look at various forms of reasoning with incomplete information,
such as default reasoning, abduction, and diagnostic reasoning. Inductive
reasoning is a subject which deserves a chapter of its own (Chapter 9). </span></p>

<h3 id="default_reasoning"><span lang=EN-US>8.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Default
reasoning</span></h3>

<p class=sektie1><span lang=EN-US>Consider the following argument:</span></p>

<p class=opsomming style='margin-top:6.0pt'><span lang=EN-US>‘Tweety is a
bird.’</span></p>

<p class=opsomming><span lang=EN-US>‘Normally, birds fly.’</span></p>

<p class=opsomming style='margin-bottom:6.0pt'><span lang=EN-US>‘Therefore,
Tweety flies.’</span></p>

<p class=tekst><span lang=EN-US>There are several ways to translate this
argument into logic. One is to read the second statement as ‘normal birds fly’,
such that the following clauses represent the premises of the argument: </span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
flies(X):-bird(X),normal(X).</span></p>

<p class=tekst><span lang=EN-US>Can we draw the conclusion that Tweety flies?
There are three models: </span></p>

<p class=p-el><span lang=EN-US style='font-family:Times'>{</span><span
lang=EN-US>bird(tweety)</span><span lang=EN-US style='font-family:Times'>}</span><span
lang=EN-US><br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>bird(tweety)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>flies(tweety)</span><span
lang=EN-US style='font-family:Times'>}</span><span lang=EN-US> <br>
</span><span lang=EN-US style='font-family:Times'>{</span><span lang=EN-US>bird(tweety)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>flies(tweety)</span><span
lang=EN-US style='font-family:Times'>, </span><span lang=EN-US>normal(tweety)</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>In the first two models, Tweety is a bird but
not normal; hence, it might or might not fly. In the third model, Tweety is a
normal flying bird. Since </span><span lang=EN-US style='font-family:Courier'>flies(tweety)</span><span
lang=EN-US> is not true in every model, it is not a logical consequence</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;logical
consequence&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the program. </span></p>

<p class=sektie><span lang=EN-US>If we want to conclude that Tweety flies, we
must explicitly state that Tweety is a normal bird, thus ruling out the first
two of the above models. However, in default reasoning we do not want to say
that a case is normal: rather, we assume a case to be normal, unless it is
known to be abormal. Therefore, it is more natural to use a predicate </span><span
lang=EN-US style='font-family:Courier'>abnormal/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;abnormal/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;abnormality predicate&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>representing the
negation of </span><span lang=EN-US style='font-family:Courier'>normal/1</span><span
lang=EN-US>. Adding </span><span lang=EN-US style='font-family:Courier'>abnormal(X)</span><span
lang=EN-US> to the head of the clause leads to the indefinite clause</span></p>

<p class=p-el><span lang=EN-US>flies(X);abnormal(X):-bird(X)</span></p>

<p class=tekst><span lang=EN-US>As has already been indicated in section 2.4,
such indefinite clause</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;indefinite
clause&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s can be transformed into ‘pseudo-definite’ or <i style='mso-bidi-font-style:
normal'>general clause</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;general clause&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s by moving all but one of the positive literals to the body of the
clause, preceded by the negation symbol </span><span lang=EN-US
style='font-family:Courier'>not</span><span lang=EN-US>. This results in the
following program: </span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
flies(X):-bird(X),not abnormal(X).</span></p>

<p class=tekst><span lang=EN-US>Since general clauses extend the language of
definite clauses, we must extend both proof theory and semantics to deal with
the negation symbol </span><span lang=EN-US style='font-family:Courier'>not</span><span
lang=EN-US>. A practical way to do this has been discussed in section 3.3,
where we treated </span><span lang=EN-US style='font-family:Courier'>not/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;not/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as a Prolog
meta-predicate</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-predicate&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, implemented by means of cut</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;cut&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Under this interpretation, we can prove that Tweety flies <br>
(fig. 8.1).</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_4" o:spid="_x0000_i1028" type="#_x0000_t75" style='width:199pt;
   height:164pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image007.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=201 height=166
  src="Part%20III_files/image008.png" v:shapes="Picture_x0020_4"><![endif]></span></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  8.1.</span></b><span lang=EN-US> Tweety flies by negation as failure.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>What happens if we learn that Tweety is an
ostrich, and that ostriches are non-flying birds? We should add a clause which
says that ostriches are abnormal (when it comes to flying): </span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
ostrich(tweety).<br>
flies(X):-bird(X),not abnormal(X).<br>
abnormal(X):-ostrich(X).</span></p>

<p class=tekst><span lang=EN-US>As the SLD-tree</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in fig. 8.2 shows,
Prolog is now unable to prove that Tweety flies, since Tweety is provably
abnormal. We say that the <i style='mso-bidi-font-style:normal'>default rule</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;default rule</span></i><span
lang=EN-US>:cancellation of<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>‘normally birds fly’ is <i
style='mso-bidi-font-style:normal'>cancelled</i> by a more <i style='mso-bidi-font-style:
normal'>specific</i> rule (about ostriches). </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=med-figure style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm'><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_5" o:spid="_x0000_i1027" type="#_x0000_t75" style='width:172pt;
   height:271pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image009.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=174 height=273
  src="Part%20III_files/image010.png" v:shapes="Picture_x0020_5"><![endif]></span></p>
  </div>
  <p class=med-caption><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  8.2.</span></b><span lang=EN-US> Tweety doesn’t fly, since it is an ostrich.</span></p>
  </td>
 </tr>
</table>

</div>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
8.1</span></i><span lang=EN-US>. Give the models of this program (interpreting
the general clause as the corresponding indefinite clause). Which one is the
intended model (see section 2.4)?</span></p>

</div>

<p class=sektie><span lang=EN-US>This example shows that in default reasoning</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
reasoning:non-monotonicity of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, <i style='mso-bidi-font-style:normal'>new information can
invalidate previous conclusions</i>, if these conclusions are based on
unprovable assumptions which are contradicted by the new information. This
property clearly distinguishes default reasoning from deductive reasoning,
which is <i style='mso-bidi-font-style:normal'>monotonic</i> in the following
sense:</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;monotonicity: of
deduction&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=formule style='tab-stops:161.0pt 188.0pt'><i style='mso-bidi-font-style:
normal'><span lang=EN-US>Theory</span></i><span lang=EN-US> </span><span
lang=EN-US style='font-family:Extra'>|</span><span lang=EN-US> <i
style='mso-bidi-font-style:normal'>Conclusion</i><span style='mso-tab-count:
1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span lang=EN-US
style='font-family:Symbol'>&THORN;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US style='font-family:Symbol'>È</span><span lang=EN-US>{<i
style='mso-bidi-font-style:normal'>AnyFormula</i>} </span><span lang=EN-US
style='font-family:Extra'>|</span><span lang=EN-US> <i style='mso-bidi-font-style:
normal'>Conclusion</i></span></p>

<p class=tekst><span lang=EN-US>That is, adding <i style='mso-bidi-font-style:
normal'>AnyFormula</i> to a set of formulas <i style='mso-bidi-font-style:normal'>Theory</i>
does not invalidate any <i style='mso-bidi-font-style:normal'>Conclusion</i>
drawn from <i style='mso-bidi-font-style:normal'>Theory</i> alone. If we define
the <i style='mso-bidi-font-style:normal'>deductive closure</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;deductive closure&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of a theory as the set
of conclusions that can be drawn from it:</span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Closure</span></i><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>Theory</i>) = {<i
style='mso-bidi-font-style:normal'>Conclusion</i> | <i style='mso-bidi-font-style:
normal'>Theory</i> </span><span lang=EN-US style='font-family:Extra'>|</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Conclusion</i>}</span></p>

<p class=tekst><span lang=EN-US>then the property of monotonicity can also be
stated as a relation between theories and their closures:</span></p>

<p class=formule style='tab-stops:161.0pt 188.0pt'><i style='mso-bidi-font-style:
normal'><span lang=EN-US>Theory1</span></i><span lang=EN-US> </span><span
lang=EN-US style='font-family:Symbol'>Í</span><span lang=EN-US> <i
style='mso-bidi-font-style:normal'>Theory2</i><span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Symbol'>&THORN;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US>Closure</span></i><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>Theory1</i>) </span><span
lang=EN-US style='font-family:Symbol'>Í</span><span lang=EN-US> <i
style='mso-bidi-font-style:normal'>Closure</i>(<i style='mso-bidi-font-style:
normal'>Theory2</i>)</span></p>

<p class=tekst><span lang=EN-US>This formulation clearly demonstrates the use
of the term ‘monotonic’. Since default reasoning lacks this property, it is
often called <i style='mso-bidi-font-style:normal'>non-monotonic reasoning</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;non-monotonic reasoning&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>.</span></p>

<p class=sektie><span lang=EN-US>Although Prolog’s </span><span lang=EN-US
style='font-family:Courier'>not/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;not/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>meta-predicate can
handle default arguments such as the above, there are a couple of problems.
First of all, as has been shown in section 3.3, the implementation of </span><span
lang=EN-US style='font-family:Courier'>not/1</span><span lang=EN-US> by means
of cut may misbehave if the goal to be negated contains variables. The second
problem is that, since cut is a procedural feature without declarative
semantics, we likewise have no declarative semantics for </span><span
lang=EN-US style='font-family:Courier'>not</span><span lang=EN-US> implemented
by means of cut. Thus, even if we avoid the first problem by a clever
re-ordering of literals in a clause, we do not know what we are computing! This
problem will be addressed in the next section. </span></p>

<p class=sektie1><span lang=EN-US>An alternative to handling possible
exceptions to rules via negation as failure</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;negation
as failure:for handling exceptions&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, is to distinguish between two possible types of rules, those with
exceptions, and those without exceptions. For instance, the rule ‘penguins are
birds’ is a rule without exceptions, whereas the rule ‘birds fly’ is a rule
with exceptions. Let us call a rule with exceptions a <i style='mso-bidi-font-style:
normal'>default</i> rule</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;default</span></i><span lang=EN-US>
rule<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, or simply a default. Rules and defaults are then treated
differently when trying to prove something: a rule is applied whenever
possible, while a default is applied only when it does not lead to an
inconsistency. So, if we only know that Tweety is a bird, the default ‘birds
fly’ can be used to conclude that Tweety flies, but if we also know that Tweety
is a penguin and that penguins don’t fly, the default cannot be applied. Thus,
instead of expressing our knowledge as a general program and using Prolog to
derive conclusions, we will extend the syntax of clausal logic to distinguish
between defaults and rules. We will develop a meta-interpreter which implements
the inference rules for this extended logic. </span></p>

<p class=sektie><span lang=EN-US>The Tweety example can be expressed in terms
of rules and defaults as follows.</span></p>

<p class=p-el><span lang=EN-US>default</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((flies(X):-bird(X))).<br>
rule</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;rule/1&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((not flies(X):-penguin(X))).<br>
rule((bird(X):-penguin(X))).<br>
rule((penguin(tweety):-true)).<br>
rule((bird(opus):-true)).</span></p>

<p class=tekst><span lang=EN-US>In order to explain why Opus flies but Tweety
doesn’t, we use two meta-interpreters. One is the familiar </span><span
lang=EN-US style='font-family:Courier'>prove</span><span lang=EN-US>
meta-interpreter for definite clauses, extended with two arguments to collect
the rules used in the proof. The other meta-interpreter</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:for
default rules&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>applies a default
whenever it does not lead to a contradiction. </span></p>

<p class=oms-eerst><span lang=EN-US>% explain(F,E) &lt;- E explains F from
rules and defaults</span></p>

<p class=pi-laatst><span lang=EN-US>explain</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;explain/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(F,E):-<br>
explain(F,[],E).</span></p>

<p class=oms><span lang=EN-US>% meta-interpreter for rules and defaults</span></p>

<p class=pi style='page-break-after:auto;tab-stops:228.0pt'><span lang=EN-US>explain(true,E,E):-!.</span></p>

<p class=pi style='page-break-after:auto;tab-stops:228.0pt'><span lang=EN-US>explain((A,B),E0,E):-!,<br>
explain(A,E0,E1),<br>
explain(B,E1,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:197.0pt'><span lang=EN-US>explain(A,E0,E):-<br>
prove_e(A,E0,E).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
explain by rules only</span></p>

<p class=pi-laatst style='tab-stops:197.0pt'><span lang=EN-US>explain(A,E0,[default((A:-B))|E]):-<br>
default((A:-B)),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
explain by default<br>
explain(B,E0,E),<br>
not contradiction(A,E).<span style='mso-tab-count:1'>&nbsp; </span>% A
consistent with E</span></p>

<p class=oms><span lang=EN-US>% meta-interpreter for rules</span></p>

<p class=pi style='tab-stops:228.0pt'><span lang=EN-US>prove_e</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_e/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(true,E,E):-!.</span></p>

<p class=pi style='tab-stops:228.0pt'><span lang=EN-US>prove_e((A,B),E0,E):-!,<br>
prove_e(A,E0,E1),<br>
prove_e(B,E1,E).</span></p>

<p class=pi-laatst style='tab-stops:228.0pt'><span lang=EN-US>prove_e(A,E0,[rule((A:-B))|E]):-<br>
rule((A:-B)),<br>
prove_e(B,E0,E).</span></p>

<p class=oms><span lang=EN-US>% check contradiction against rules</span></p>

<p class=pi style='tab-stops:228.0pt'><span lang=EN-US>contradiction(not
A,E):-!,<br>
prove_e(A,E,E1).</span></p>

<p class=pi-laatst><span lang=EN-US>contradiction(A,E):-<br>
prove_e(not A,E,E1).</span></p>

<p class=tekst><span lang=EN-US>The query </span><span lang=EN-US
style='font-family:Courier'>?-explain(flies(X),E)</span><span lang=EN-US> has
only one answer:</span></p>

<p class=p-el><span lang=EN-US>X = polly<br>
E = [ default((flies(polly):-bird(polly))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((bird(polly):-true)) ]</span></p>

<p class=MsoNormal><span lang=EN-US>Tweety does not fly, since </span><span
lang=EN-US style='font-family:Courier'>not flies(tweety)</span><span
lang=EN-US> is provable from the rules:</span></p>

<p class=p-el><span lang=EN-US>?-explain(not flies(X), E)<br>
X = tweety<br>
E = [ rule((not flies(tweety):-penguin(tweety))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((penguin(tweety):-true)) ]</span></p>

<p class=sektie><span lang=EN-US>Sometimes, both a fact and its negation can be
explained. Consider the following set of defaults and rules:</span></p>

<p class=p-eerst style='page-break-after:auto'><span lang=EN-US>default((not
flies(X):-mammal(X))).<br>
default((flies(X):-bat(X))).<br>
default((not flies(X):-dead(X))).</span></p>

<p class=p-laatst><span lang=EN-US>rule((mammal(X):-bat(X))).<br>
rule((bat(dracula):-true)).<br>
rule((dead(dracula):-true)).</span></p>

<p class=tekst><span lang=EN-US>Does Dracula fly or not? One explanation claims
he does, because he is a bat, and bats typically fly: </span></p>

<p class=p-el><span lang=EN-US>?-explain(flies(dracula),E)<br>
E = [ default((flies(dracula):-bat(dracula))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((bat(dracula):-true)) ]</span></p>

<p class=tekst><span lang=EN-US>However, there are also two explanations
stating that Dracula doesn’t fly; after all, he’s not only a mammal, and mammals
typically don’t fly, but he’s also dead, and dead things typically don’t fly
either:</span></p>

<p class=p-el><span lang=EN-US>?-explain(not flies(dracula), E)<br>
E = [ default((not flies(dracula):-mammal(dracula))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((mammal(dracula):-bat(dracula))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((bat(dracula):-true)) ];<br>
E = [ default((not flies(dracula):-dead(dracula))), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((dead(dracula):-true)) ]</span></p>

<p class=tekst><span lang=EN-US>It seems that only the third of these
explanations is acceptable. Thus, we need a way to cancel particular defaults
in certain situations. </span></p>

<p class=sektie><span lang=EN-US>This can be done by attaching <i
style='mso-bidi-font-style:normal'>name</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
rule:<i style='mso-bidi-font-style:normal'>name</i> of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> to defaults, which are parametrised with the variables in the
default. Then, we can refer to a default in the conclusion of a rule:</span></p>

<p class=p-el style='tab-stops:269.0pt'><span lang=EN-US>% default(Name,Rule)<br>
default(mammals_dont_fly(X),(not flies(X):-mammal(X))).<br>
default(bats_fly(X),(flies(X):-bat(X))).<br>
default(dead_things_dont_fly(X),(not flies(X):-dead(X))).<br>
rule((mammal(X):-bat(X))).<br>
rule((bat(dracula):-true)).<br>
rule((dead(dracula):-true)).<br>
% bats are flying mammals<br>
rule((not mammals_dont_fly(X):-bat(X))).<br>
% dead bats don’t fly<br>
rule((not bats_fly(X):-dead(X))).</span></p>

<p class=tekst><span lang=EN-US>We change the fourth clause of the </span><span
lang=EN-US style='font-family:Courier'>explain/3</span><span lang=EN-US>
predicate accordingly:</span></p>

<p class=pi-el style='tab-stops:211.0pt'><span lang=EN-US>explain(A,E0,[default(Name)|E]):-<br>
default(Name,(A:-B)),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
explain by default rule<br>
explain(B,E0,E),<br>
not contradiction(Name,E).<span style='mso-tab-count:1'>&nbsp; </span>% default
applicable<br>
not contradiction(A,E).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>%
A consistent with E</span></p>

<p class=tekst><span lang=EN-US>There are two changes: (<i style='mso-bidi-font-style:
normal'>i</i>) when applying a default, its name is tested for consistency with
the rules, and (<i style='mso-bidi-font-style:normal'>ii</i>) the name of the
default is added to the explanation, instead of the default itself. The above queries
are now handled correctly:</span></p>

<p class=p-el><span lang=EN-US>?-explain(flies(dracula),E)<br>
No.</span></p>

<p class=p-laatst><span lang=EN-US>?-explain(not flies(dracula), E)<br>
E = [ default(dead_things_dont_fly(dracula)), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>rule((dead(dracula):-true)) ];<br>
No more solutions.</span></p>

<p class=tekst><span lang=EN-US>We thus see that it is the programmer’s
responsibility to avoid inconsistencies by specifying appropriate cancellation
rules. </span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><i style='mso-bidi-font-style:
normal'><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
rule</span></i><span lang=EN-US>:cancellation of<i style='mso-bidi-font-style:
normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<h3 id="the_semantics_of_incomplete_information"><span lang=EN-US>8.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>The
semantics of incomplete information</span></h3>

<p class=sektie1><span lang=EN-US>In this section, we present a way to
interpret </span><span lang=EN-US style='font-family:Courier'>not</span><span
lang=EN-US> as a logical symbol rather than a meta-predicate. In this way, it
can be assigned a declarative semantics of its own, without reference to
procedural features like cut. The basic idea is to transform the given program
into an <i style='mso-bidi-font-style:normal'>intended</i> (possibly indefinite)
program, which explicitly captures the intended meaning of the original general
program. We will see that the intended program</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
program&quot; \b </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is <i style='mso-bidi-font-style:
normal'>complete</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;complete</span></i><span
lang=EN-US>ness:of a program<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, in the sense that for every ground fact in the Herbrand base</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand
base&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, either that fact or its negation is a logical consequence of the
intended program. Consequently, the intended program will have exactly one
model, which is taken to be the intended model of the original program. We will
discuss two methods to construct a complete program. The first, simple method
is called the Closed World Assumption; it is simple in the sense that it only
works for definite clauses without negation. The second method is called
Predicate Completion; it can handle general programs with negated literals in
the body of clauses.</span></p>

<p class=sektie1><span lang=EN-US>Informally, the <i style='mso-bidi-font-style:
normal'>Closed World Assumption</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Closed World Assumption&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(CWA) states that <i
style='mso-bidi-font-style:normal'>everything that is not known to be true,
must be false</i>. Under the CWA, we need not say that something is not true:
we simply say nothing about it. This is motivated by the assumption that, in
general, there are many more false statements that can be made than true
statements. Let us state the CWA more precisely. It suffices to know the truth
or falsity of every ground atom in the Herbrand base, since this results in a
single model from which the truth or falsity of any clause can be determined.
Saying that such a ground atom </span><span lang=EN-US style='font-family:Courier'>A</span><span
lang=EN-US> is false, is the same as saying that </span><span lang=EN-US
style='font-family:Courier'>:-A</span><span lang=EN-US> is true. Thus, if <i
style='mso-bidi-font-style:normal'>P</i> is a program and <i style='mso-bidi-font-style:
normal'>B</i> is its Herbrand base, then we define the <i style='mso-bidi-font-style:
normal'>CWA-closure</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;CWA-closure&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span><i style='mso-bidi-font-style:
normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i>) of <i
style='mso-bidi-font-style:normal'>P</i> as</span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>CWA</span></i><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>P</i>) = <i style='mso-bidi-font-style:
normal'>P</i> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> {</span><span lang=EN-US style='font-family:Courier'>:-A</span><span
lang=EN-US> | </span><span lang=EN-US style='font-family:Courier'>A</span><span
lang=EN-US style='font-family:Symbol'>Î</span><i style='mso-bidi-font-style:
normal'><span lang=EN-US>B</span></i><span lang=EN-US> and <i style='mso-bidi-font-style:
normal'>P</i> </span><!--[if supportFields]><span lang=EN-US><span
style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>EQ \O(</span><span lang=EN-US
style='font-family:Extra'>=</span><span lang=EN-US>;/) <span
style="mso-spacerun:yes">&nbsp;</span></span><![endif]--><!--[if supportFields]><span
lang=EN-US><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US>}</span></p>

<p class=tekst><span lang=EN-US>We refer to <i style='mso-bidi-font-style:normal'>CWA</i>(<i
style='mso-bidi-font-style:normal'>P</i>)</span><span lang=EN-US
style='font-family:Symbol'>-</span><i style='mso-bidi-font-style:normal'><span
lang=EN-US>P</span></i><span lang=EN-US> as the <i style='mso-bidi-font-style:
normal'>CWA-complement</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;CWA-complement&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>P</i>. <i style='mso-bidi-font-style:normal'>CWA</i>(<i
style='mso-bidi-font-style:normal'>P</i>) is the <i style='mso-bidi-font-style:
normal'>intended</i> program according to the Closed World Assumption.</span></p>

<p class=sektie><span lang=EN-US>For instance, if <i style='mso-bidi-font-style:
normal'>P</i> is the program</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
student_of(paul,peter).</span></p>

<p class=tekst><span lang=EN-US>then the ground atoms which are logical
consequence</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;logical
consequence&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s of <i style='mso-bidi-font-style:normal'>P</i> are </span><span
lang=EN-US style='font-family:Courier'>likes(peter,paul</span><span lang=EN-US>)
and </span><span lang=EN-US style='font-family:Courier'>student_of(paul,peter)</span><span
lang=EN-US>.</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
margin;mso-element-left:center;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>
  <p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  margin;mso-element-left:center;mso-height-rule:exactly'><i style='mso-bidi-font-style:
  normal'><span lang=EN-US>Exercise 8.2</span></i><span lang=EN-US>. Give the
  models of <i style='mso-bidi-font-style:normal'>P</i>.</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<p class=tekst><span lang=EN-US>The remaining ground atoms in the Herbrand base
are not known to be true, and we add their negation to obtain <i
style='mso-bidi-font-style:normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i>):</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
student_of(paul,peter).<br>
:-student_of(paul,paul).<br>
:-student_of(peter,paul).<br>
:-student_of(peter,peter).<br>
:-likes(paul,paul).<br>
:-likes(paul,peter).<br>
:-likes(peter,peter).</span></p>

<p class=tekst><span lang=EN-US>Note that <i style='mso-bidi-font-style:normal'>CWA</i>(<i
style='mso-bidi-font-style:normal'>P</i>) has only one model: </span></p>

<p class=sektie style='margin-top:6.0pt;margin-right:0cm;margin-bottom:6.0pt;
margin-left:0cm'><span lang=EN-US>{</span><span lang=EN-US style='font-family:
Courier'>student_of(paul,peter)</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>likes(peter,paul)</span><span
lang=EN-US>}</span></p>

<p class=tekst><span lang=EN-US>That is, <i style='mso-bidi-font-style:normal'>CWA</i>(<i
style='mso-bidi-font-style:normal'>P</i>) is a complete program, assigning <b
style='mso-bidi-font-weight:normal'>true</b> or <b style='mso-bidi-font-weight:
normal'>false</b> to every ground atom in the Herbrand base. While our original
program had several, alternative models, the extended program has exactly one
model. This model is then declared to be the <i style='mso-bidi-font-style:
normal'>intended model</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;intended model</span></i><span
lang=EN-US>:according to CWA<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the original program.</span></p>

<p class=sektie><span lang=EN-US>If we add the clause <i style='mso-bidi-font-style:
normal'>C</i>=</span><span lang=EN-US style='font-family:Courier'>likes(paul,X)</span><span
lang=EN-US> to <i style='mso-bidi-font-style:normal'>P</i>, we find that <i
style='mso-bidi-font-style:normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i></span><span
lang=EN-US style='font-family:Symbol'>È</span><span lang=EN-US>{<i
style='mso-bidi-font-style:normal'>C</i>}) is</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
student_of(paul,peter).<br>
likes(paul,X).<br>
:-student_of(paul,paul).<br>
:-student_of(peter,paul).<br>
:-student_of(peter,peter).<br>
:-likes(peter,peter).</span></p>

<p class=tekst><span lang=EN-US>This example shows that extending the set of
clauses results in a smaller CWA-complement, just as we would expect from a
non-monotonic</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;non-monotonic
reasoning&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>form of reasoning. </span></p>

<p class=sektie><span lang=EN-US>The CWA is limited to definite clauses: if it
is applied to indefinite clause</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;indefinite
clause:inconsistency of CWA&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, the resulting CWA-closure will be inconsistent. For instance, let
<i style='mso-bidi-font-style:normal'>P</i> be</span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
flies(X);abnormal(X):-bird(X).</span></p>

<p class=tekst><span lang=EN-US>then the Herbrand base is </span></p>

<p class=p-el><span lang=EN-US>{bird(tweety), abnormal(tweety), flies(tweety)</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>of which only the first ground atom follows
logically from <i style='mso-bidi-font-style:normal'>P</i>. Thus, <i
style='mso-bidi-font-style:normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i>)
is</span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
flies(X);abnormal(X):-bird(X).<br>
:-flies(tweety)<br>
:-abnormal(tweety)</span></p>

<p class=tekst><span lang=EN-US>which is inconsistent: it does not have a
model, since the first two clauses require that at least one of </span><span
lang=EN-US style='font-family:Courier'>abnormal(tweety)</span><span lang=EN-US>,
</span><span lang=EN-US style='font-family:Courier'>flies(tweety)</span><span
lang=EN-US> is true. Since the Closed World Assumption is unable to handle
indefinite clauses, it is equally unable to handle general clauses with negated
literals in the body. The CWA originates from the field of databases, where all
information is stored in the form of ground atoms, so that indefinite
(disjunctive) information does not occur. </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Closed World Assumption:origin of&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=sektie1><span lang=EN-US>A more sophisticated way to construct
complete programs is called <i style='mso-bidi-font-style:normal'>Predicate
Completion</i></span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Completion&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. The basic idea of Predicate Completion is to view each clause as
part of the <i style='mso-bidi-font-style:normal'>definition</i> of a specific
predicate. For instance, a clause like </span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter)</span></p>

<p class=tekst><span lang=EN-US>is seen as part of the definition of the </span><span
lang=EN-US style='font-family:Courier'>likes</span><span lang=EN-US> predicate.
Such a clause gives values for </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>Y</span><b
style='mso-bidi-font-weight:normal'><span lang=EN-US> </span></b><span
lang=EN-US>in which </span><span lang=EN-US style='font-family:Courier'>likes(X,Y)</span><span
lang=EN-US> is true. In other words, it belongs to the <i style='mso-bidi-font-style:
normal'>if</i> part</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;predicate
definition:<i style='mso-bidi-font-style:normal'>if</i> part&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the definition: ‘<i
style='mso-bidi-font-style:normal'>X</i> likes <i style='mso-bidi-font-style:
normal'>Y</i> if …’. This definition can be <i style='mso-bidi-font-style:normal'>completed</i>
by adding the <i style='mso-bidi-font-style:normal'>only-if</i> part</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;predicate
definition:<i style='mso-bidi-font-style:normal'>only-if</i> part&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, resulting in a full definition: ‘<i style='mso-bidi-font-style:
normal'>X</i> likes <i style='mso-bidi-font-style:normal'>Y</i> if and only if
…’. Such a full definition is most easily expressed in Predicate Logic</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate
Logic:for Predicate Completion&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. For instance, the above clause could be completed to the following
full definition:</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>S:likes(X,S)</span><span lang=EN-US style='font-family:Symbol'>«</span><span
lang=EN-US>X=peter</span><span lang=EN-US style='font-family:Symbol'>Ù</span><span
lang=EN-US>student_of(S,peter)</span></p>

<p class=tekst><span lang=EN-US>In words: ‘<i style='mso-bidi-font-style:normal'>X</i>
likes <i style='mso-bidi-font-style:normal'>S</i> if and only if <i
style='mso-bidi-font-style:normal'>X</i> is Peter, and <i style='mso-bidi-font-style:
normal'>S</i> is a student of Peter’, that is, Peter is the only one who likes
people, and the people Peter likes are his students, and nobody else. We can
translate this formula back to clausal form (see section 2.5), which yields a
set of clauses</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
X=peter:-likes(X,S).<br>
student_of(S,peter):-likes(X,S).</span></p>

<p class=tekst><span lang=EN-US>The first clause was originally given; the
other two are added by the Completion process.</span></p>

<p class=sektie><span lang=EN-US>In general, the procedure for completing a
predicate definition consists of the following steps (a Prolog program which
performs Predicate Completion is given in Appendix B.2): </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;predicate definition:completion of&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming style='margin-top:6.0pt'><span lang=EN-US>(1)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>make sure that every argument of
the predicate in the head of each clause is a distinct variable, by adding
literals of the form </span><span lang=EN-US style='font-family:Courier'>Var=Term</span><span
lang=EN-US> to the body;</span></p>

<p class=opsomming><span lang=EN-US>(2)<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>if
there are several clauses, combine them into a single formula with a
disjunctive body (this is possible since after step (1) each clause has the
same head);</span></p>

<p class=opsomming style='margin-bottom:6.0pt'><span lang=EN-US>(3)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>turn the implication</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;implication&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in this formula into an
equivalence</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;equivalence&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>.</span></p>

<p class=tekst><span lang=EN-US>Step (3) is the actual Completion step; the
first two steps are preparatory.</span></p>

<p class=sektie><span lang=EN-US>As an example, consider the following set of
clauses:</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
likes(X,Y):-friend(Y,X).</span></p>

<p class=tekst><span lang=EN-US>The first step results in the clauses</span></p>

<p class=p-el><span lang=EN-US>likes(X,S):-X=peter,student_of(S,peter).<br>
likes(X,Y):-friend(Y,X).</span></p>

<p class=tekst><span lang=EN-US>In the second step, these clauses are combined
into a single formula in Predicate Logic:</span></p>

<p class=p-el style='margin-left:86.0pt;text-indent:-69.0pt'><span lang=EN-US
style='font-family:Symbol'>&quot;</span><span lang=EN-US>X</span><span
lang=EN-US style='font-family:Symbol'>&quot;</span><span lang=EN-US>Y:likes(X,Y)</span><span
lang=EN-US style='font-family:Symbol'>¬</span><span lang=EN-US> ((X=peter</span><span
lang=EN-US style='font-family:Symbol'>Ù</span><span lang=EN-US>student_of(Y,peter))</span><span
lang=EN-US style='font-family:Symbol'>Ú</span><span lang=EN-US>friend(Y,X))</span></p>

<p class=tekst><span lang=EN-US>This is a formula which is logically equivalent
with the original set of clauses</span><a style='mso-footnote-id:ftn1'
href="#_ftn1" name="_ftnref1" title=""><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span
style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[18]</span></span><![endif]></span></span></span></a><span lang=EN-US>.
The Completion step is done by turning the implication into an equivalence.</span></p>

<p class=sektie><span lang=EN-US>Care should be taken if one of the original
clauses contains variables in the body which do not occur in the head, for
example</span></p>

<p class=p-el><span lang=EN-US>ancestor(X,Y):-parent(X,Y).<br>
ancestor(X,Y):-parent(X,Z),ancestor(Z,Y).</span></p>

<p class=tekst><span lang=EN-US>Here, the second clause is equivalent with the
formula</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>Y</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>Z:ancestor(X,Y)</span><span lang=EN-US style='font-family:Symbol'>¬</span><span
lang=EN-US>(parent(X,Z)</span><span lang=EN-US style='font-family:Symbol'>Ù</span><span
lang=EN-US>ancestor(Z,Y))</span></p>

<p class=tekst><span lang=EN-US>but also with the formula</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>Y:ancestor(X,Y)</span><span lang=EN-US style='font-family:Symbol'>¬</span><span
lang=EN-US>(</span><span lang=EN-US style='font-family:Symbol'>$</span><span
lang=EN-US>Z:parent(X,Z)</span><span lang=EN-US style='font-family:Symbol'>Ù</span><span
lang=EN-US>ancestor(Z,Y))</span></p>

<p class=tekst><span lang=EN-US>For this reason, variables which occur in the
body of a clause but not in the head are often called <i style='mso-bidi-font-style:
normal'>existential</i> variable</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;existential</span></i><span
lang=EN-US> variable<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s. When performing Predicate Completion we must use the <b
style='mso-bidi-font-weight:normal'>second</b> formula, with explicit
existential quantification in the body, because we want all clauses to have
exactly the same head. The two original clauses are thus converted to</span></p>

<p class=p-el style='margin-left:86.0pt;text-indent:-69.0pt'><span lang=EN-US
style='font-family:Symbol'>&quot;</span><span lang=EN-US>X</span><span
lang=EN-US style='font-family:Symbol'>&quot;</span><span lang=EN-US>Y:ancestor(X,Y)</span><span
lang=EN-US style='font-family:Symbol'>¬ </span><span lang=EN-US>(parent(X,Y)</span><span
lang=EN-US style='font-family:Symbol'>Ú</span><span lang=EN-US>(</span><span
lang=EN-US style='font-family:Symbol'>$</span><span lang=EN-US>Z:parent(X,Z)</span><span
lang=EN-US style='font-family:Symbol'>Ù</span><span lang=EN-US>ancestor(Z,Y)))</span></p>

<p class=sektie><span lang=EN-US>A <i style='mso-bidi-font-style:normal'>program</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;program</span></i><span lang=EN-US>:completion
of<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>P</span></i><span lang=EN-US> consisting
of several predicate definitions is completed by completing each predicate
definition separately; for those predicates </span><span lang=EN-US
style='font-family:Courier'>P(X1,</span><span lang=EN-US>…</span><span
lang=EN-US style='font-family:Courier'>,Xn)</span><span lang=EN-US> which occur
in the body of clauses but are themselves not defined, a clause </span><span
lang=EN-US style='font-family:Courier'>:&#8209;P(X1,</span><span lang=EN-US>…</span><span
lang=EN-US style='font-family:Courier'>,Xn)</span><span lang=EN-US> is added.
The resulting set of clauses is denoted <i style='mso-bidi-font-style:normal'>Comp</i>(<i
style='mso-bidi-font-style:normal'>P</i>). For instance, if <i
style='mso-bidi-font-style:normal'>P</i> is</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
student_of(paul,peter).</span></p>

<p class=tekst><span lang=EN-US>then <i style='mso-bidi-font-style:normal'>Comp</i>(<i
style='mso-bidi-font-style:normal'>P</i>) is</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
X=peter:-likes(X,S).<br>
student_of(S,peter):-likes(X,S).<br>
student_of(paul,peter).<br>
X=paul:-student_of(X,Y).<br>
Y=peter:-student_of(X,Y).</span></p>

<p class=tekst><span lang=EN-US>It is easily checked that the completed program
has only one model: </span></p>

<p class=p-el><span lang=EN-US>{student_of(paul,peter), likes(peter,paul)</span><span
lang=EN-US style='font-family:Times'>}</span></p>

<p class=tekst><span lang=EN-US>and is thus complete</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;completeness:of
a program&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. As we saw earlier, this is also the single model of <i
style='mso-bidi-font-style:normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i>),
which means that, in this case, <i style='mso-bidi-font-style:normal'>Comp</i>(<i
style='mso-bidi-font-style:normal'>P</i>) and <i style='mso-bidi-font-style:
normal'>CWA</i>(<i style='mso-bidi-font-style:normal'>P</i>) are logically
equivalent. This is true in general, provided <i style='mso-bidi-font-style:
normal'>P</i> is a set of definite clauses.</span></p>

<p class=sektie><span lang=EN-US>Predicate Completion extends the Closed World
Assumption by also being able to handle programs containing general clause</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;general
clause:completion of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, like</span></p>

<p class=p-el><span lang=EN-US>bird(tweety).<br>
flies(X):-bird(X),not abnormal(X).</span></p>

<p class=tekst><span lang=EN-US>Predicate Completion produces the following
formulas:</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X:bird(X)</span><span lang=EN-US style='font-family:Symbol'>«</span><span
lang=EN-US>X=tweety<br>
</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X:flies(X)</span><span lang=EN-US style='font-family:Symbol'>«</span><span
lang=EN-US>(bird(X)</span><span lang=EN-US style='font-family:Symbol'>Ù</span><span
lang=EN-US>¬abnormal(X))<br>
</span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X:¬abnormal(X)</span></p>

<p class=tekst><span lang=EN-US>In words: Tweety is the only bird, something
flies if and only if it is a bird which is not abnormal, and there are no
abnormal birds. The last formula is added because there is no predicate
definition for </span><span lang=EN-US style='font-family:Courier'>abnormal</span><span
lang=EN-US>.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate
Completion:handling undefined predicates&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>The only model of this
set of formulas is </span></p>

<p class=p-el><span lang=EN-US>{bird(tweety), flies(tweety)}</span></p>

<p class=sektie><span lang=EN-US>However, there are also general clause</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;general
clause:inconsistency of Predicate Completion&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s which Predicate Completion cannot handle. One such a clause is the
following: </span></p>

<p class=p-el><span lang=EN-US>friendly(peter):-not friendly(peter)</span></p>

<p class=tekst><span lang=EN-US>This clause states that the assumption that
Peter is not friendly leads to a contradiction; therefore Peter must be
friendly, and </span><span lang=EN-US style='font-family:Courier'>friendly(peter)</span><span
lang=EN-US> should be a logical consquence of the intended program associated
with this clause. Predicate Completion will construct the formula</span></p>

<p class=p-el><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US>X: friendly(X)</span><span lang=EN-US style='font-family:Symbol'>«</span><span
lang=EN-US>(X=peter </span><span lang=EN-US style='font-family:Symbol'>Ù</span><span
lang=EN-US> ¬friendly(peter))</span></p>

<p class=tekst><span lang=EN-US>It is easy to see that this formula is
inconsistent.</span></p>

<p class=sektie><span lang=EN-US>Admittedly, the above clause is a bit awkward,
since it is logically equivalent with </span></p>

<p class=p-el><span lang=EN-US>friendly(peter)</span></p>

<p class=tekst><span lang=EN-US>However, there are many programs which exhibit
the same problem. Basically, the problem is caused by ‘recursion through
negation</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;recursion: through
negation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>’. For instance, the completion of the following two clauses is also
inconsistent:</span></p>

<p class=p-el><span lang=EN-US>wise(X):-not teacher(X).<br>
teacher(peter):-wise(peter).</span></p>

<p class=tekst><span lang=EN-US>These clauses say ‘anybody who is not a teacher
is wise’ and ‘if Peter is wise, he is a teacher’. Assuming that Peter is not a
teacher leads to a contradiction; therefore, he must be a teacher (and he may
or may not be wise). However, Predicate Completion leads to inconsistencies. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
8.3</span></i><span lang=EN-US>. Apply Predicate Completion to this program.</span></p>

</div>

<p class=tekst><span lang=EN-US>A <i style='mso-bidi-font-style:normal'>stratified</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;program:<i
style='mso-bidi-font-style:normal'>stratified</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>program is a program
without recursion through negation. One can prove that for stratified programs,
Predicate Completion never results in inconsistencies. </span></p>

<h3 id="abduction_and_diagnostic_reasoning"><span lang=EN-US>8.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Abduction
and diagnostic reasoning</span></h3>

<p class=sektie1><span lang=EN-US>Abduction extends default reasoning by not
only making assumptions about what is false, but also about what is true. For instance,
in the lightbulb example given earlier, we know that if the lightbulb is
broken, the light doesn’t switch on. If we observe that the light doesn’t
switch on, a possible explanation is that the lightbulb is broken. Since this
is only one of the possible explanations, it cannot be guaranteed to be true.
For instance, there might be a problem with the power supply instead, or the
switch might be broken. </span></p>

<p class=sektie><span lang=EN-US>The general problem of abduction</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abduction&quot;
\b </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>can be stated as
follows. Given a <i style='mso-bidi-font-style:normal'>Theory</i> and an <i
style='mso-bidi-font-style:normal'>Observation</i>, find an <i
style='mso-bidi-font-style:normal'>Explanation</i> such that</span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Explanation</i><b
style='mso-bidi-font-weight:normal'> </b></span><span lang=EN-US
style='font-family:Extra'>=</span><span lang=EN-US> <i style='mso-bidi-font-style:
normal'>Observation</i></span></p>

<p class=tekst><span lang=EN-US>i.e. the <i style='mso-bidi-font-style:normal'>Observation</i>
follows logically from the <i style='mso-bidi-font-style:normal'>Theory</i>
extended with the <i style='mso-bidi-font-style:normal'>Explanation</i>. For
instance, if <i style='mso-bidi-font-style:normal'>Theory</i> consists of the
following clauses</span></p>

<p class=p-el><span lang=EN-US>likes(peter,S):-student_of(S,peter).<br>
likes(X,Y):-friend(Y,X).</span></p>

<p class=tekst><span lang=EN-US>and we have the <i style='mso-bidi-font-style:
normal'>Observation</i> </span><span lang=EN-US style='font-family:Courier'>likes(peter,paul)</span><span
lang=EN-US>, then possible <i style='mso-bidi-font-style:normal'>Explanations</i>
are {</span><span lang=EN-US style='font-family:Courier'>student_of(paul,peter)</span><span
lang=EN-US>} and {</span><span lang=EN-US style='font-family:Courier'>friend(paul,peter)</span><span
lang=EN-US>}. </span></p>

<p class=sektie><span lang=EN-US>Other <i style='mso-bidi-font-style:normal'>Explanations</i>
which satisfy the problem specification are {</span><span lang=EN-US
style='font-family:Courier'>likes(X,paul)</span><span lang=EN-US>} and {</span><span
lang=EN-US style='font-family:Courier'>likes(X,Y):-friendly(Y)</span><span
lang=EN-US>,</span><span lang=EN-US style='font-family:Courier'>friendly(paul)</span><span
lang=EN-US>}. However, abductive explanations are usually restricted to ground
literals with predicates that are undefined in <i style='mso-bidi-font-style:
normal'>Theory</i> (such literals are called <i style='mso-bidi-font-style:
normal'>abducible</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;abducible&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>). Inferring general rules from specific observations is called
induction</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and is discussed in the next chapter. </span></p>

<p class=sektie><span lang=EN-US>Procedurally, we can construct an abductive
explanation</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abductive
explanation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>by trying to prove the <i
style='mso-bidi-font-style:normal'>Observation</i> from the initial <i
style='mso-bidi-font-style:normal'>Theory</i> alone: whenever we encounter a
literal for which there is no clause to resolve with, we add the literal to the
<i style='mso-bidi-font-style:normal'>Explanation</i>. This leads to the
following abductive meta-interpreter</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:abductive&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>.</span></p>

<p class=oms-eerst><span lang=EN-US>% abduce(O,E) &lt;- observation O follows
by SLD-resolution <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>from the theory defined by clause/2, <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>extended with a list of unit clauses E</span></p>

<p class=pi-laatst><span lang=EN-US>abduce(O,E) :-<br>
abduce(O,[],E).</span></p>

<p class=oms><span lang=EN-US>% with accumulator for explanations</span></p>

<p class=pi style='page-break-after:auto;tab-stops:171.0pt'><span lang=EN-US>abduce(true,E,E):-!.</span></p>

<p class=pi style='page-break-after:auto;tab-stops:171.0pt'><span lang=EN-US>abduce((A,B),E0,E):-!,<br>
abduce(A,E0,E1),<br>
abduce(B,E1,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:171.0pt'><span lang=EN-US>abduce(A,E0,E):-<br>
clause(A,B),<br>
abduce(B,E0,E).</span></p>

<p class=pi style='tab-stops:171.0pt'><span lang=EN-US>abduce(A,E,E):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
already assumed<br>
element(A,E).</span></p>

<p class=pi-laatst style='tab-stops:171.0pt'><span lang=EN-US>abduce(A,E,[A|E]):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% A can be
added to E<br>
not element(A,E),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% if
it's not already there,<br>
abducible(A).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
and if it's abducible</span></p>

<p class=pi-laatst><span lang=EN-US>abducible(A):-<br>
not clause(A,B).</span></p>

<p class=tekst><span lang=EN-US>The last two clauses of </span><span
lang=EN-US style='font-family:Courier'>abduce/3</span><span lang=EN-US> extend
the original depth-first meta-interpreter. The program uses an accumulator
containing the partial explanation found so far, such that literals are not
unnecessarily duplicated in the final explanation. The query </span></p>

<p class=p-el><span lang=EN-US>?-abduce(likes(peter,paul),Explanation)</span></p>

<p class=tekst><span lang=EN-US>results in the answers</span></p>

<p class=p-el><span lang=EN-US>Explanation = [student_of(paul,peter)];<br>
Explanation = [friend(paul,peter)]</span></p>

<p class=sektie><span lang=EN-US>Interestingly, this abductive meta-interpreter
also works for general clauses, but it does not always produce correct
explanations. For instance, suppose the initial <i style='mso-bidi-font-style:
normal'>Theory</i> contains a general clause:</span></p>

<p class=p-el><span lang=EN-US>flies(X):-bird(X),not abnormal(X).<br>
abnormal(X):-penguin(X).<br>
bird(X):-penguin(X).<br>
bird(X):-sparrow(X).</span></p>

<p class=tekst><span lang=EN-US>If asked to explain </span><span lang=EN-US
style='font-family:Courier'>flies(tweety)</span><span lang=EN-US>, the above
program will try to find a clause explaining </span><span lang=EN-US
style='font-family:Courier'>not(abnormal(tweety))</span><span lang=EN-US>;
since there is no such clause, this negated literal will be added to the
explanation. As a result, the program will give the following explanations:</span></p>

<p class=p-el><span lang=EN-US>Explanation = [not abnormal(tweety),penguin(tweety)];<br>
Explanation = [not abnormal(tweety),sparrow(tweety)]</span></p>

<p class=tekst><span lang=EN-US>There are two problems with these explanations.
First of all, the first explanation is inconsistent with the theory. Secondly, </span><span
lang=EN-US style='font-family:Courier'>abnormal/1</span><span lang=EN-US> is
not an abducible predicate, and should not appear in an abductive explanation.
For these reasons, we have to deal explicitly with negated literals in our
abduction program. </span></p>

<p class=sektie><span lang=EN-US>As a first try, we can extend our abductive
meta-interpreter with negation as failure</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;negation
as failure:in abduction&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, by adding the following clause (see also section 3.8):</span></p>

<p class=pi-el><span lang=EN-US>abduce(not(A),E,E):-<span style='mso-tab-count:
1'> </span>% E explains not(A)<br>
not abduce(A,E,E).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>% if E
doesn't explain A</span></p>

<p class=tekst><span lang=EN-US>In order to prevent the query </span><span
lang=EN-US style='font-family:Courier'>abducible(not(A))</span><span
lang=EN-US> from succeeding, we change the definition of </span><span
lang=EN-US style='font-family:Courier'>abducible/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;abducible/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to</span></p>

<p class=pi-el><span lang=EN-US>abducible(A):-<br>
A \= not(X),<br>
not clause(A,B).</span></p>

<p class=tekst><span lang=EN-US>With this extended abductive meta-interpreter,
the query</span></p>

<p class=p-el><span lang=EN-US>?-abduce(flies(tweety),Explanation).</span></p>

<p class=tekst><span lang=EN-US>now results in the following, correct answer:</span></p>

<p class=p-el><span lang=EN-US>Explanation = [sparrow(tweety)]</span></p>

<p class=tekst><span lang=EN-US>The explanation </span><span lang=EN-US
style='font-family:Courier'>[penguin(tweety)]</span><span lang=EN-US> is found
to be inconsistent, since </span></p>

<p class=p-el><span lang=EN-US>?-abduce(not(abnormal(tweety)),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>[penguin(tweety)],[penguin(tweety)]) </span></p>

<p class=tekst><span lang=EN-US>will fail, as it should. </span></p>

<p class=sektie><span lang=EN-US>However, this approach relies on the fact that
negated literals are checked <b style='mso-bidi-font-weight:normal'>after</b>
the abductive explanation has been constructed. To illustrate this, supppose
that <i style='mso-bidi-font-style:normal'>Theory</i> is extended with the
following clause:</span></p>

<p class=p-el><span lang=EN-US>flies1(X):-not abnormal(X),bird(X)</span></p>

<p class=tekst><span lang=EN-US>Since </span></p>

<p class=p-el><span lang=EN-US>?-abduce(not(abnormal(tweety)),[],[]).</span></p>

<p class=tekst><span lang=EN-US>succeeds, any explanation of </span><span
lang=EN-US style='font-family:Courier'>bird(tweety)</span><span lang=EN-US>
will also be an explanation of </span><span lang=EN-US style='font-family:Courier'>flies1(tweety)</span><span
lang=EN-US>, which is of course wrong. The problem here is that the fact that </span><span
lang=EN-US style='font-family:Courier'>abnormal(tweety)</span><span lang=EN-US>
is considered to be <b style='mso-bidi-font-weight:normal'>false</b> is not
reflected in the explanation. Thus, we need a separate predicate </span><span
lang=EN-US style='font-family:Courier'>abduce_not/3</span><span lang=EN-US> for
building explanations for literals assumed to be false. </span></p>

<p class=sektie><span lang=EN-US>The full program is given below. There are two
changes in </span><span lang=EN-US style='font-family:Courier'>abduce/3</span><span
lang=EN-US>: in the fifth clause, an abducible </span><span lang=EN-US
style='font-family:Courier'>A</span><span lang=EN-US> is only added to the
explanation </span><span lang=EN-US style='font-family:Courier'>E</span><span
lang=EN-US> if it is consistent with it; i.e. if </span><span lang=EN-US
style='font-family:Courier'>E</span><span lang=EN-US> does not explain </span><span
lang=EN-US style='font-family:Courier'>not(A)</span><span lang=EN-US>. In the
sixth clause, an explicit explanation for </span><span lang=EN-US
style='font-family:Courier'>not(A)</span><span lang=EN-US> is constructed. </span></p>

<p class=oms-eerst><span lang=EN-US>% abduce(O,E0,E) &lt;- E is abductive
explanation of O, given <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>E0 (works also for general programs)</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abduce/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(true,E,E):-!.</span></p>

<p class=pi style='page-break-after:auto;tab-stops:198.0pt'><span lang=EN-US>abduce((A,B),E0,E):-!,<br>
abduce(A,E0,E1),<br>
abduce(B,E1,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:187.0pt'><span lang=EN-US>abduce(A,E0,E):-<br>
clause(A,B),<br>
abduce(B,E0,E).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:187.0pt'><span lang=EN-US>abduce(A,E,E):-<br>
element(A,E).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
already assumed</span></p>

<p class=pi style='page-break-after:auto;tab-stops:187.0pt'><span lang=EN-US>abduce(A,E,[A|E]):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
A can be added to E<br>
not element(A,E),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
if it's not already there,<br>
abducible(A),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
if it's abducible,<br>
not abduce_not(A,E,E).<span style='mso-tab-count:1'>&nbsp; </span>% and E
doesn't explain not(A)</span></p>

<p class=pi-laatst style='tab-stops:187.0pt'><span lang=EN-US>abduce(not(A),E0,E):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% find
explanation for not(A)<br>
not element(A,E0),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
should be consistent<br>
abduce_not(A,E0,E).</span></p>

<p class=tekst><span lang=EN-US>The definition of </span><span lang=EN-US
style='font-family:Courier'>abduce_not/3</span><span lang=EN-US> closely
mirrors the clauses for </span><span lang=EN-US style='font-family:Courier'>abduce/3</span><span
lang=EN-US>:</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>a negated conjunction </span><span
lang=EN-US style='font-family:Courier'>not((A,B))</span><span lang=EN-US> is
explained by either explaining </span><span lang=EN-US style='font-family:Courier'>not(A)</span><span
lang=EN-US> <b style='mso-bidi-font-weight:normal'>or</b> </span><span
lang=EN-US style='font-family:Courier'>not(B)</span><span lang=EN-US>;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>if there are clauses for </span><span
lang=EN-US style='font-family:Courier'>A</span><span lang=EN-US>, then </span><span
lang=EN-US style='font-family:Courier'>not(A)</span><span lang=EN-US> is
explained by constructing an explanation for </span><span lang=EN-US
style='font-family:Courier'>not(B)</span><span lang=EN-US>, for <b
style='mso-bidi-font-weight:normal'>every</b> body </span><span lang=EN-US
style='font-family:Courier'>B</span><span lang=EN-US>;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iii</i>)<span
style='mso-tab-count:1'>&nbsp; </span></span><span lang=EN-US style='font-family:
Courier'>not(A)</span><span lang=EN-US> is explained if it is already part of
the explanation;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>iv</i>)<span
style='mso-tab-count:1'>&nbsp; </span>otherwise, </span><span lang=EN-US
style='font-family:Courier'>not(A)</span><span lang=EN-US> is explained by
itself, if </span><span lang=EN-US style='font-family:Courier'>A</span><span
lang=EN-US> is abducible and not explained;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>v</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span></span><span lang=EN-US
style='font-family:Courier'>not(not(A))</span><span lang=EN-US> is explained by
explaining </span><span lang=EN-US style='font-family:Courier'>A</span><span
lang=EN-US>.</span></p>

<p class=tekst><span lang=EN-US>There is no clause for </span><span lang=EN-US
style='font-family:Courier'>true</span><span lang=EN-US>, since </span><span
lang=EN-US style='font-family:Courier'>not(true)</span><span lang=EN-US> cannot
be explained.</span></p>

<p class=oms-eerst><span lang=EN-US>% abduce_not(O,E0,E) &lt;- E is abductive
expl. of not(O)</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce_not</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abduce_not/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((A,B),E0,E):-!,<br>
abduce_not(A,E0,E);<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
disjunction<br>
abduce_not(B,E0,E).</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce_not(A,E0,E):-<br>
setof(B,clause(A,B),L),<br>
abduce_not_l(L,E0,E).</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce_not(A,E,E):-<br>
element(not(A),E).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
not(A) already assumed</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce_not(A,E,[not(A)|E]):-<span
style='mso-tab-count:1'>&nbsp; </span>% not(A) can be added to E<br>
not element(not(A),E),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
if it's not already there,<br>
abducible(A),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
if A is abducible<br>
not abduce(A,E,E).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
and E doesn't explain A</span></p>

<p class=pi-laatst style='tab-stops:198.0pt'><span lang=EN-US>abduce_not(not(A),E0,E):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>% find explanation for
A<br>
not element(not(A),E0),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
should be consistent<br>
abduce(A,E0,E).</span></p>

<p class=pi style='tab-stops:198.0pt'><span lang=EN-US>abduce_not_l([],E,E).</span></p>

<p class=pi-laatst style='tab-stops:198.0pt'><span lang=EN-US>abduce_not_l([B|Bs],E0,E):-<br>
abduce_not(B,E0,E1),<br>
abduce_not_l(Bs,E1,E).</span></p>

<p class=sektie><span lang=EN-US>We illustrate the program on the following set
of clauses. Notice that there are several explanations for </span><span
lang=EN-US style='font-family:Courier'>abnormal(tweety)</span><span lang=EN-US>.
</span></p>

<p class=p-el><span lang=EN-US>flies(X):-bird(X),not abnormal(X).<br>
flies1(X):-not abnormal(X),bird(X).<br>
abnormal(X):-penguin(X).<br>
abnormal(X):-dead(X).<br>
bird(X):-penguin(X).<br>
bird(X):-sparrow(X).</span></p>

<p class=tekst><span lang=EN-US>The following queries show that the order of
unnegated and negated literals in a clause only influences the order in which
abducible</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abducible&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s are added to the explanation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abductive
explanation&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, but not the explanation itself: </span></p>

<p class=p-eerst style='margin-right:-1.0pt;page-break-after:auto'><span
lang=EN-US>?-abduce(flies(tweety),Explanation).<br>
Explanation = <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>[not&nbsp;penguin(tweety),not&nbsp;dead(tweety),sparrow(tweety)]</span></p>

<p class=p-el style='margin-right:-1.0pt'><span lang=EN-US>?-abduce(flies1(tweety),Explanation).<br>
Explanation = <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>[sparrow(tweety),not&nbsp;penguin(tweety),not&nbsp;dead(tweety)]</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
8.4</span></i><span lang=EN-US>. The abductive meta-interpreter will loop on
the program<br>
</span><span lang=EN-US style='font-family:Courier'><span style='mso-tab-count:
2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>wise(X):-not
teacher(X).<br>
<span style='mso-tab-count:2'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher(peter):-wise(peter).<br>
</span><span lang=EN-US>with the query </span><span lang=EN-US
style='font-family:Courier'>?-abduce(teacher(peter),E)</span><span lang=EN-US>
(see section 8.2). Change the interpreter such that this query is handled
correctly, by adding <b style='mso-bidi-font-weight:normal'>all</b> literals
collected in the proof to the abductive explanation. </span></p>

</div>

<p class=sektie1><span lang=EN-US>Abduction</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Abduction:applied
to diagnosis&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>can be used for
formulating hypotheses about faulty components in a malfunctioning system.
Here, the <i style='mso-bidi-font-style:normal'>Theory</i> is a description of
the operation of the system, an <i style='mso-bidi-font-style:normal'>Observation</i>
is a combination of input values and the observed output values, and <i
style='mso-bidi-font-style:normal'>Explanation</i> is a <i style='mso-bidi-font-style:
normal'>diagnosis</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;diagnosis&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, telling us which components are malfunctioning. As an example we
consider a logical circuit for adding three binary digits. Such a circuit can
be built from two XOR-gates, two AND-gates, and an OR-gate (fig. 8.3). Its
behaviour can be described logically as follows: </span></p>

<p class=pi-el><span lang=EN-US>adder(X,Y,Z,Sum,Carry):-<br>
xor(X,Y,S),<br>
xor(Z,S,Sum),<br>
and(X,Y,C1),<br>
and(Z,S,C2),<br>
or(C1,C2,Carry).</span></p>

<p class=pi style='tab-stops:113.0pt 225.0pt'><span lang=EN-US>xor(0,0,0).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>and(0,0,0).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>or(0,0,0).</span></p>

<p class=pi style='tab-stops:113.0pt 225.0pt'><span lang=EN-US>xor(0,1,1).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>and(0,1,0).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>or(0,1,1).</span></p>

<p class=pi style='tab-stops:113.0pt 225.0pt'><span lang=EN-US>xor(1,0,1).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>and(1,0,0).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>or(1,0,1).</span></p>

<p class=pi-laatst style='tab-stops:113.0pt 225.0pt'><span lang=EN-US>xor(1,1,0).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>and(1,1,1).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>or(1,1,1).</span></p>

<p class=sektie><span lang=EN-US>These clauses describe the normal operation of
the system. However, since diagnosis deals with faulty operation of components,
we have to extend the system description with a so-called <i style='mso-bidi-font-style:
normal'>fault model</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;fault model&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Such a fault model describes the behaviour of each component when
it is in a faulty state. We distinguish two faulty states: the output of a
component can be stuck at 0, or it can be stuck at 1. Faulty states are
expressed by literals of the form </span><span lang=EN-US style='font-family:
Courier'>fault(Name=State)</span><span lang=EN-US>, where </span><span
lang=EN-US style='font-family:Courier'>State</span><span lang=EN-US> is either </span><span
lang=EN-US style='font-family:Courier'>s0</span><span lang=EN-US> (stuck at 0)
or </span><span lang=EN-US style='font-family:Courier'>s1</span><span
lang=EN-US> (stuck at 1). The </span><span lang=EN-US style='font-family:Courier'>Name</span><span
lang=EN-US> of a component is given by the system that contains it. Since
components might be nested (e.g. the adder might itself be part of a circuit
that adds two 8-bits binary numbers), the names of the components of a
sub-system are prefixed by the name of that sub-system. This results in the
following system description: </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_6" o:spid="_x0000_i1026" type="#_x0000_t75" style='width:318pt;
   height:224pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image011.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=320 height=226
  src="Part%20III_files/image012.png" v:shapes="Picture_x0020_6"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  8.3.</span></b><span lang=EN-US> A 3-bit adder.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=pi-el><span lang=EN-US>adder(N,X,Y,Z,Sum,Carry):-<br>
xorg(N-xor1,X,Y,S),<br>
xorg(N-xor2,Z,S,Sum),<br>
andg(N-and1,X,Y,C1),<br>
andg(N-and2,Z,S,C2),<br>
org(N-or1,C1,C2,Carry).</span></p>

<p class=pi><span lang=EN-US>xorg(N,X,Y,Z):-xor(X,Y,Z).</span></p>

<p class=pi><span lang=EN-US>xorg(N,0,0,1):-fault(N=s1).</span></p>

<p class=pi><span lang=EN-US>xorg(N,0,1,0):-fault(N=s0).</span></p>

<p class=pi><span lang=EN-US>xorg(N,1,0,0):-fault(N=s0).</span></p>

<p class=pi-laatst><span lang=EN-US>xorg(N,1,1,1):-fault(N=s1).</span></p>

<p class=pi><span lang=EN-US>andg(N,X,Y,Z):-and(X,Y,Z).</span></p>

<p class=pi><span lang=EN-US>andg(N,0,0,1):-fault(N=s1).</span></p>

<p class=pi><span lang=EN-US>andg(N,0,1,1):-fault(N=s1).</span></p>

<p class=pi><span lang=EN-US>andg(N,1,0,1):-fault(N=s1).</span></p>

<p class=pi-laatst><span lang=EN-US>andg(N,1,1,0):-fault(N=s0).</span></p>

<p class=pi><span lang=EN-US>org(N,X,Y,Z):-or(X,Y,Z).</span></p>

<p class=pi><span lang=EN-US>org(N,0,0,1):-fault(N=s1).</span></p>

<p class=pi><span lang=EN-US>org(N,0,1,0):-fault(N=s0).</span></p>

<p class=pi><span lang=EN-US>org(N,1,0,0):-fault(N=s0).</span></p>

<p class=pi-laatst><span lang=EN-US>org(N,1,1,0):-fault(N=s0).</span></p>

<p class=tekst><span lang=EN-US>Such a fault model</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;fault
model:strong&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which includes all possible faulty behaviours, is called a <i
style='mso-bidi-font-style:normal'>strong</i> fault model.</span></p>

<p class=sektie><span lang=EN-US>In order to diagnose the system, we declare </span><span
lang=EN-US style='font-family:Courier'>fault/1</span><span lang=EN-US> as the
(only) abducible predicate, and we make a call to </span><span lang=EN-US
style='font-family:Courier'>abduce/2</span><span lang=EN-US>:</span></p>

<p class=pi-el><span lang=EN-US>diagnosis</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;diagnosis/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Observation,Diagnosis):-<br>
abduce(Observation,Diagnosis).</span></p>

<p class=pi-laatst><span lang=EN-US>abducible(fault(X)).</span></p>

<p class=tekst><span lang=EN-US>For instance, suppose the inputs </span><span
lang=EN-US style='font-family:Courier'>X=0</span><span lang=EN-US>, </span><span
lang=EN-US style='font-family:Courier'>Y=0</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>Z=1</span><span lang=EN-US> result in
the outputs </span><span lang=EN-US style='font-family:Courier'>Sum=0</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>Carry=1</span><span
lang=EN-US> (a double fault). In order to diagnose this behaviour, we formulate
the following query:</span></p>

<p class=p-el><span lang=EN-US>?-diagnosis(adder(a,0,0,1,0,1),D).<br>
D = [fault(a-or1=s1),fault(a-xor2=s0)];<br>
D = [fault(a-and2=s1),fault(a-xor2=s0)];<br>
D = [fault(a-and1=s1),fault(a-xor2=s0)];<br>
D = [fault(a-and2=s1),fault(a-and1=s1),fault(a-xor2=s0)];<br>
D = [fault(a-xor1=s1)];<br>
D = [fault(a-or1=s1),fault(a-and2=s0),fault(a-xor1=s1)];<br>
D = [fault(a-and1=s1),fault(a-xor1=s1)];<br>
D = [fault(a-and2=s0),fault(a-and1=s1),fault(a-xor1=s1)];<br>
No more solutions</span></p>

<p class=tekst><span lang=EN-US>The first diagnosis is very obvious: it states
that </span><span lang=EN-US style='font-family:Courier'>or1</span><span
lang=EN-US> (which calculates </span><span lang=EN-US style='font-family:Courier'>Carry</span><span
lang=EN-US>) is stuck at 1, and </span><span lang=EN-US style='font-family:
Courier'>xor2</span><span lang=EN-US> (which calculates </span><span
lang=EN-US style='font-family:Courier'>Sum</span><span lang=EN-US>) is stuck at
0. But the fault in the output of </span><span lang=EN-US style='font-family:
Courier'>or1</span><span lang=EN-US> might also be caused by </span><span
lang=EN-US style='font-family:Courier'>and2</span><span lang=EN-US> or </span><span
lang=EN-US style='font-family:Courier'>and1</span><span lang=EN-US>, and even
by both! The fifth diagnosis is an interesting one: if </span><span lang=EN-US
style='font-family:Courier'>xor1</span><span lang=EN-US> is stuck at 1, this
accounts for <b style='mso-bidi-font-weight:normal'>both</b> faults in the
outputs of the adder. The remaining three diagnoses are considerably less
interesting, since each of them makes unnecessary assumptions about additional
faulty components. </span></p>

<p class=sektie><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>diagnosis/2</span><span lang=EN-US> generates every
possible diagnosis; it does not make any assumptions about the relative
plausibility of each of them. Several such assumptions can be made. For
instance, we might be interested in the diagnoses with the least number of
faulty components (there is only one smallest diagnosis in the example, but
there may be several in general). Alternatively, we might want to consider only
non-redundant or <i style='mso-bidi-font-style:normal'>minimal</i> diagnoses:
those of which no proper subset is also a diagnosis. This is readily expressed
in Prolog: </span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;diagnosis:minimal&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;minimal diagnosis&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=pi-el><span lang=EN-US>min_diagnosis</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;min_diagnosis/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(O,D):-<br>
diagnosis(O,D),<br>
not((diagnosis(O,D1),proper_subset(D1,D))).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% proper_subset/2: see Appendix A.2</span></p>

<p class=p-laatst style='mso-pagination:widow-orphan'><span lang=EN-US>?-min_diagnosis(adder(a,0,0,1,0,1),D).<br>
D = [fault(a-or1=s1),fault(a-xor2=s0)];<br>
D = [fault(a-and2=s1),fault(a-xor2=s0)];<br>
D = [fault(a-and1=s1),fault(a-xor2=s0)];<br>
D = [fault(a-xor1=s1)];<br>
No more solutions</span></p>

<p class=tekst><span lang=EN-US>It should be noted that the predicate </span><span
lang=EN-US style='font-family:Courier'>min_diagnosis/2</span><span lang=EN-US>
is quite inefficient, since it needs time quadratic in the number of diagnoses
(for each possible diagnosis, it generates in the worst case each possible
diagnosis to see if the second is a proper subset of the first). In turn, the
number of diagnoses is exponential in the number of components. More efficient
ways of generating minimal diagnoses can be found in the literature; they fall
outside the scope of this book. </span></p>

<h3 id="the_complete_picture"><span lang=EN-US>8.4<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>The
complete picture</span></h3>

<p class=sektie1><span lang=EN-US>In this chapter we studied several ways of
dealing with imcomplete information. Incompleteness occurs whenever there is a
ground fact in the Herbrand base</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand
base&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of which we do not know
the truth value. In order to extend our knowledge, we need to make assumptions
about the truth value of such ground facts. The simplest approach is to assume
that everything that is not known to be true must be false. The procedural
equivalent of this is <i style='mso-bidi-font-style:normal'>negation as failure</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;negation as failure&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: everything that is not <b style='mso-bidi-font-weight:normal'>provable</b>
is assumed to be false. Thus, a negated literal </span><span lang=EN-US
style='font-family:Courier'>not L</span><span lang=EN-US> in the body of a
general clause is assumed to be proved if a proof of </span><span lang=EN-US
style='font-family:Courier'>L</span><span lang=EN-US> fails. The resulting
proof procedure is called <i style='mso-bidi-font-style:normal'>SLDNF-resolution</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;SLDNF-resolution&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><a
style='mso-footnote-id:ftn2' href="#_ftn2" name="_ftnref2" title=""><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt'><span style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[19]</span></span><![endif]></span></span></span></a><span lang=EN-US>.</span></p>

<p class=sektie><span lang=EN-US>If we strengthen our proof procedure, we must
strengthen the semantics accordingly. Since the original program is incomplete
it has several models, one of which we need to choose. One way to do this is to
transform the original program into a new, complete program, which we declare
to be the <i style='mso-bidi-font-style:normal'>intended</i> program</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;intended</span></i><span
lang=EN-US> program<i style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. The only model of this complete program is taken as the intended
model</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended model&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the original program.
The <i style='mso-bidi-font-style:normal'>Closed World Assumption</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Closed World Assumption&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a rather naive way to
achieve this, while <i style='mso-bidi-font-style:normal'>Predicate Completion</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Completion&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>can also handle a
restricted subclass of the class of general programs (so-called <i
style='mso-bidi-font-style:normal'>stratified</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;program:<i
style='mso-bidi-font-style:normal'>stratified</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>programs). </span></p>

<p class=sektie><span lang=EN-US>The relation between SLDNF-resolution and
Predicate Completion is as follows. Let <i style='mso-bidi-font-style:normal'>P</i>
be a general program, let <i style='mso-bidi-font-style:normal'>Comp</i>(<i
style='mso-bidi-font-style:normal'>P</i>) denote the completion of <i
style='mso-bidi-font-style:normal'>P</i>, and let </span><span lang=EN-US
style='font-family:Extra'>|</span><span lang=EN-US style='font-size:7.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>SLDNF</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>denote provability by
SLDNF-resolution, treating negated literals in the body of clauses by negation
as failure; then the following relation holds:</span></p>

<p class=formule style='tab-stops:120.0pt 147.0pt'><i style='mso-bidi-font-style:
normal'><span lang=EN-US>P</span></i><span lang=EN-US> </span><span lang=EN-US
style='font-family:Extra'>|</span><span lang=EN-US style='font-size:7.0pt;
position:relative;top:2.0pt;mso-text-raise:-2.0pt'>SLDNF</span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span><i style='mso-bidi-font-style:
normal'>q</i><span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Symbol'>&THORN;<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><i
style='mso-bidi-font-style:normal'><span lang=EN-US>Comp</span></i><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>P</i>)<b style='mso-bidi-font-weight:
normal'> </b></span><span lang=EN-US style='font-family:Extra'>=</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>q<o:p></o:p></i></span></p>

<p class=tekst><span lang=EN-US>This is a <i style='mso-bidi-font-style:normal'>soundness</i>
result for SLDNF-resolution. The corresponding completeness result is not so
easily proved, and holds only for specific sub-classes of programs. </span></p>

<p class=sektie><i style='mso-bidi-font-style:normal'><span lang=EN-US>Default
reasoning</span></i><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Default reasoning&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is reasoning with
typical cases and exceptions. A practical approach to default reasoning is by
explicitly listing the exceptions to a rule by means of <i style='mso-bidi-font-style:
normal'>abnormality predicates</i>. The rule describing the typical case is
represented by a general clause, containing the negation of the abnormality
predicate. An alternative approach is to distinguish between rules which always
hold, and rules which typically hold (so-called <i style='mso-bidi-font-style:
normal'>defaults</i>). A default</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
rule&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is <i style='mso-bidi-font-style:
normal'>applicable</i> whenever it does not lead to inconsistencies. In order
to prevent the applicability of defaults in certain cases, they are assigned <i
style='mso-bidi-font-style:normal'>name</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
rule:<i style='mso-bidi-font-style:normal'>name</i> of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>. These names can then be used in other rules to refer to a specific
default. </span></p>

<p class=sektie><span lang=EN-US>There is a close relation between abnormality
predicate</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abnormality
predicate:relation with names of defaults&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s and names of defaults, demonstrated by the following translation
of default rule</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
rule:translation to general clauses&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s to general clauses. The default rule </span></p>

<p class=p-el><span lang=EN-US>default(bats_fly(X),(flies(X):-bat(X)))</span></p>

<p class=tekst><span lang=EN-US>is first translated to a clause</span></p>

<p class=p-el><span lang=EN-US>flies(X):-bat(X),bats_fly(X)</span></p>

<p class=tekst><span lang=EN-US>after which the predicate </span><span
lang=EN-US style='font-family:Courier'>bats_fly/1</span><span lang=EN-US>,
indicating the normal case, is converted to a negated abnormality predicate:</span></p>

<p class=p-el><span lang=EN-US>flies(X):-bat(X),not nonflying_bat(X)</span></p>

<p class=tekst><span lang=EN-US>Furthermore, for each negated conclusion in a
rule like</span></p>

<p class=p-el><span lang=EN-US>default(dead_things_dont_fly(X),(not
flies(X):-dead(X)))</span></p>

<p class=tekst><span lang=EN-US>a new predicate is introduced:</span></p>

<p class=p-el><span lang=EN-US>notflies(X):-dead(X),not flying_deadthing(X)</span></p>

<p class=tekst><span lang=EN-US>Thus, the complete set of rules and defaults
about Dracula is translated to the following general program:</span></p>

<p class=p-el style='tab-stops:269.0pt'><span lang=EN-US>notflies(X):-mammal(X),not
flying_mammal(X).<br>
flies(X):-bat(X),not nonflying_bat(X).<br>
notflies(X):-dead(X),not flying_deadthing(X)<br>
mammal(X):-bat(X).<br>
bat(dracula).<br>
dead(dracula).<br>
flying_mammal(X):-bat(X).<br>
nonflying_bat(X):-dead(X).</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
8.5</span></i><span lang=EN-US>. Draw the SLD-trees for the queries </span><span
lang=EN-US style='font-family:Courier'>?-flies(X)</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>?&#8209;notflies(X)</span><span
lang=EN-US>.</span></p>

</div>

<p class=tekst><span lang=EN-US>What this shows is the close relationship
between assuming that something is false unless the opposite can be proved
(negation as failure), and assuming that a default rule is applicable unless
this leads to inconsistencies. </span></p>

<p class=sektie><i style='mso-bidi-font-style:normal'><span lang=EN-US>Abduction</span></i><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Abduction</span></i><span
lang=EN-US>:and negation as failure<i style='mso-bidi-font-style:normal'>&quot;
</i></span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>generalises negation as
failure by formulating assumptions about either truth or falsity of specific
literals (<i style='mso-bidi-font-style:normal'>abducible</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;abducible&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>). For instance, the Dracula example can be handled by the abductive
meta-interpreter</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:abductive&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of section 8.3 without
any problem, if we declare the abnormality predicate</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;abnormality
predicate:as abducible&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s as abducibles: </span></p>

<p class=p-el><span lang=EN-US>abducible(flying_mammal(X)).<br>
abducible(nonflying_bat(X)).<br>
abducible(flying_deadthing(X)).</span></p>

<p class=p-laatst><span lang=EN-US>?-abduce(flies(X),E)<br>
No.</span></p>

<p class=p-laatst><span lang=EN-US>?-abduce(notflies(X),E)<br>
X = dracula<br>
E = [not flying_deadthing(dracula)];<br>
No more solutions.</span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
8.6</span></i><span lang=EN-US>. Remove the last two clauses from the program,
and again determine the answers to the queries </span><span lang=EN-US
style='font-family:Courier'>?-abduce(flies(X),E)</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>?&#8209;abduce(notflies(X),E)</span><span
lang=EN-US>.</span></p>

</div>

<p class=tekst><span lang=EN-US>This shows that negation as failure</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;negation
as failure:as a special case of abduction&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a special case of
abduction. Moreover, it shows that making assumptions about the applicability
of a default rule is a form of abduction.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;default
reasoning:as abduction&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>We can therefore
conclude that abduction is the most general form of reasoning with incomplete
information among the ones discussed in this chapter. However, inductive
reasoning extends abduction by hypothesising complete predicate definitions
rather than sets of ground literals. This will be the subject of the next
chapter. </span></p>

<h3 id="further_reading_8" style='page-break-before:always'><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>Negation as failure and Predicate Completion
are discussed by Clark (1978). In the same volume, the Closed World Assumption
was formally introduced by Reiter (1978). The approach to default reasoning by
means of defaults and rules is due to Poole (1988). In (Poole, 1991), a more
elaborate Prolog implementation of this approach is presented. (Sombé, 1990)
gives a detailed comparison of formalisms for reasoning with incomplete
information, using a single example. </span></p>

<p class=sektie><span lang=EN-US>An extensive overview of different approaches
to abduction and their relation to other forms of reasoning with incomplete
information can be found in (Kakas <i style='mso-bidi-font-style:normal'>et al.</i>,
1992). The abductive meta-interpreter in section 8.3 is based on ideas from the
same paper, as well as parts of the analysis in section 8.4. (Mozeti</span><span
lang=EN-US style='font-family:YuTimes'>Ë</span><span lang=EN-US>, 1992)
presents an efficient algorithm for the computation of minimal diagnoses. </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>K.L.
Clark (</span><span lang=EN-US>1978)<span style='font-variant:small-caps'>,</span>
‘Negation as failure’. In <i style='mso-bidi-font-style:normal'>Logic and
Databases</i>, H. Gallaire &amp; J. Minker (eds), pp. 293-322, Plenum Press.<span
style='display:none;mso-hide:all'>.L.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Clark,
K.L.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>A.C.
Kakas, R.A. Kowalski &amp; F. Toni (</span><span lang=EN-US>1992)<span
style='font-variant:small-caps'>,</span> ‘Abductive Logic Programming’, <i
style='mso-bidi-font-style:normal'>Journal of Logic and Computation</i> <b
style='mso-bidi-font-weight:normal'>2</b>(6): 719-770.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
TC </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;&quot; \l 1 </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Kakas, A.C.&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.A.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Kowalski,
R.A.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Toni,
F.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>I. Mozeti</span><span
lang=EN-US style='font-size:9.0pt;font-family:YuTimes;font-variant:small-caps'>»</span><span
lang=EN-US style='font-variant:small-caps'> (</span><span lang=EN-US>1992)<span
style='font-variant:small-caps'>,</span> ‘A polynomial-time algorithm for
model-based diagnosis’. In <i style='mso-bidi-font-style:normal'>Proc. Tenth
European Conference on Artificial Intelligence, ECAI’92</i>, B. Neumann (ed.),
pp. 729-733, John Wiley.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Mozetic,
I.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>D. Poole
(</span><span lang=EN-US>1988)<span style='font-variant:small-caps'>,</span> ‘A
logical framework for default reasoning’, <i style='mso-bidi-font-style:normal'>Artificial
Intelligence</i> <b style='mso-bidi-font-weight:normal'>36</b>: 27-47.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Poole,
D.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>D. Poole
(</span><span lang=EN-US>1991)<span style='font-variant:small-caps'>,</span>
‘Compiling a default reasoning system into Prolog’, <i style='mso-bidi-font-style:
normal'>New Generation Computing</i> <b style='mso-bidi-font-weight:normal'>9</b>:
3-38.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Poole,
D.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>R. Reiter
(</span><span lang=EN-US>1978)<span style='font-variant:small-caps'>,</span>
‘On closed world databases’. In <i style='mso-bidi-font-style:normal'>Logic and
Databases</i>, H. Gallaire &amp; J. Minker (eds), pp. 55-76, Plenum Press.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Reiter,
R.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>Léa Sombé</span><span
lang=EN-US> (1990), <i style='mso-bidi-font-style:normal'>Reasoning under
Incomplete Information in Artificial Intelligence</i>, John Wiley. Also <i
style='mso-bidi-font-style:normal'>International Journal of Intelligent Systems</i>
<b style='mso-bidi-font-weight:normal'>5</b>(4). </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Sombé, Léa&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<b style='mso-bidi-font-weight:normal'><span lang=EN-US style='font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA'><br clear=all style='page-break-before:right;
mso-break-type:section-break'>
</span></b>

<div class=WordSection4>

<p class=cijfer><span lang=EN-US>9</span></p>

<h2 id="inductive_reasoning"><span lang=EN-US>Inductive reasoning</span></h2>

<p class=sektie1><i style='mso-bidi-font-style:normal'><span lang=EN-US>Induction</span></i><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Induction&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is a form of reasoning
which infers general rules from specific observations. For instance, given the
following <i style='mso-bidi-font-style:normal'>Theory</i></span></p>

<p class=p-el style='tab-stops:170.0pt'><span lang=EN-US>bird(tweety).<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>bird(polly).<br>
has_feathers(tweety).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>has_beak(polly).</span></p>

<p class=tekst><span lang=EN-US>we might want to infer a <i style='mso-bidi-font-style:
normal'>Hypothesis</i> explaining why both Tweety and Polly fly:</span></p>

<p class=p-el><span lang=EN-US>flies(X):-bird(X)</span></p>

<p class=tekst><span lang=EN-US>There is a strong similarity between induction
and abduction: if the <i style='mso-bidi-font-style:normal'>Examples</i>, which
induction seeks to explain, are the ground facts </span><span lang=EN-US
style='font-family:Courier'>flies(tweety)</span><span lang=EN-US> and </span><span
lang=EN-US style='font-family:Courier'>flies(polly)</span><span lang=EN-US>
then the following relation holds:</span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Hypothesis</i><b
style='mso-bidi-font-weight:normal'> </b></span><span lang=EN-US
style='font-family:Extra'>=</span><span lang=EN-US> <i style='mso-bidi-font-style:
normal'>Examples<o:p></o:p></i></span></p>

<p class=tekst><span lang=EN-US>The main difference with abduction is that <i
style='mso-bidi-font-style:normal'>Hypothesis</i> is allowed to be a set of
clauses, rather than a set of ground facts as in abduction. </span></p>

<p class=sektie><span lang=EN-US>Given this similarity, we will try to adopt
the abductive meta-interpreter</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:inductive&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>developed in section 8.3
to perform induction. We assume that the set of possible hypotheses is given by
means of the predicate </span><span lang=EN-US style='font-family:Courier'>inducible/1</span><span
lang=EN-US>.</span></p>

<p class=oms-eerst><span lang=EN-US>% induce(E,H) &lt;- H is inductive
explanation of E</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>induce</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induce/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(E,H):-<br>
induce(E,[],H).</span></p>

<p class=pi style='tab-stops:188.0pt'><span lang=EN-US>induce(true,H,H).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:188.0pt'><span lang=EN-US>induce((A,B),H0,H):-<br>
induce(A,H0,H1),<br>
induce(B,H1,H).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:188.0pt'><span lang=EN-US>induce(A,H0,H):-<br>
clause(A,B),<br>
induce(B,H0,H).</span></p>

<p class=pi style='page-break-after:auto;tab-stops:188.0pt'><span lang=EN-US>induce(A,H0,H):-<br>
element((A:-B),H0),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>%
already assumed<br>
induce(B,H0,H).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
proceed with body of rule</span></p>

<p class=pi-laatst style='tab-stops:188.0pt'><span lang=EN-US>induce(A,H0,[(A:-B)|H]):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>% A:-B can be added to H<br>
inducible((A:-B)),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
if it's inducible, and<br>
not element((A:-B),H0),<span style='mso-tab-count:1'> </span>% if it's not
already there<br>
induce(B,H0,H).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
proceed with body of rule</span></p>

<p class=tekst><span lang=EN-US>Whenever a clause is added to the inductive
hypothesis</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;inductive
hypothesis&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, we proceed by constructing an inductive explanation of its body.</span></p>

<p class=sektie><span lang=EN-US>Suppose </span><span lang=EN-US
style='font-family:Courier'>inducible/1</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;inducible/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is defined as follows:</span></p>

<p class=p-el><span lang=EN-US>inducible((flies(X):-bird(X),has_feathers(X),has_beak(X))).<br>
inducible((flies(X):-has_feathers(X),has_beak(X))).<br>
inducible((flies(X):-bird(X),has_beak(X))).<br>
inducible((flies(X):-bird(X),has_feathers(X))).<br>
inducible((flies(X):-bird(X))).<br>
inducible((flies(X):-has_feathers(X))).<br>
inducible((flies(X):-has_beak(X))).<br>
inducible((flies(X):-true)).</span></p>

<p class=tekst><span lang=EN-US>These facts state that every clause with </span><span
lang=EN-US style='font-family:Courier'>flies/1</span><span lang=EN-US> in its
head and some of the predicates in <i style='mso-bidi-font-style:normal'>Theory</i>
in its body is a possible inductive hypothesis. We can use </span><span
lang=EN-US style='font-family:Courier'>induce/2</span><span lang=EN-US> to find
out which of these clauses account for the fact that Tweety and Polly fly:</span></p>

<p class=p-el><span lang=EN-US>?-induce(flies(tweety),H).<br>
H = [(flies(tweety):-bird(tweety),has_feathers(tweety))];<br>
H = [(flies(tweety):-bird(tweety))];<br>
H = [(flies(tweety):-has_feathers(tweety))];<br>
H = [(flies(tweety):-true)];<br>
No more solutions</span></p>

<p class=p-laatst><span lang=EN-US>?-induce(flies(polly),H).<br>
H = [(flies(polly):-bird(polly),has_beak(polly))];<br>
H = [(flies(polly):-bird(polly))];<br>
H = [(flies(polly):-has_beak(polly))];<br>
H = [(flies(polly):-true)];<br>
No more solutions</span></p>

<p class=tekst><span lang=EN-US>We can combine the answers to these queries in
order to find a single clause which explains <b style='mso-bidi-font-weight:
normal'>both</b> </span><span lang=EN-US style='font-family:Courier'>flies(tweety)</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>flies(polly)</span><span
lang=EN-US>. One way to do this is by <i style='mso-bidi-font-style:normal'>generalisation</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;generalisation&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, as will be explained later. Another way is to process all the
examples at once. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
9.1</span></i><span lang=EN-US>. Change </span><span lang=EN-US
style='font-family:Courier'>induce/3</span><span lang=EN-US> so that it handles
a list of examples rather than a single example. Moreover, the inductive
hypothesis should contain uninstantiated clauses, so that the same clause can
be used to explain several examples. </span></p>

</div>

<p class=sektie><span lang=EN-US>However, a serious problem with this approach
is the impracticality of listing every possible hypothesis by means of the
predicate </span><span lang=EN-US style='font-family:Courier'>inducible/1</span><span
lang=EN-US>. In general, the inductive hypothesis can consist of several
clauses, and might be recursive. The <i style='mso-bidi-font-style:normal'>hypothesis
space</i></span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:<i
style='mso-bidi-font-style:normal'>hypothesis space</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of possible sets of
clauses is typically very large, and even infinite when functors are involved.
This space needs to be searched in a systematic manner. Another complication is
the possibility of <i style='mso-bidi-font-style:normal'>overgeneralisation</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;overgeneralisation&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> like the clause </span><span lang=EN-US style='font-family:Courier'>flies(X):-true</span><span
lang=EN-US>. In order to prevent overgeneralisation, <i style='mso-bidi-font-style:
normal'>negative examples</i> need to be included in the induction process
(here: non-flying objects). For these reasons, induction requires a more
sophisticated search strategy than abduction. We will take a closer look at the
structure of the search space in the next section. Then, we will develop two
programs that can induce definitions for predicates like </span><span
lang=EN-US style='font-family:Courier'>append/3</span><span lang=EN-US> from
examples. </span></p>

<h3 id="generalisation_and_specialisation"><span lang=EN-US>9.1<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Generalisation
and specialisation</span></h3>

<p class=sektie1><span lang=EN-US>An <i style='mso-bidi-font-style:normal'>example</i>
is a ground fact for the predicate of which a definition is to be induced. A <i
style='mso-bidi-font-style:normal'>positive</i> example</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;positive</span></i><span
lang=EN-US> example<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is true in the intended
interpretation</span><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
interpretation&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, while a <i style='mso-bidi-font-style:normal'>negative</i> example</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;negative</span></i><span
lang=EN-US> example<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>is false. Consequently,
the inductive <i style='mso-bidi-font-style:normal'>Hypothesis</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;inductive
<i style='mso-bidi-font-style:normal'>Hypothesis</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>should be such that for
every positive example <i style='mso-bidi-font-style:normal'>p</i></span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Hypothesis</i><b
style='mso-bidi-font-weight:normal'> </b></span><span lang=EN-US
style='font-family:Extra'>=</span><span lang=EN-US> <i style='mso-bidi-font-style:
normal'>p<o:p></o:p></i></span></p>

<p class=tekst><span lang=EN-US>while for every negative example <i
style='mso-bidi-font-style:normal'>n</i></span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Hypothesis</i><b
style='mso-bidi-font-weight:normal'> </b></span><!--[if supportFields]><b
style='mso-bidi-font-weight:normal'><span lang=EN-US><span style='mso-element:
field-begin'></span><span style="mso-spacerun:yes">&nbsp;</span>EQ \</span></b><span
lang=EN-US>O(</span><span lang=EN-US style='font-family:Extra'>=</span><span
lang=EN-US>;/) <b style='mso-bidi-font-weight:normal'><span
style="mso-spacerun:yes">&nbsp;</span></b></span><![endif]--><!--[if supportFields]><b
style='mso-bidi-font-weight:normal'><span lang=EN-US><span style='mso-element:
field-end'></span></span></b><![endif]--><i style='mso-bidi-font-style:normal'><span
lang=EN-US>n<o:p></o:p></span></i></p>

<p class=tekst><span lang=EN-US>We say that <i style='mso-bidi-font-style:normal'>p</i>
is <i style='mso-bidi-font-style:normal'>covered</i> by <i style='mso-bidi-font-style:
normal'>Hypothesis</i>, given <i style='mso-bidi-font-style:normal'>Theory</i>.
For instance, if <i style='mso-bidi-font-style:normal'>Hypothesis</i> is the
standard recursive definition of </span><span lang=EN-US style='font-family:
Courier'>element/2</span><!--[if supportFields]><span lang=EN-US
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;element/2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span lang=EN-US>:</span></p>

<p class=p-el><span lang=EN-US>element(X,[X|Z]).<br>
element(X,[Y|Z]):-element(X,Z).</span></p>

<p class=tekst><span lang=EN-US>then the example </span><span lang=EN-US
style='font-family:Courier'>element(b,[a,b])</span><span lang=EN-US> is covered
(with empty <i style='mso-bidi-font-style:normal'>Theory</i>).</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;coverage&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>This can be demonstrated
by a simple meta-interpreter for definite clauses. Note that this proof
requires <b style='mso-bidi-font-weight:normal'>both</b> of the above clauses.
Alternatively, if </span><span lang=EN-US style='font-family:Courier'>element(b,[b])</span><span
lang=EN-US> is also known to be a positive example, we can say that </span><span
lang=EN-US style='font-family:Courier'>element(b,[a,b])</span><span lang=EN-US>
is covered by the second, recursive clause alone. The first definition of
coverage, which refers to the complete hypothesis, is called <i
style='mso-bidi-font-style:normal'>intensional</i> coverage</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;intensional</span></i><span
lang=EN-US> coverage<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, while the second, referring to single clauses plus the rest of the
examples, is called <i style='mso-bidi-font-style:normal'>extensional</i>
coverage</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;extensional</span></i><span
lang=EN-US> coverage<i style='mso-bidi-font-style:normal'>&quot; \b </i></span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. In the induction programs to be developed, we will employ both
notions of coverage; for the moment, however, the distinction is immaterial. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
9.2</span></i><span lang=EN-US>. Write a predicate </span><span lang=EN-US
style='font-family:Courier'>covers_ex/3</span><span lang=EN-US> which, given a
clause, an example, and a list of positive examples, tests whether the clause
extensionally covers the example. </span></p>

</div>

<p class=sektie><span lang=EN-US>If <i style='mso-bidi-font-style:normal'>Hypothesis1</i>
covers at least all the examples covered by <i style='mso-bidi-font-style:normal'>Hypothesis2</i>,
we say that <i style='mso-bidi-font-style:normal'>Hypothesis1</i> is at least
as <i style='mso-bidi-font-style:normal'>general</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;at
least as <i style='mso-bidi-font-style:normal'>general</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as <i style='mso-bidi-font-style:
normal'>Hypothesis2</i>, or that <i style='mso-bidi-font-style:normal'>Hypothesis2</i>
is at least as <i style='mso-bidi-font-style:normal'>specific</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;at
least as <i style='mso-bidi-font-style:normal'>specific</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>as <i style='mso-bidi-font-style:
normal'>Hypothesis1</i>. From the definition of coverage, one can see that <i
style='mso-bidi-font-style:normal'>Hypothesis2</i> must be a logical
consequence</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;logical
consequence&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of <i style='mso-bidi-font-style:
normal'>Hypothesis1</i>, given <i style='mso-bidi-font-style:normal'>Theory</i>:
</span></p>

<p class=formule><i style='mso-bidi-font-style:normal'><span lang=EN-US>Theory</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Symbol'>È</span><span
lang=EN-US> <i style='mso-bidi-font-style:normal'>Hypothesis1</i><b
style='mso-bidi-font-weight:normal'> </b></span><span lang=EN-US
style='font-family:Extra'>=</span><span lang=EN-US> <i style='mso-bidi-font-style:
normal'>Hypothesis2<o:p></o:p></i></span></p>

<p class=tekst><span lang=EN-US>Suppose <i style='mso-bidi-font-style:normal'>p</i>
is a positive example covered by <i style='mso-bidi-font-style:normal'>Hypothesis1</i>
but not by <i style='mso-bidi-font-style:normal'>Hypothesis2</i>. This means
that <i style='mso-bidi-font-style:normal'>Hypothesis2</i> is too specific; if
it is our current hypothesis, it needs to be <i style='mso-bidi-font-style:
normal'>generalised</i>, for instance to <i style='mso-bidi-font-style:normal'>Hypothesis1</i>.
Similarly, if a hypothesis covers a negative example, it needs to be <i
style='mso-bidi-font-style:normal'>specialised</i>. Generalisation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Generalisation&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>and specialisation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>are the basic operations
of induction. </span></p>

<p class=sektie><span lang=EN-US>Although we defined generality between hypotheses
being <b style='mso-bidi-font-weight:normal'>sets</b> of clauses, practical
approaches to induction usually generalise or specialise single clauses. For
instance, the following are clauses of increasing generality: </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;generality of clauses&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=p-el><span lang=EN-US>element(X,[Y|Z]):-element(X,Z).<br>
element(X,V):-element(X,Z).<br>
element(X,V).</span></p>

<p class=tekst><span lang=EN-US>This shows that a more specific clause can be
constructed by adding a literal, by applying a substitution, or both. This
relation of generality between clauses is called </span><span lang=EN-US
style='font-family:Symbol;display:none;mso-hide:all'>.ib.</span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-subsumption</span><span
lang=EN-US style='font-family:Symbol;display:none;mso-hide:all'>;</span><span
lang=EN-US>. Formally, </span><span lang=EN-US style='font-family:Courier'>Clause1</span><span
lang=EN-US> </span><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumes</span></i><span
lang=EN-US> </span><span lang=EN-US style='font-family:Courier'>Clause2</span><span
lang=EN-US> if there is a substitution</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;substitution&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span></span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US> that can be applied to </span><span
lang=EN-US style='font-family:Courier'>Clause1</span><span lang=EN-US>, such
that every literal in the resulting clause occurs in </span><span lang=EN-US
style='font-family:Courier'>Clause2</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>Notice that </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US> only replaces variables in
</span><span lang=EN-US style='font-family:Courier'>Clause1</span><span
lang=EN-US>, not in </span><span lang=EN-US style='font-family:Courier'>Clause2</span><span
lang=EN-US>. One way to test if such a </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US> exists is to ground all
variables in </span><span lang=EN-US style='font-family:Courier'>Clause2</span><span
lang=EN-US>, and then unify the ground version of </span><span lang=EN-US
style='font-family:Courier'>Clause2</span><span lang=EN-US> with </span><span
lang=EN-US style='font-family:Courier'>Clause1</span><span lang=EN-US>.
Grounding the variables in a term can be done by means of the built-in
predicate </span><span lang=EN-US style='font-family:Courier'>numbervars/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;numbervars/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which unifies different variables with terms of the form </span><span
lang=EN-US style='font-family:Courier'>'$VAR(N)'</span><span lang=EN-US>. </span></p>

<p class=pi-el><span lang=EN-US>theta_subsumes1((H:-B1),(H:-B2)):-<br>
ground(B2),<br>
subset(B1,B2).</span></p>

<p class=pi-laatst><span lang=EN-US>ground</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;ground/1&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Term):-<br>
numbervars(Term,0,N).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% subset/2: see Appendix A.2</span></p>

<p class=tekst><span lang=EN-US>This approach has the disadvantage that one or
both clauses are changed after a call to </span><span lang=EN-US
style='font-family:Courier'>theta_subsumes1/2</span><span lang=EN-US>. To avoid
this, we apply the following little programming trick: </span></p>

<p class=pi-el><span lang=EN-US>theta_subsumes</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;theta_subsumes/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((H1:-B1),(H2:-B2)):-<br>
not((H1=H2,ground(B2),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>not
subset(B1,B2))).</span></p>

<p class=tekst><span lang=EN-US style='font-family:Courier'>theta_subsumes/2</span><span
lang=EN-US> succeeds exactly when </span><span lang=EN-US style='font-family:
Courier'>theta_subsumes1/2</span><span lang=EN-US> does, but by means of the
double negation unifications are ‘undone’ after the call succeeds. </span></p>

<p class=sektie style='page-break-after:avoid'><span lang=EN-US>Next, we turn
to the issue of how to construct generalisations of clauses. First we consider
the simpler case of generalising two atoms. Consider the following two ground
facts:</span></p>

<p class=p-el><span lang=EN-US>element(1,[1])<br>
element(z,[z,y,x])</span></p>

<p class=tekst><span lang=EN-US>The following atom </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumes both of them:</span></p>

<p class=p-el><span lang=EN-US>element(X,[X|Y])</span></p>

<p class=tekst><span lang=EN-US>Note that this atom is </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumed by every other
possible generalisation (such as </span><span lang=EN-US style='font-family:
Courier'>element(X,[Y|Z])</span><span lang=EN-US> or </span><span lang=EN-US
style='font-family:Courier'>element(X,Y)</span><span lang=EN-US>). For this
reason, it is called a <i style='mso-bidi-font-style:normal'>least general
generalisation under </i></span><i style='mso-bidi-font-style:normal'><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-subsumption</span></i><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;least general generalisation: under
</span></i><i style='mso-bidi-font-style:normal'><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumption&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>or </span><span
lang=EN-US style='font-family:Symbol;display:none;mso-hide:all'>.ib.</span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG</span><span
lang=EN-US style='font-family:Symbol;display:none;mso-hide:all'>;</span><span
lang=EN-US>. </span><span lang=EN-US style='font-family:Symbol'>q</span><span
lang=EN-US>-LGG’s of atoms can be computed by means of <i style='mso-bidi-font-style:
normal'>anti-unification</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;anti-unification&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. This operation is the dual of unification. It operates by
comparing the terms occurring at the same position in the two atoms, and
replacing them by a new variable if they are different. The terms which have
already been replaced by a variable are collected in two lists, because if the same
pair of terms is encountered again, it should be replaced by the same variable
(see </span><span lang=EN-US style='font-family:Courier'>1</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>z</span><span
lang=EN-US> in the example above). For obvious reasons, such lists are called <i
style='mso-bidi-font-style:normal'>inverse substitution</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inverse substitution&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US>.</span></p>

<p class=pi-el><span lang=EN-US>:-op(600,xfx,'&lt;-'). % operator for inverse
substitution</span></p>

<p class=oms style='tab-stops:172.0pt'><span lang=EN-US>% anti_unify(T1,T2,T)
&lt;-<span style='mso-tab-count:1'>&nbsp; </span>T is the anti-unification <br>
%<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>of
T1 and T2</span></p>

<p class=pi-laatst><span lang=EN-US>anti_unify</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;anti_unify/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Term1,Term2,Term):-<br>
anti_unify(Term1,Term2,Term,[],S1,[],S2).</span></p>

<p class=pi><span lang=EN-US>% anti-unification with inverse subst.s and
accumulators</span></p>

<p class=pi style='tab-stops:290.0pt'><span lang=EN-US>anti_unify(Term1,Term2,Term1,S1,S1,S2,S2):-<br>
Term1 == Term2,!.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
same terms</span></p>

<p class=pi style='tab-stops:290.0pt'><span lang=EN-US>anti_unify(Term1,Term2,V,S1,S1,S2,S2):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% already <br>
subs_lookup(S1,S2,Term1,Term2,V),!.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
substituted</span></p>

<p class=pi style='tab-stops:290.0pt'><span lang=EN-US>anti_unify(Term1,Term2,Term,S10,S1,S20,S2):-<br>
nonvar(Term1),nonvar(Term2),<br>
functor(Term1,F,N),functor(Term2,F,N),!,<span style='mso-tab-count:1'> </span>%
same <br>
functor(Term,F,N),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
functor<br>
anti_unify_args(N,Term1,Term2,Term,S10,S1,S20,S2).</span></p>

<p class=pi-laatst><span lang=EN-US>anti_unify(T1,T2,V,S10,[T1&lt;-V|S10],S20,[T2&lt;-V|S20]).</span></p>

<p class=pi><span lang=EN-US>anti_unify_args(0,Term1,Term2,Term,S1,S1,S2,S2).</span></p>

<p class=pi-laatst><span lang=EN-US>anti_unify_args(N,Term1,Term2,Term,S10,S1,S20,S2):-<br>
N&gt;0,N1 is N-1,<br>
arg(N,Term1,Arg1),<br>
arg(N,Term2,Arg2),<br>
arg(N,Term,Arg),<br>
anti_unify(Arg1,Arg2,Arg,S10,S11,S20,S21),<br>
anti_unify_args(N1,Term1,Term2,Term,S11,S1,S21,S2).</span></p>

<p class=pi><span lang=EN-US>subs_lookup([T1&lt;-V|Subs1],[T2&lt;-V|Subs2],Term1,Term2,V):-<br>
T1 == Term1,<br>
T2 == Term2,!.<span style='mso-tab-count:1'>&nbsp; </span>% no alternative
solutions needed</span></p>

<p class=pi-laatst><span lang=EN-US>subs_lookup([S1|Subs1],[S2|Subs2],Term1,Term2,V):-<br>
subs_lookup(Subs1,Subs2,Term1,Term2,V).</span></p>

<p class=tekst><span lang=EN-US>The following query illustrates the operation
of the program, including the use of inverse substitutions:</span></p>

<p class=query style='margin-bottom:6.0pt'><span lang=EN-US>?-anti_unify(2*2=2+2,2*3=3+3,T,[],S1,[],S2)<br>
T = 2*X=X+X<br>
S1 = [2&lt;-X]<br>
S2 = [3&lt;-X]</span></p>

<p class=tekst><span lang=EN-US>Note that the inverse substitution </span><span
lang=EN-US style='font-family:Courier'>[2&lt;-X]</span><span lang=EN-US> does
not indicate which occurrences of </span><span lang=EN-US style='font-family:
Courier'>2</span><span lang=EN-US> should be replaced by </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US>. This means
that </span><span lang=EN-US style='font-family:Courier'>S1</span><span
lang=EN-US> applied to the first term does not yield </span><span lang=EN-US
style='font-family:Courier'>T</span><span lang=EN-US> (the inverse of </span><span
lang=EN-US style='font-family:Courier'>S1</span><span lang=EN-US> applied to </span><span
lang=EN-US style='font-family:Courier'>T</span><span lang=EN-US> yields the
first term, however). Therefore, a proper definition of inverse substitution
should include the positions of terms which are to be replaced by variables. We
will not elaborate this any further here. </span></p>

<p class=sektie><span lang=EN-US>The construction of the </span><span
lang=EN-US style='font-family:Symbol;display:none;mso-hide:all'>.i.</span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG<span
style='display:none;mso-hide:all'>:construction of;</span> of two clauses makes
use of, but is more complicated than anti-unification. The basic difference
with anti-unification is that the body of a clause is logically speaking
unordered, whereas subterms within a term have fixed positions. Therefore, we
cannot just compare the literals occurring at the same position in the
respective bodies, but should consider all pairs of literals, one from each
body. For instance, the </span><span lang=EN-US style='font-family:Symbol'>q</span><span
lang=EN-US>-LGG of the following two clauses</span></p>

<p class=pi-eerst><span lang=EN-US>element(c,[b,c]):-element(c,[c])</span></p>

<p class=pi-laatst><span lang=EN-US>element(d,[b,c,d]):-element(d,[c,d]),element(d,[d])</span></p>

<p class=tekst><span lang=EN-US>is the clause</span></p>

<p class=pi-el><span lang=EN-US>element(X,[b,c|Y]):-element(X,[c|Y]),element(X,[X])</span></p>

<p class=tekst><span lang=EN-US>The head of this clause is simply obtained by
anti-unifying the heads of the original clauses, and the body is obtained by
anti-unification of </span><span lang=EN-US style='font-family:Courier'>element(c,[c])</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>element(d,[c,d])</span><span
lang=EN-US>, giving </span><span lang=EN-US style='font-family:Courier'>element(X,[c|Y])</span><span
lang=EN-US>, and anti-unification of </span><span lang=EN-US style='font-family:
Courier'>element(c,[c])</span><span lang=EN-US> and </span><span lang=EN-US
style='font-family:Courier'>element(d,[d])</span><span lang=EN-US>, giving </span><span
lang=EN-US style='font-family:Courier'>element(X,[X])</span><span lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>The program for constructing </span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG’s is given
below. Note that the inverse substitutions found in each step are passed on to
the next, so that the literals share variables.</span></p>

<p class=oms-eerst><span lang=EN-US>% theta_lgg(C1,C2,C) &lt;- C is the </span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG of clause
C1 and C2</span></p>

<p class=pi-laatst style='tab-stops:320.0pt'><span lang=EN-US>theta_lgg</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;theta_lgg/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>((H1:-B1),(H2:-B2),(H:-B)):-<br>
anti_unify(H1,H2,H,[],S10,[],S20),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
heads<br>
theta_lgg_bodies(B1,B2,[],B,S10,S1,S20,S2).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
bodies</span></p>

<p class=oms><span lang=EN-US>% select literal from first body...</span></p>

<p class=pi><span lang=EN-US>theta_lgg_bodies([],B2,B,B,S1,S1,S2,S2).</span></p>

<p class=pi-laatst><span lang=EN-US>theta_lgg_bodies([L|B1],B2,B0,B,S10,S1,S20,S2):-<br>
theta_lgg_literal(L,B2,B0,B00,S10,S11,S20,S21),<br>
theta_lgg_bodies(B1,B2,B00,B,S11,S1,S21,S2).</span></p>

<p class=oms><span lang=EN-US>% and one from second body</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>theta_lgg_literal(L1,[],B,B,S1,S1,S2,S2).</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>theta_lgg_literal(L1,[L2|B2],B0,B,S10,S1,S20,S2):-<br>
same_predicate(L1,L2),<br>
anti_unify(L1,L2,L,S10,S11,S20,S21),<br>
theta_lgg_literal(L1,B2,[L|B0],B,S11,S1,S21,S2).</span></p>

<p class=pi-laatst><span lang=EN-US>theta_lgg_literal(L1,[L2|B2],B0,B,S10,S1,S20,S2):-<br>
not same_predicate(L1,L2),<br>
theta_lgg_literal(L1,B2,B0,B,S10,S1,S20,S2).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% same_predicate/2: see Appendix A.2</span></p>

<p class=tekst><span lang=EN-US>To check the above example, we pose the
following query:</span></p>

<p class=query style='margin-top:6.0pt;margin-right:0cm;margin-bottom:6.0pt;
margin-left:26.0pt;page-break-after:auto'><span lang=EN-US>?-theta_lgg((element(c,[b,c]):-[element(c,[c])]),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(element(d,[b,c,d]):-<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>[element(d,[c,d]),element(d,[d])]),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>C)<br>
C = element(X,[b,c|Y]):-[element(X,[X]),element(X,[c|Y])]</span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm'>
  <p class=inter-title style='margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>The relation between </span><span lang=EN-US
  style='font-family:Symbol;display:none;mso-hide:all'>.i.</span><span
  lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-subsumption<span
  style='display:none;mso-hide:all'>:relation with logical consequence;</span>
  and logical consequence</span><!--[if supportFields]><span lang=EN-US
  style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;logical
  consequence:relation with </span><span lang=EN-US style='font-family:Symbol'>q</span><span
  lang=EN-US>-subsumption&quot; </span><![endif]--><!--[if supportFields]><span
  lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>If </span><span lang=EN-US style='font-family:
  Courier'>Clause1</span><span lang=EN-US> </span><span lang=EN-US
  style='font-family:Symbol'>q</span><span lang=EN-US>-subsumes </span><span
  lang=EN-US style='font-family:Courier'>Clause2</span><span lang=EN-US>, then
  also </span><span lang=EN-US style='font-family:Courier'>Clause1</span><span
  lang=EN-US> </span><span lang=EN-US style='font-family:Extra'>=</span><span
  lang=EN-US> </span><span lang=EN-US style='font-family:Courier'>Clause2</span><span
  lang=EN-US>. The reverse, however, is not always true. Consider the following
  two clauses:</span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US style='font-family:Courier'>list([V|W]):-list(W)<br>
  list([X,Y|Z]):-list(Z)<o:p></o:p></span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>Given </span><span lang=EN-US
  style='font-family:Courier'>list([])</span><span lang=EN-US>, the first
  clause covers lists of arbitrary length, while the second covers only lists
  of even length. All lists covered by the second clause are also covered by
  the first, which is therefore more general. However, there is no substitution
  that can be applied to the first clause to yield the second (such a
  substitution should map </span><span lang=EN-US style='font-family:Courier'>W</span><span
  lang=EN-US> both to </span><span lang=EN-US style='font-family:Courier'>[Y|Z]</span><span
  lang=EN-US> and to </span><span lang=EN-US style='font-family:Courier'>Z</span><span
  lang=EN-US>, which is impossible).</span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>It may seem that </span><span lang=EN-US
  style='font-family:Extra'>=</span><span lang=EN-US> provides a better notion
  of generality than </span><span lang=EN-US style='font-family:Symbol'>q</span><span
  lang=EN-US>-subsumption. However, such a semantic definition of generality
  introduces two problems. One is that it does not suggest a simple procedure
  to generalise clauses, as </span><span lang=EN-US style='font-family:Symbol'>q</span><span
  lang=EN-US>-subsumption does. The second problem is that LGG’s under logical
  consequence</span><!--[if supportFields]><span lang=EN-US style='display:
  none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
  lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;least general
  generalisation:under logical consequence&quot; </span><![endif]--><!--[if supportFields]><span
  lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
  lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>are not always unique.
  Consider the two clauses</span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US style='font-family:Courier'>list([A,B|C]):-list(C)<br>
  list([P,Q,R|S]):-list(S)<o:p></o:p></span></p>
  <p class=intermezzo style='margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto'><span lang=EN-US>Under logical consequence, these clauses have
  two LGG’s: one is <br>
  </span><span lang=EN-US style='font-family:Courier'>list([X|Y]):-list(Y)</span><span
  lang=EN-US>, and the other is </span><span lang=EN-US style='font-family:
  Courier'>list([X,Y|Z]):-list(V)</span><span lang=EN-US>. <br>
  Under </span><span lang=EN-US style='font-family:Symbol'>q</span><span
  lang=EN-US>-subsumption, only the latter is an LGG. <br>
  Note that the first LGG looks in fact more plausible!</span></p>
  </div>
  </td>
 </tr>
</table>

</div>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
9.3. </span></i><span lang=EN-US>Determine the </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-LGG of the following two
clauses: <br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span
lang=EN-US style='font-family:Courier'>reverse([2,1],[3],[1,2,3]):-reverse([1],[2,3],[1,2,3])<br>
<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>reverse([a],[],[a]):-reverse([],[a],[a])</span></p>

</div>

<p class=sektie><span lang=EN-US>In the following section we develop a program
which generalises the examples by constructing </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-LGG’s. This corresponds to
a <i style='mso-bidi-font-style:normal'>specific-to-general</i> search of the
space of possible predicate definitions; it is also called <i style='mso-bidi-font-style:
normal'>bottom-up</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:<i
style='mso-bidi-font-style:normal'>bottom-up</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span></span></i><span lang=EN-US>induction.
Alternatively, one could start with the most general definition, which is
specialised as long as it covers some negative example. A program for <i
style='mso-bidi-font-style:normal'>top-down</i> induction is given in section
9.3. </span></p>

<h3 id="bottom_up_induction"><span lang=EN-US>9.2<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Bottom-up
induction</span></h3>

<p class=sektie1><span lang=EN-US>The induction program we will develop in this
section constructs </span><span lang=EN-US style='font-family:Symbol'>q</span><span
lang=EN-US>-LGG’s of two examples, relative to a partial model <i
style='mso-bidi-font-style:normal'>M</i> which consists of all positive
examples plus ground facts for the background predicate</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;background
predicate&quot; \b </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, of which the definitions are given beforehand. Such </span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG’s are
called <i style='mso-bidi-font-style:normal'>relative least general
generalisation</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relative least general
generalisation&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i
style='mso-bidi-font-style:normal'><span lang=EN-US>s</span></i><span
lang=EN-US> or RLGG’s. Typically, RLGG’s are quite big clauses, that contain
many redundant or otherwise useless literals, but also one or two useful
literals. For instance, suppose <i style='mso-bidi-font-style:normal'>M</i>
consists of the following positive examples for the predicate </span><span
lang=EN-US style='font-family:Courier'>append/3</span><span lang=EN-US>:</span></p>

<p class=p-el style='tab-stops:212.0pt'><span lang=EN-US>append([1,2],[3,4],[1,2,3,4])<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>append([a],[],[a])<br>
append([],[],[])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>append([2],[3,4],[2,3,4])</span></p>

<p class=tekst><span lang=EN-US>The RLGG of two examples <i style='mso-bidi-font-style:
normal'>E</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>1</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>and <i style='mso-bidi-font-style:normal'>E</i></span><span
lang=EN-US style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>2</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>relative to a model <i style='mso-bidi-font-style:
normal'>M</i> is defined as the </span><span lang=EN-US style='font-family:
Symbol'>q</span><span lang=EN-US>-LGG of the clauses <i style='mso-bidi-font-style:
normal'>E</i></span><span lang=EN-US style='font-size:9.0pt;position:relative;
top:2.0pt;mso-text-raise:-2.0pt'>1</span><span lang=EN-US style='font-family:
Courier'>:-</span><i style='mso-bidi-font-style:normal'><span lang=EN-US>Conj</span></i><span
lang=EN-US>(<i style='mso-bidi-font-style:normal'>M</i>) and <i
style='mso-bidi-font-style:normal'>E</i></span><span lang=EN-US
style='font-size:9.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt'>2</span><span
lang=EN-US style='font-family:Courier'>:-</span><i style='mso-bidi-font-style:
normal'><span lang=EN-US>Conj</span></i><span lang=EN-US>(<i style='mso-bidi-font-style:
normal'>M</i>), where <i style='mso-bidi-font-style:normal'>Conj</i>(<i
style='mso-bidi-font-style:normal'>M</i>) denotes the conjunction</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;conjunction&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the ground facts in <i
style='mso-bidi-font-style:normal'>M</i>. So, the RLGG of the first two
examples above is the </span><span lang=EN-US style='font-family:Symbol'>q</span><span
lang=EN-US>-LGG of the following two clauses:</span></p>

<p class=pi-el><span lang=EN-US>append([1,2],[3,4],[1,2,3,4]):-<br>
append([1,2],[3,4],[1,2,3,4]),append([a],[],[a]),<br>
append([],[],[]),append([2],[3,4],[2,3,4])</span></p>

<p class=pi-laatst><span lang=EN-US>append([a],[],[a]):-<br>
append([1,2],[3,4],[1,2,3,4]),append([a],[],[a]),<br>
append([],[],[]),append([2],[3,4],[2,3,4])</span></p>

<p class=tekst><span lang=EN-US>The body of the resulting clause consists of 16
literals, constructed by pairwise anti-unification of facts in <i
style='mso-bidi-font-style:normal'>M</i>:</span></p>

<p class=pi-el><span lang=EN-US>append([A|B],C,[A|D]):-<br>
append([1,2],[3,4],[1,2,3,4]),append([A|B],C,[A|D]),<br>
append(W,C,X),append([S|B],[3,4],[S,T,U|V]),<br>
append([R|G],K,[R|L]),append([a],[],[a]),<br>
append(Q,[],Q),append([P],K,[P|K]),append(N,K,O),<br>
append(M,[],M),append([],[],[]),append(G,K,L),<br>
append([F|G],[3,4],[F,H,I|J]),append([E],C,[E|C]),<br>
append(B,C,D),append([2],[3,4],[2,3,4])</span></p>

<p class=sektie><span lang=EN-US>Clearly, this clause contains many redundant
literals. First of all, removing the ground facts from <i style='mso-bidi-font-style:
normal'>M</i> does not change the logical meaning of the clause, since they are
known to be true. Furthermore, note that most literals introduce new variables,
that do not appear in the head of the clause</span><a style='mso-footnote-id:
ftn3' href="#_ftn3" name="_ftnref3" title=""><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span
style='mso-special-character:footnote'><![if !supportFootnotes]><span
class=MsoFootnoteReference><span lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:
Times;mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:
AR-SA'>[20]</span></span><![endif]></span></span></span></a><span lang=EN-US>.</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;existential
variable&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>For simplicity, we will
assume that this does not occur in the intended program, i.e. <i
style='mso-bidi-font-style:normal'>all variables in the body of a hypothesis
clause also occur in the head</i>. Such clauses are also called <i
style='mso-bidi-font-style:normal'>constrained</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;clause:<i
style='mso-bidi-font-style:normal'>constrained</i>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Under this assumption, the clause can be considerably reduced: </span></p>

<p class=pi-el><span lang=EN-US>append([A|B],C,[A|D]):-<br>
append([A|B],C,[A|D]),append(B,C,D),</span></p>

<p class=tekst><span lang=EN-US>Note that the first body literal turns the
clause into a <i style='mso-bidi-font-style:normal'>tautology</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tautology&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: a clause that is true by definition. We will exclude this literal
as well by assuming that hypothesis clauses are <b style='mso-bidi-font-weight:
normal'>strictly</b> constrained, i.e. the set of body variables is a <b
style='mso-bidi-font-weight:normal'>proper</b> subset of the set of head
variables (see Exercise 9.4 for a discussion of the kind of program excluded by
this restriction). Under this assumption, we arrive at the recursive clause for
</span><span lang=EN-US style='font-family:Courier'>append/3</span><span
lang=EN-US>:</span></p>

<p class=pi-el><span lang=EN-US>append([A|B],C,[A|D]):-<br>
append(B,C,D)</span></p>

<p class=tekst><span lang=EN-US>It is interesting to trace the literal </span><span
lang=EN-US style='font-family:Courier'>append(B,C,D)</span><span lang=EN-US>
back to its origin: it is the anti-unification</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;anti-unification&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of the facts </span><span
lang=EN-US style='font-family:Courier'>append([],[],[])</span><span lang=EN-US>
and </span><span lang=EN-US style='font-family:Courier'>append([2],[3,4],[2,3,4])</span><span
lang=EN-US>. These are exactly the ground bodies of the last clause, if we
unify its head with the two original examples! </span></p>

<p class=sektie><span lang=EN-US>The program for computing the RLGG</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;relative
least general generalisation:computation of&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>of two examples is given
below. It is a slight modification of the program for computing </span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-LGG’s, given in
the previous section. After the head of the clause is constructed, the
variables in the head are passed on to the predicate </span><span lang=EN-US
style='font-family:Courier'>rlgg_bodies/9</span><span lang=EN-US>, which will
only construct literals of which all the variables occur in the head. </span></p>

<p class=oms-eerst><span lang=EN-US>% rlgg(E1,E2,M,C) &lt;- C is RLGG of E1 and
E2 relative to M</span></p>

<p class=pi-laatst style='tab-stops:127.0pt'><span lang=EN-US>rlgg</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;rlgg/4&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(E1,E2,M,(H:-B)):-<br>
anti_unify(E1,E2,H,[],S10,[],S20),<br>
varsin(H,V),<span style='mso-tab-count:1'>&nbsp; </span>% determine variables
in head of clause<br>
rlgg_bodies(M,M,[],B,S10,S1,S20,S2,V).</span></p>

<p class=p-laatst><span lang=EN-US>% varsin</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;varsin/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(T,V) &lt;- V is list of variables occuring in term T<br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(standard predicate in many Prologs)</span></p>

<p class=pi><span lang=EN-US>rlgg_bodies([],B2,B,B,S1,S1,S2,S2,V).</span></p>

<p class=pi-laatst><span lang=EN-US>rlgg_bodies([L|B1],B2,B0,B,S10,S1,S20,S2,V):-<br>
rlgg_literal(L,B2,B0,B00,S10,S11,S20,S21,V),<br>
rlgg_bodies(B1,B2,B00,B,S11,S1,S21,S2,V).</span></p>

<p class=pi><span lang=EN-US>rlgg_literal(L1,[],B,B,S1,S1,S2,S2,V).</span></p>

<p class=pi style='page-break-after:auto'><span lang=EN-US>rlgg_literal(L1,[L2|B2],B0,B,S10,S1,S20,S2,V):-<br>
same_predicate(L1,L2),<br>
anti_unify(L1,L2,L,S10,S11,S20,S21),<br>
varsin(L,Vars),<br>
var_proper_subset(Vars,V),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
no new variables<br>
!,rlgg_literal(L1,B2,[L|B0],B,S11,S1,S21,S2,V).</span></p>

<p class=pi-laatst><span lang=EN-US>rlgg_literal(L1,[L2|B2],B0,B,S10,S1,S20,S2,V):-<br>
rlgg_literal(L1,B2,B0,B,S10,S1,S20,S2,V).</span></p>

<p class=pi-laatst><span lang=EN-US>%%% var_… uses == rather than unification
(Appendix A.2)</span></p>

<p class=tekst><span lang=EN-US>For simplicity, the body of the RLGG thus
constructed is a <b style='mso-bidi-font-weight:normal'>list</b> of literals
rather than a conjunction. </span></p>

<p class=sektie><span lang=EN-US>The main algorithm of the RLGG-program is
relatively simple: construct the RLGG of two positive examples, and remove all
positive examples that are extensionally covered by this clause. Such an
algorithm, which induces each clause separately, is also called a <i
style='mso-bidi-font-style:normal'>covering algorithm</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;covering algorithm&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Positive</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Positive
example&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>and negative example</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;negative
example&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, identified by a sign, are first separated by means of the
predicate </span><span lang=EN-US style='font-family:Courier'>pos_neg/3</span><span
lang=EN-US>, and the positive examples are combined with a (possibly empty) <a
name=bk0>background model for the background predicates, to yield the model to
be used for construction of RLGG’s .</a></span></p>

<p class=pi-el style='tab-stops:194.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>induce_rlgg</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induce_rlgg/2&quot;
</span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>(Exs,Clauses):-<br>
pos_neg(Exs,Poss,Negs),<span style='mso-tab-count:1'>&nbsp; </span>% split pos.
&amp; neg. examples<br>
bg_model(BG),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
ground background model<br>
append(Poss,BG,Model),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>% Model
includes pos.exs.<br>
induce_rlgg(Poss,Negs,Model,Clauses).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>induce_rlgg(Poss,Negs,Model,Clauses):-<br>
covering(Poss,Negs,Model,[],Clauses).</span></span></p>

<p class=oms><span style='mso-bookmark:bk0'><span lang=EN-US>% split positive
and negative examples</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>pos_neg([],[],[]).</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>pos_neg([+E|Exs],[E|Poss],Negs):-<br>
pos_neg(Exs,Poss,Negs).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>pos_neg([-E|Exs],Poss,[E|Negs]):-<br>
pos_neg(Exs,Poss,Negs).</span></span></p>

<p class=oms><span style='mso-bookmark:bk0'><span lang=EN-US>% covering
algorithm</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>covering</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;covering/2&quot;
</span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>(Poss,Negs,Model,H0,H):-<br>
construct_hypothesis(Poss,Negs,Model,Hyp),!,<br>
remove_pos(Poss,Model,Hyp,NewPoss),<br>
covering(NewPoss,Negs,Model,[Hyp|H0],H).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>covering(P,N,M,H0,H):-<br>
append(H0,P,H).<span style='mso-tab-count:1'> </span>% add uncovered examples
to hypothesis</span></span></p>

<p class=oms><span style='mso-bookmark:bk0'><span lang=EN-US>% remove covered
positive examples</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>remove_pos([],M,H,[]).</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>remove_pos([P|Ps],Model,Hyp,NewP):-<br>
covers_ex(Hyp,P,Model),!,<br>
write('Covered example: '),write(P),nl,<br>
remove_pos(Ps,Model,Hyp,NewP).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>remove_pos([P|Ps],Model,Hyp,[P|NewP]):-<br>
remove_pos(Ps,Model,Hyp,NewP).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>The two
predicates called by the covering algorithm are </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Courier'>construct_hypothesis/4</span><span
lang=EN-US> to construct a new clause, and </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Courier'>covers_ex/3</span><span
lang=EN-US> to check extensional coverage</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;extensional
coverage&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. </span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk0'><span lang=EN-US>%
extensional coverage, relative to a ground model</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>covers_ex</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;covers_ex/3&quot;
</span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>((Head:-Body),Example,Model):-<br>
try((Head=Example,<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>forall(element(L,Body),element(L,Model)))).</span></span></p>

<p class=oms><span style='mso-bookmark:bk0'><span lang=EN-US>% construct a
clause by means of RLGG</span></span></p>

<p class=pi><span style='mso-bookmark:bk0'><span lang=EN-US>construct_hypothesis([E1,E2|Es],Negs,Model,Clause):-<br>
write('RLGG of '),write(E1),<br>
write(' and '),write(E2),write(' is'),<br>
rlgg(E1,E2,Model,Cl),<br>
reduce(Cl,Negs,Model,Clause),!,<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
no backtracking<br>
nl,tab(5),write(Clause),nl.</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>construct_hypothesis([E1,E2|Es],Negs,Model,Clause):-<br>
write(' too general'),nl,<br>
construct_hypothesis([E2|Es],Negs,Model,Clause).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Courier'>try</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Courier;
display:none;mso-hide:all'> XE </span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;try/1&quot; </span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Courier'>(Goal)</span><span lang=EN-US> succeeds
if and only if </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Courier'>Goal</span><span lang=EN-US> succeeds, but without
instantiating variables in </span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Courier'>Goal</span><span lang=EN-US> (see
Appendix A.2). </span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>The remaining
predicate is </span></span><span style='mso-bookmark:bk0'><span lang=EN-US
style='font-family:Courier'>reduce/4</span><span lang=EN-US>. This predicate
first removes all the ground facts in the background model from the body</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;body
of a clause:reduction of&quot; </span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>of the clause. In a second step, the
clause is further generalised by removing as many literals as possible, as long
as the resulting clause does not cover any negative example (this is the only
point where negative examples are used). This is needed because an RLGG might
still contain redundant literals. For instance, given the following model</span></span></p>

<p class=p-el style='tab-stops:212.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>append([1,2],[3,4],[1,2,3,4])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>append([a],[],[a])<br>
append([],[],[])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>append([],[1,2,3],[1,2,3])<br>
append([2],[3,4],[2,3,4])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>append([],[3,4],[3,4])</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>the RLGG of the
first two facts is</span></span></p>

<p class=pi-el><span style='mso-bookmark:bk0'><span lang=EN-US>append([A|B],C,[A|E]):-<br>
append(B,C,D),append([],C,C)</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>This clause
contains the redundant literal</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;redundant
literal&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span></span></span><span style='mso-bookmark:
bk0'><span lang=EN-US style='font-family:Courier'>append([],C,C)</span><span
lang=EN-US>, which is true in the intended interpretation</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
interpretation&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. Therefore, removing it will not
change the meaning of the clause in the intended interpretation. </span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk0'><span lang=EN-US>% remove
redundant literals</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>reduce((H:-B0),Negs,M,(H:-B)):-<br>
setof0(L,(element(L,B0),not var_element(L,M)),B1),<br>
reduce_negs(H,B1,[],B,Negs,M).</span></span></p>

<p class=oms><span style='mso-bookmark:bk0'><span lang=EN-US>%
reduce_negs(H,B1,B0,B,N,M) &lt;- B is a subsequence of B1 <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>such that H:-B does not <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>cover elements of N</span></span></p>

<p class=pi style='tab-stops:273.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>reduce_negs(H,[L|B0],In,B,Negs,M):-<br>
append(In,B0,Body),<br>
not covers_neg((H:-Body),Negs,M,N),!,<span style='mso-tab-count:1'> </span>%
remove L<br>
reduce_negs(H,B0,In,B,Negs,M).</span></span></p>

<p class=pi style='tab-stops:273.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>reduce_negs(H,[L|B0],In,B,Negs,M):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
keep L<br>
reduce_negs(H,B0,[L|In],B,Negs,M).</span></span></p>

<p class=pi-laatst style='tab-stops:273.0pt'><span style='mso-bookmark:bk0'><span
lang=EN-US>reduce_negs(H,[],Body,Body,Negs,M):-<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
fail if clause <br>
not covers_neg((H:-Body),Negs,M,N).<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
covers neg.ex.</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>covers_neg(Clause,Negs,Model,N):-<br>
element(N,Negs),<br>
covers_ex(Clause,N,Model).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk0'><span lang=EN-US>%%%
var_element/2: see Appendix A.2</span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>We illustrate
the program by applying it to two induction problems, one without and one with
additional background predicate</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;background
predicate&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>s. The first example is the familiar </span></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='font-family:Courier'>append/3</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span></span><span style='mso-bookmark:bk0'><span lang=EN-US style='font-family:
Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;append/3</span><span
lang=EN-US>:induction of</span></span><span style='mso-bookmark:bk0'><span
lang=EN-US style='font-family:Courier'>&quot; </span></span><![endif]--><span
style='mso-bookmark:bk0'></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>predicate. </span></span></p>

<p class=p-el style='page-break-after:avoid'><span style='mso-bookmark:bk0'><span
lang=EN-US>bg_model([]).</span></span></p>

<p class=programma style='margin-left:117.0pt;text-indent:-100.0pt;page-break-after:
auto;tab-stops:239.0pt'><span style='mso-bookmark:bk0'><span lang=EN-US>?-induce_rlgg([<span
style='mso-tab-count:1'>&nbsp; </span>+append([1,2],[3,4],[1,2,3,4]),<br>
+append([a],[],[a]),<br>
+append([],[],[]),<br>
+append([],[1,2,3],[1,2,3]),<br>
+append([2],[3,4],[2,3,4]),<br>
+append([],[3,4],[3,4]),<br>
-append([a],[b],[b]),<br>
-append([c],[b],[c,a]),<br>
-append([1,2],[],[1,3])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>],Clauses).</span></span></p>

<p class=p-eerst style='page-break-after:auto'><span style='mso-bookmark:bk0'><span
lang=EN-US>RLGG of append([1,2],[3,4],[1,2,3,4]) and append([a],[],[a]) is<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>append([X|Xs],Ys,[X|Zs]):-[append(Xs,Ys,Zs)]<br>
Covered example: append([1,2],[3,4],[1,2,3,4])<br>
Covered example: append([a],[],[a])<br>
Covered example: append([2],[3,4],[2,3,4])</span></span></p>

<p class=programma style='page-break-after:auto'><span style='mso-bookmark:
bk0'><span lang=EN-US>RLGG of append([],[],[]) and append([],[1,2,3],[1,2,3])
is<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>append([],Y,Y):-[]<br>
Covered example: append([],[],[])<br>
Covered example: append([],[1,2,3],[1,2,3])<br>
Covered example: append([],[3,4],[3,4])</span></span></p>

<p class=p-el><span style='mso-bookmark:bk0'><span lang=EN-US>Clauses =
[(append([],Y,Y):-[]),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(append([X|Xs],Ys,[X|Zs]):-[append(Xs,Ys,Zs)])]</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>Note that,
because of the use of extensional coverage, we have to provide complete
‘recursive chains</span></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;recursive
chains&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>’ like</span></span></p>

<p class=p-el><span style='mso-bookmark:bk0'><span lang=EN-US>append([1,2],[3,4],[1,2,3,4])<br>
append([2],[3,4],[2,3,4])<br>
append([],[3,4],[3,4])</span></span></p>

<p class=tekst><span style='mso-bookmark:bk0'><span lang=EN-US>Note also that
the recursive clause is induced before the non-recursive one. This is due to
the order in which the examples are presented; of course, it is only possible
if we apply extensional coverage</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;extensional
coverage&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>rather than intensional coverage</span></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intensional
coverage&quot; </span></span><![endif]--><span style='mso-bookmark:bk0'></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk0'><span lang=EN-US>. </span></span></p>

<p class=sektie><span style='mso-bookmark:bk0'><span lang=EN-US>The second
example concerns the use of a non-empty background model</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;background
model&quot; \r &quot;bk0&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. The background predicate </span><span lang=EN-US style='font-family:
Courier'>num/2</span><span lang=EN-US> converts the numbers 1…5 to the numerals
one…five and vice versa; the predicate </span><span lang=EN-US
style='font-family:Courier'>listnum/2</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;listnum/2</span><span lang=EN-US>:induction
of</span><span lang=EN-US style='font-family:Courier'>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, which does the same for lists of numbers and numerals, is to be
induced. </span></p>

<p class=p-el style='margin-left:89.0pt;text-indent:-72.0pt'><span lang=EN-US>bg_model([<span
style='mso-tab-count:1'>&nbsp; </span>num(1,one),<br>
num(2,two),<br>
num(3,three),<br>
num(4,four),<br>
num(5,five)<span style='mso-tab-count:1'>&nbsp; </span>]).</span></p>

<p class=programma style='margin-left:117.0pt;text-indent:-100.0pt;page-break-after:
auto;tab-stops:239.0pt'><span lang=EN-US>?-induce_rlgg([<span style='mso-tab-count:
1'>&nbsp; </span>+listnum([],[]),<br>
+listnum([2,three,4],[two,3,four]),<br>
+listnum([4],[four]),<br>
+listnum([three,4],[3,four]),<br>
+listnum([two],[2]),<br>
-listnum([1,4],[1,four]),<br>
-listnum([2,three,4],[two]),<br>
-listnum([five],[5,5])<span style='mso-tab-count:1'> </span>],Clauses).</span></p>

<p class=p-eerst style='page-break-after:auto'><span lang=EN-US>RLGG of
listnum([],[]) and listnum([2,three,4],[two,3,four]) is <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>too general</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>RLGG of
listnum([2,three,4],[two,3,four]) and listnum([4],[four]) is <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>listnum([X|Xs],[Y|Ys]):-[num(X,Y),listnum(Xs,Ys)]<br>
Covered example: listnum([2,three,4],[two,3,four])<br>
Covered example: listnum([4],[four])</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>RLGG of
listnum([],[]) and listnum([three,4],[3,four]) is <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>too general</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>RLGG of
listnum([three,4],[3,four]) and listnum([two],[2]) is<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;
</span>listnum([V|Vs],[W|Ws]):-[num(W,V),listnum(Vs,Ws)]<br>
Covered example: listnum([three,4],[3,four])<br>
Covered example: listnum([two],[2])</span></p>

<p class=p-el><span lang=EN-US>Clauses = <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span>[
(listnum([V|Vs],[W|Ws]):-[num(W,V),listnum(Vs,Ws)]),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(listnum([X|Xs],[Y|Ys]):-[num(X,Y),listnum(Xs,Ys)]),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>listnum([],[]) ]</span></p>

<p class=tekst><span lang=EN-US>The RLGG of the first two examples is </span><span
lang=EN-US style='font-family:Courier'>listnum(X,Y):-[]</span><span lang=EN-US>,
which is too general since it covers the negative examples. Therefore, the
first example is temporarily discarded. After construction of the first clause,
it is tried again, without success. Finally, since all examples except the
first are covered by the two clauses found, the first example is simply added
to the hypothesis as a ground fact. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
9.4</span></i><span lang=EN-US>. The restriction that the head of a hypothesis
clause contains at least one variable that does not occur in the body excludes
many useful programs with accumulator</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;accumulator&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>s, like </span><span lang=EN-US style='font-family:Courier'>reverse/3</span><span
lang=EN-US> (section 3.6). Choose another method to exclude tautological
clauses, and demonstrate that your program can learn </span><span lang=EN-US
style='font-family:Courier'>reverse/3</span><!--[if supportFields]><span
lang=EN-US style='font-family:Courier;display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span lang=EN-US
style='font-family:Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;reverse/3&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='font-family:
Courier;display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. </span></p>

</div>

<h3 id="top_down_induction"><span lang=EN-US>9.3<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>Top-down
induction</span></h3>

<p class=sektie1><span lang=EN-US>We introduce the second induction method by
means of an example. Suppose we want to construct a definition of the predicate
</span><span lang=EN-US style='font-family:Courier'>element/2</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;element/2</span><span lang=EN-US>:induction
of</span><span lang=EN-US style='font-family:Courier'>&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>by means of induction.
After receiving the first example </span><span lang=EN-US style='font-family:
Courier'>+element(a,[a,b])</span><span lang=EN-US>, we formulate the simplest
hypothesis possible:</span></p>

<p class=p-el><span lang=EN-US>element(X,Y)</span></p>

<p class=tekst><span lang=EN-US>This hypothesis states that everything is an
element of everything. Suppose our next example is a negative one: </span><span
lang=EN-US style='font-family:Courier'>-element(x,[a,b])</span><span
lang=EN-US>. Since this negative example is covered by our current hypothesis,
we conclude that it is too general and has to be specialised. Under </span><span
lang=EN-US style='font-family:Symbol'>q</span><span lang=EN-US>-subsumption,
there are two ways to specialise a clause: </span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation:of a clause&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>i</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>apply a substitution to
variables in the clause;</span></p>

<p class=opsomming><span lang=EN-US>(<i style='mso-bidi-font-style:normal'>ii</i>)<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>add a literal to the body of the
clause.</span></p>

<p class=tekst><span lang=EN-US>We can thus specialise our hypothesis in
several ways: we can apply substitutions like {</span><span lang=EN-US
style='font-family:Courier'>X</span><span lang=EN-US style='font-family:Symbol'>®</span><span
lang=EN-US style='font-family:Courier'>[]</span><span lang=EN-US>}, {</span><span
lang=EN-US style='font-family:Courier'>Y</span><span lang=EN-US
style='font-family:Symbol'>®</span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US>} or {</span><span lang=EN-US style='font-family:Courier'>Y</span><span
lang=EN-US style='font-family:Symbol'>®</span><span lang=EN-US
style='font-family:Courier'>[V|W]</span><span lang=EN-US>}, or we can add a
literal like </span><span lang=EN-US style='font-family:Courier'>element(Y,X)</span><span
lang=EN-US> to the body of the clause. So, the set of specialisations of the
above clause includes, among others, the following clauses:</span></p>

<p class=p-el><span lang=EN-US>element([],Y)<br>
element(X,X)<br>
element(X,[V|W])<br>
element(X,Y):-element(Y,X)</span></p>

<p class=tekst><span lang=EN-US>Note that each of these clauses is a <i
style='mso-bidi-font-style:normal'>minimal</i> specialisation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation:minimal&quot;
\b </span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, in the following sense: each of them is </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumed by the original clause,
and there exist no more-general clauses which are also </span><span lang=EN-US
style='font-family:Symbol'>q</span><span lang=EN-US>-subsumed by the original
clause. </span></p>

<p class=sektie><span lang=EN-US>Suppose for the moment that we choose the
third clause as our next hypothesis:</span></p>

<p class=p-el><span lang=EN-US>element(X,[V|W])</span></p>

<p class=tekst><span lang=EN-US>This hypothesis expresses that anything is an
element of a non-empty list. Obviously, this clause is again too general, since
it still covers the negative example. Possible minimal specialisations include</span></p>

<p class=p-el><span lang=EN-US>element(X,[V])<br>
element(X,[X|W])<br>
element(X,[V|X])<br>
element(X,[V|W]):-element(X,W)</span></p>

<p class=tekst><span lang=EN-US>The second of these clauses is true in the
intended interpretation</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
interpretation&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, and will therefore never cover any negative example. Since it also
covers the only positive example seen up till now, we decide to adopt it as our
next hypothesis. Notice that the recursive clause is also among the above
specialisations; it will be found if we supply a positive example like </span><span
lang=EN-US style='font-family:Courier'>+element(b,[a,b])</span><span
lang=EN-US>. </span></p>

<p class=sektie><span lang=EN-US>Thus, we see that the operation of
specialisation generates a search space</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search
space:for top-down induction&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in which the correct
clauses defining </span><span lang=EN-US style='font-family:Courier'>element/2</span><span
lang=EN-US> are to be found. Part of this search space, which we will call the <i
style='mso-bidi-font-style:normal'>specialisation graph</i></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation graph&quot; \b </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, is depicted in fig. 9.1. Notice that, in order to generate the
specialisation graph, we need to specify the <i style='mso-bidi-font-style:
normal'>hypothesis language</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:<i
style='mso-bidi-font-style:normal'>hypothesis language</i>&quot; \b </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: the set of predicates, functors and constants that can occur in
the hypothesis. We can further restrict the search space by assigning <i
style='mso-bidi-font-style:normal'>types</i> to the arguments of predicates and
functors.</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;variable:type&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>For instance, by
assigning </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>Y</span><span
lang=EN-US> in </span><span lang=EN-US style='font-family:Courier'>element(X,Y)</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>[X|Y]</span><span
lang=EN-US> the types ‘item’ and ‘list of items’, respectively, it becomes
clear that </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> and </span><span lang=EN-US style='font-family:Courier'>Y</span><span
lang=EN-US> should not be unified in a specialisation step, and neither should </span><span
lang=EN-US style='font-family:Courier'>X</span><span lang=EN-US> be substituted
by </span><span lang=EN-US style='font-family:Courier'>[]</span><span
lang=EN-US> or </span><span lang=EN-US style='font-family:Courier'>[V|W]</span><span
lang=EN-US>. Such typing would rule out three clauses in fig. 9.1. </span></p>

<div style='mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly'>

<table cellspacing=0 cellpadding=0 hspace=0 vspace=0 align=center>
 <tr>
  <td valign=top align=left style='padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt'>
  <div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm'>
  <p class=figure><span lang=EN-US style='mso-no-proof:yes'><!--[if gte vml 1]><v:shape
   id="Picture_x0020_7" o:spid="_x0000_i1025" type="#_x0000_t75" style='width:355pt;
   height:122pt;visibility:visible;mso-wrap-style:square'>
   <v:imagedata src="Part%20III_files/image013.emz" o:title=""/>
  </v:shape><![endif]--><![if !vml]><img width=357 height=124
  src="Part%20III_files/image014.png" v:shapes="Picture_x0020_7"><![endif]></span></p>
  </div>
  <p class=Caption1><b style='mso-bidi-font-weight:normal'><span lang=EN-US>Figure
  9.1.</span></b><span lang=EN-US> Part of the specialisation graph for </span><span
  lang=EN-US style='font-family:Courier'>element/2</span><span lang=EN-US>.</span></p>
  </td>
 </tr>
</table>

</div>

<p class=sektie><span lang=EN-US>Even with such typing restrictions, the
branching factor</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;branching
factor&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>in the specialisation
graph is typically quite large, increasing with the number of variables in a
clause. Therefore, an agenda-based search procedure will require large amounts
of memory. Instead, we will employ an iterative deepening</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;iterative
deepening&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>search strategy with
backtracking</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. Each time a clause in the hypothesis is found to be too general,
we search the specialisation graph for an alternative, starting from the root
and increasing the depth bound until a suitable clause is found. Identifying
and removing the too-general clause is a specialisation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation:by
removing a clause&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>operation; searching for
an alternative and adding it to the hypothesis is a generalisation</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;generalisation:by
adding a clause&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>step. </span></p>

<p class=sektie><span lang=EN-US>The program below implements this top-down</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:top-down&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>induction procedure. Its
main loop is given by the predicate </span><span lang=EN-US style='font-family:
Courier'>process_examples/4</span><span lang=EN-US>. This predicate processes
the examples one by one. Whenever the hypothesis is changed by generalisation
or specialisation, the new hypothesis should be checked against all previous
examples, which are therefore passed in the list </span><span lang=EN-US
style='font-family:Courier'>Done</span><span lang=EN-US>. </span></p>

<p class=pi-el><span lang=EN-US>induce_spec</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induce_spec/2&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>(Examples,Clauses):-<br>
process_examples([],[],Examples,Clauses).</span></p>

<p class=oms><span lang=EN-US>% process the examples</span></p>

<p class=pi><span lang=EN-US>process_examples(Clauses,Done,[],Clauses).</span></p>

<p class=pi-laatst><span lang=EN-US>process_examples(Cls1,Done,[Ex|Exs],Clauses):-<br>
process_example(Cls1,Done,Ex,Cls2),<br>
process_examples(Cls2,[Ex|Done],Exs,Clauses).</span></p>

<p class=oms><span lang=EN-US>% process one example</span></p>

<p class=pi><span lang=EN-US>process_example(Clauses,Done,+Example,Clauses):-<br>
covers_d(Clauses,Example).</span></p>

<p class=pi><span lang=EN-US>process_example(Cls,Done,+Example,Clauses):-<br>
not covers_d(Cls,Example),<br>
generalise(Cls,Done,Example,Clauses).</span></p>

<p class=pi><span lang=EN-US>process_example(Cls,Done,-Example,Clauses):-<br>
covers_d(Cls,Example),<br>
specialise(Cls,Done,Example,Clauses).</span></p>

<p class=pi-laatst><span lang=EN-US>process_example(Clauses,Done,-Example,Clauses):-<br>
not covers_d(Clauses,Example).</span></p>

<p class=sektie><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter:for intensional
coverage&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>Intensional coverage of an example by a set of clauses is checked by
a simple meta-interpreter. Since the current hypothesis might include circular</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;clause:circular&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>clauses like </span><span
lang=EN-US style='font-family:Courier'>element(X,Y):-element(Y,X)</span><span
lang=EN-US>, the meta-interpreter employs a depth bound</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;depth
bound&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>to cut off the search
for a proof after a fixed number of steps. Additionally, a <a name=bk2>background
theory might be defined by means of the meta-predicate</a></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;meta-predicate&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span></span></span><span style='mso-bookmark:
bk2'><span lang=EN-US style='font-family:Courier'>bg/1</span><span lang=EN-US>;
we will assume that this background theory is non-circular, and does not
contain the predicate to be induced. </span></span><span style='mso-bookmark:
bk2'><span lang=EN-US style='font-family:Courier'><o:p></o:p></span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk2'><span lang=EN-US>%
covers_d(Clauses,Ex) &lt;- Ex can be proved from Clauses and <br>
%<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp; </span><span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>background
theory (max. 10 steps)</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk2'><span lang=EN-US>covers_d</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;covers_d/2&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(Clauses,Example):-<br>
prove_d(10,Clauses,Example).</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>prove_d</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_d/3&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(D,Cls,true):-!.</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>prove_d(D,Cls,(A,B)):-!,<br>
prove_d(D,Cls,A),<br>
prove_d(D,Cls,B).</span></span></p>

<p class=pi style='tab-stops:226.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>prove_d(D,Cls,A):-<br>
D&gt;0,D1 is D-1,<br>
copy_element((A:-B),Cls),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>%
make copy of clause<br>
prove_d(D1,Cls,B).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk2'><span lang=EN-US>prove_d(D,Cls,A):-<br>
prove_bg(A).</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>prove_bg</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;prove_bg/1&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(true):-!.</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>prove_bg((A,B)):-!,<br>
prove_bg(A),<br>
prove_bg(B).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk2'><span lang=EN-US>prove_bg(A):-<br>
bg((A:-B)),<br>
prove_bg(B).</span></span></p>

<p class=pi-laatst style='tab-stops:216.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>%%% copy_element/2: see Appendix A.2</span></span></p>

<p class=sektie><span style='mso-bookmark:bk2'><span lang=EN-US>If the current
hypothesis covers a negative example, it follows that it contains at least one
clause which is false in the intended interpretation</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;intended
interpretation&quot; </span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>. The predicate </span></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='font-family:Courier'>specialise/4</span><span
lang=EN-US> identifies such a false clause by examining the proof of the
negative example. Once such a clause is found, it is simply thrown out of the
hypothesis. Since this is quite a coarse specialisation</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation:by
removing a clause&quot; </span></span><![endif]--><span style='mso-bookmark:
bk2'></span><!--[if supportFields]><span style='mso-bookmark:bk2'></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>step, some of
the previous positive examples will now become uncovered, and the predicate </span></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='font-family:Courier'>process_examples/4</span><span
lang=EN-US> is called again. </span></span></p>

<p class=pi-el><span style='mso-bookmark:bk2'><span lang=EN-US>specialise</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialise/4&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(Cls,Done,Example,Clauses):-<br>
false_clause(Cls,Done,Example,C),<br>
remove_one(C,Cls,Cls1),<br>
write('.....refuted: '),write(C),nl,<br>
process_examples(Cls1,[],[-Example|Done],Clauses).</span></span></p>

<p class=oms><span style='mso-bookmark:bk2'><span lang=EN-US>%
false_clause(Cs,Exs,E,C) &lt;- C is a false clause <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>in the proof of E</span></span></p>

<p class=pi style='page-break-after:auto;tab-stops:226.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>false_clause(Cls,Exs,true,ok):-!.<span
style='mso-tab-count:1'>&nbsp; </span>% empty proof</span></span></p>

<p class=pi style='page-break-after:auto;tab-stops:123.0pt 226.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>false_clause(Cls,Exs,(A,B),X):-!,<br>
false_clause(Cls,Exs,A,Xa),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
try first conjunct<br>
( Xa = ok<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>-&gt;
false_clause(Cls,Exs,B,X)<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
2nd one<br>
; otherwise<span style='mso-tab-count:1'>&nbsp; </span>-&gt; X = Xa<br>
).</span></span></p>

<p class=pi style='page-break-after:auto;tab-stops:123.0pt 212.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>false_clause(Cls,Exs,E,ok):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>% no false clause for <br>
element(+E,Exs),!.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
positive examples</span></span></p>

<p class=pi style='page-break-after:auto;tab-stops:123.0pt 212.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>false_clause(Cls,Exs,A,ok):-<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp; </span>% no false clause for <br>
bg((A:-B)),!.<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
background literals</span></span></p>

<p class=pi-laatst style='tab-stops:123.0pt 212.0pt'><span style='mso-bookmark:
bk2'><span lang=EN-US>false_clause(Cls,Exs,A,X):-<br>
copy_element((A:-B),Cls),<br>
false_clause(Cls,Exs,B,Xb),<span style='mso-tab-count:1'> </span>% false clause
in proof B?<br>
( Xb \= ok<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>-&gt; X = Xb<span
style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>% yes<br>
; otherwise<span style='mso-tab-count:1'>&nbsp; </span>-&gt; X = (A:-B)<span
style='mso-tab-count:1'>&nbsp; </span>% no; return this clause<br>
).</span></span></p>

<p class=sektie><span style='mso-bookmark:bk2'><span lang=EN-US>As explained
above, the predicate </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>generalise/4</span><span lang=EN-US>
searches the specialisation graph for a clause covering an uncovered positive
example. Since there might be several uncovered positive examples, the
generalised hypothesis is again tested against all previous examples. </span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;generalisation:by adding a clause&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'></span></p>

<p class=pi-el><span style='mso-bookmark:bk2'><span lang=EN-US>generalise</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;generalise/4&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(Cls,Done,Example,Clauses):-<br>
search_clause(Done,Example,Cl),<br>
write('Found clause: '),write(Cl),nl,<br>
process_examples([Cl|Cls],[],[+Example|Done],Clauses).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>The current node
in the search process is represented by a term </span></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='font-family:Courier'>a(Clause,Vars)</span><span
lang=EN-US>, where </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>Vars</span><span lang=EN-US> is the list
of variables occurring in </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>Clause</span><span lang=EN-US>, together
with their types (see below). </span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk2'><span lang=EN-US>%
search_clause(Exs,E,C) &lt;- C is a clause covering E and <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>not covering negative examples<br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(iterative deepening search)</span></span></p>

<p class=pi-laatst style='tab-stops:181.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>search_clause</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;search_clause/3&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>(Exs,Example,Clause):-<br>
literal(Head,Vars),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
root of specialisation graph<br>
try((Head=Example)),<br>
search_clause(3,a((Head:-true),Vars),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Exs,Example,Clause).</span></span></p>

<p class=pi style='tab-stops:219.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>search_clause(D,Current,Exs,Example,Clause):-<br>
write(D),write('..'),<br>
search_clause_d(D,Current,Exs,Example,Clause),!.</span></span></p>

<p class=pi-laatst style='tab-stops:219.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>search_clause(D,Current,Exs,Example,Clause):-<br>
D1 is D+1,<br>
!,search_clause(D1,Current,Exs,Example,Clause).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>The search ends
when a clause is found that covers the uncovered example, while not covering
any of the negative examples. </span></span></p>

<p class=pi-eerst style='tab-stops:250.0pt'><span style='mso-bookmark:bk2'><span
lang=EN-US>search_clause_d(D,a(Clause,Vars),Exs,Example,Clause):-<br>
covers_ex(Clause,Example,Exs),<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>%
goal<br>
not((element(-N,Exs),covers_ex(Clause,N,Exs))),!.</span></span></p>

<p class=pi-laatst style='tab-stops:250.0pt 260.0pt'><span style='mso-bookmark:
bk2'><span lang=EN-US>search_clause_d(D,Current,Exs,Example,Clause):-<br>
D&gt;0,D1 is D-1,<br>
specialise_clause(Current,Spec),<span style='mso-tab-count:1'>&nbsp; </span>%
specialise<br>
search_clause_d(D1,Spec,Exs,Example,Clause).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>Here,
extensional coverage</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;extensional
coverage&quot; </span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>is tested against the examples and the
background theory: </span></span></p>

<p class=pi-el><span style='mso-bookmark:bk2'><span lang=EN-US>covers_ex</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;covers_ex/3&quot;
</span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>((Head:-Body),Example,Exs):-<br>
try((Head=Example,covers_ex(Body,Exs))).</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>covers_ex(true,Exs):-!.</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>covers_ex((A,B),Exs):-!,<br>
covers_ex(A,Exs),<br>
covers_ex(B,Exs).</span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span lang=EN-US>covers_ex(A,Exs):-<br>
element(+A,Exs).</span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk2'><span lang=EN-US>covers_ex(A,Exs):-<br>
prove_bg(A).</span></span></p>

<p class=sektie><span style='mso-bookmark:bk2'><span lang=EN-US>The following
predicates generate the specialisation graph</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialisation
graph:generation of&quot; </span></span><![endif]--><span style='mso-bookmark:
bk2'></span><!--[if supportFields]><span style='mso-bookmark:bk2'></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span lang=EN-US>. The literals that can be added to the body of a clause
are given by the predicate </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>literal/2</span><span lang=EN-US>. The
first argument of </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>literal/2</span><span lang=EN-US> is a
literal; the second argument specifies the types of variables in the literal.
Thus, for the predicate </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>element/2</span><span lang=EN-US> the
following fact should be added: <a name=bk1></a></span></span></p>

<p class=p-el><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>literal(element(X,Y),[item(X),list(Y)]).</span></span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>Likewise, the possible terms to be used in a substitution are
specified with their types by the predicate </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>term/2</span><span lang=EN-US>:</span></span></span></p>

<p class=p-el><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>term(list([]),[]).<br>
term(list([X|Y]),[item(X),list(Y)]).</span></span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>For instance, the clause </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>element(X,[V|W]):-true</span><span lang=EN-US> is
represented during the search process as </span></span></span></p>

<p class=p-el><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>a((element(X,[V|W]):-true),[item(X),item(V),list(W)])</span></span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>Consequently, </span></span></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> and </span></span></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='font-family:Courier'>V</span><span
lang=EN-US> can be unified with each other but not with </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>W</span><span lang=EN-US>, and </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>W</span><span lang=EN-US> can be substituted by </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>[]</span><span lang=EN-US> or </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>[Y|Z]</span><span lang=EN-US>, but </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>X</span><span lang=EN-US> and </span></span></span><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span lang=EN-US
style='font-family:Courier'>V</span><span lang=EN-US> cannot. To restrict the
search further, we will again make the assumption that hypothesis clauses are
strictly constrained; i.e. the set of variables in a newly added literal is a
proper subset of the set of variables in the head of the clause. </span></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>XE<span style="mso-spacerun:yes">&nbsp;
</span>&quot;clause:constrained\; i.e. the set of variables in a newly added
literal is a proper subset of the set of variables in the head of the clause. &quot;
</span></span></span><![endif]--><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span style='mso-bookmark:bk1'></span></span></p>

<p class=oms-eerst><span style='mso-bookmark:bk2'><span style='mso-bookmark:
bk1'><span lang=EN-US>% specialise_clause(C,S) &lt;- S is minimal
specialisation <br>
%<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>of C under theta-subsumption</span></span></span></p>

<p class=pi><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>specialise_clause</span></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;specialise_clause/2&quot;
</span></span></span><![endif]--><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span style='mso-bookmark:bk1'><span lang=EN-US>(Current,Spec):-<br>
add_literal(Current,Spec).</span></span></span></p>

<p class=pi-laatst><span style='mso-bookmark:bk2'><span style='mso-bookmark:
bk1'><span lang=EN-US>specialise_clause(Current,Spec):-<br>
apply_subs(Current,Spec).</span></span></span></p>

<p class=pi style='tab-stops:215.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>add_literal(a((H:-true),Vars),a((H:-L),Vars)):-!,<br>
literal(L,LVars),<br>
proper_subset(LVars,Vars).<span style='mso-tab-count:1'>&nbsp; </span>% no new
variables in L</span></span></span></p>

<p class=pi-laatst style='tab-stops:215.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>add_literal(a((H:-B),Vars),a((H:-L,B),Vars)):-<br>
literal(L,LVars),<br>
proper_subset(LVars,Vars).<span style='mso-tab-count:1'>&nbsp; </span>% no new
variables in L</span></span></span></p>

<p class=pi-laatst style='tab-stops:282.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>apply_subs(a(Clause,Vars),a(Spec,SVars)):-<br>
copy_term(a(Clause,Vars),a(Spec,Vs)),<span style='mso-tab-count:1'>&nbsp;&nbsp; </span>%
don’t change <br>
apply_subs1(Vs,SVars).<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>%
Clause</span></span></span></p>

<p class=pi style='tab-stops:191.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>apply_subs1(Vars,SVars):-<br>
unify_two(Vars,SVars).<span style='mso-tab-count:1'>&nbsp; </span>% unify two
variables</span></span></span></p>

<p class=pi-laatst style='tab-stops:191.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>apply_subs1(Vars,SVars):-<br>
subs_term(Vars,SVars).<span style='mso-tab-count:1'>&nbsp; </span>% subs. term
for variable</span></span></span></p>

<p class=pi style='tab-stops:191.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>unify_two([X|Vars],Vars):-<span
style='mso-tab-count:1'>&nbsp;&nbsp; </span>% not both X and Y in Vars<br>
element(Y,Vars),<br>
X=Y.</span></span></span></p>

<p class=pi-laatst style='tab-stops:215.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>unify_two([X|Vars],[X|SVars]):-<br>
unify_two(Vars,SVars).</span></span></span></p>

<p class=pi-laatst style='tab-stops:191.0pt'><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US>subs_term(Vars,SVars):-<br>
remove_one(X,Vars,Vs),<br>
term(Term,TVars),<br>
X=Term,<br>
append(Vs,TVars,SVars).<span style='mso-tab-count:1'> </span>% TVars instead of
X in Vars</span></span></span></p>

<p class=sektie><span style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'><span
lang=EN-US>We illustrate the program by applying it to the induction problems
of the previous section. The first problem is to induce a definition of the
predicate </span></span></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='font-family:Courier'>append/3</span></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span></span></span><span style='mso-bookmark:bk2'><span style='mso-bookmark:
bk1'><span lang=EN-US style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;append/3</span><span lang=EN-US>:induction
of</span></span></span><span style='mso-bookmark:bk2'><span style='mso-bookmark:
bk1'><span lang=EN-US style='font-family:Courier'>&quot; </span></span></span><![endif]--><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span style='mso-bookmark:bk1'><span lang=EN-US>. The hypothesis language</span></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:hypothesis
language&quot; </span></span></span><![endif]--><span style='mso-bookmark:bk2'><span
style='mso-bookmark:bk1'></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'><span style='mso-bookmark:bk1'></span></span><span
style='mso-element:field-end'></span><![endif]--><span style='mso-bookmark:
bk2'><span style='mso-bookmark:bk1'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>is specified by the literals and terms to
be used, together with the types of their arguments: </span></span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable:type&quot; \r
&quot;bk1&quot; </span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'></span></p>

<p class=p-el><span style='mso-bookmark:bk2'><span lang=EN-US>literal(append(X,Y,Z),[list(X),list(Y),list(Z)]).<br>
term(list([]),[]).<br>
term(list([X|Y]),[item(X),list(Y)]).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>The following
query demonstrates that </span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>append/3</span><span lang=EN-US> can be
induced from two positive and four negative examples: </span></span></p>

<p class=programma style='margin-top:6.0pt;margin-right:0cm;margin-bottom:0cm;
margin-left:116.0pt;margin-bottom:.0001pt;text-indent:-99.0pt;tab-stops:297.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>?-induce_spec([<span
style='mso-tab-count:1'>&nbsp; </span>+append([],[b,c],[b,c]),<br>
-append([],[a,b],[c,d]),<br>
-append([a,b],[c,d],[c,d]),<br>
-append([a],[b,c],[d,b,c]),<br>
-append([a],[b,c],[a,d,e]),<br>
+append([a],[b,c],[a,b,c])<span style='mso-tab-count:1'>&nbsp;&nbsp;&nbsp; </span>],Clauses)</span></span></p>

<p class=p-eerst><span style='mso-bookmark:bk2'><span lang=EN-US>3..Found
clause: append(X,Y,Z):-true<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>...refuted:
append([],[a,b],[c,d]):-true</span></span></p>

<p class=programma><span style='mso-bookmark:bk2'><span lang=EN-US>3..Found
clause: append(X,Y,Y):-true<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>...refuted:
append([a,b],[c,d],[c,d]):-true</span></span></p>

<p class=programma><span style='mso-bookmark:bk2'><span lang=EN-US>3..Found
clause: append([],Y,Y):-true</span></span></p>

<p class=programma style='margin-left:255.0pt;text-indent:-238.0pt'><span
style='mso-bookmark:bk2'><span lang=EN-US>3..4..Found clause:
append([X|Xs],Ys,[X|Zs]):-append(Xs,Ys,Zs)</span></span></p>

<p class=p-el style='page-break-after:avoid'><span style='mso-bookmark:bk2'><span
lang=EN-US>Clauses = [ (append([X|Xs],Ys,[X|Zs]):-append(Xs,Ys,Zs)),<br>
<span
style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(append([],Y,Y):-true) ]</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>The numbers
indicate the level of iterative deepening</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;iterative
deepening&quot; </span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>at which the clauses are found. The first
two negative examples are needed for the construction of the non-recursive
clause, and the remaining two are needed for the construction of the recursive
clause. </span></span></p>

<p class=sektie><span style='mso-bookmark:bk2'><span lang=EN-US>The second
induction problem concerns the predicate </span></span><span style='mso-bookmark:
bk2'><span lang=EN-US style='font-family:Courier'>listnum/2</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span></span><span style='mso-bookmark:bk2'><span lang=EN-US style='font-family:
Courier'><span style="mso-spacerun:yes">&nbsp;</span>&quot;listnum/2</span><span
lang=EN-US>:induction of</span></span><span style='mso-bookmark:bk2'><span
lang=EN-US style='font-family:Courier'>&quot; </span></span><![endif]--><span
style='mso-bookmark:bk2'></span><!--[if supportFields]><span style='mso-bookmark:
bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US>. The hypothesis language</span></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk2'><span lang=EN-US style='display:none;mso-hide:all'> XE
</span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;induction:hypothesis
language&quot; </span></span><![endif]--><span style='mso-bookmark:bk2'></span><!--[if supportFields]><span
style='mso-bookmark:bk2'></span><span style='mso-element:field-end'></span><![endif]--><span
style='mso-bookmark:bk2'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>is declared as follows: </span></span></p>

<p class=p-eerst style='page-break-after:auto'><span style='mso-bookmark:bk2'><span
lang=EN-US>literal(listnum(X,Y),[list(X),list(Y)]).<br>
literal(num(X,Y),[item(X),item(Y)]).</span></span></p>

<p class=p-laatst><span style='mso-bookmark:bk2'><span lang=EN-US>term(list([]),[]).<br>
term(list([X|Y]),[item(X),list(Y)]).</span></span></p>

<p class=tekst><span style='mso-bookmark:bk2'><span lang=EN-US>We supply the
following background theory</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;background
theory&quot; \r &quot;bk2&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>: </span></p>

<p class=p-el><span lang=EN-US>bg((num(1,one):-true)).<br>
bg((num(2,two):-true)).<br>
bg((num(3,three):-true)).<br>
bg((num(4,four):-true)).<br>
bg((num(5,five):-true)).</span></p>

<p class=tekst><span lang=EN-US>The predicate </span><span lang=EN-US
style='font-family:Courier'>listnum/2</span><span lang=EN-US> can be learned
from six well-chosen examples: </span></p>

<p class=programma style='margin-top:6.0pt;margin-right:0cm;margin-bottom:0cm;
margin-left:116.0pt;margin-bottom:.0001pt;text-indent:-99.0pt;page-break-after:
auto;tab-stops:242.0pt'><span lang=EN-US>?-induce_spec([<span style='mso-tab-count:
1'>&nbsp; </span>+listnum([],[]),<br>
-listnum([one],[one]),<br>
-listnum([1,two],[one,two]),<br>
+listnum([1],[one]),<br>
-listnum([five,two],[5,two]),<br>
+listnum([five],[5])<span style='mso-tab-count:1'> </span>],Clauses)</span></p>

<p class=p-eerst style='page-break-after:auto'><span lang=EN-US>3..Found
clause: listnum(X,Y):-true<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>...refuted:
listnum([one],[one]):-true</span></p>

<p class=programma style='page-break-after:auto'><span lang=EN-US>3..Found
clause: listnum([],[]):-true</span></p>

<p class=programma style='margin-left:214.0pt;text-indent:-197.0pt;page-break-after:
auto'><span lang=EN-US>3..4..Found clause:
listnum([V|Vs],[W|Ws]):-num(V,W),listnum(Vs,Ws)</span></p>

<p class=programma style='margin-left:214.0pt;text-indent:-197.0pt;page-break-after:
auto'><span lang=EN-US>3..4..Found clause:
listnum([X|Xs],[Y|Ys]):-num(Y,X),listnum(Xs,Ys)</span></p>

<p class=p-el><span lang=EN-US>Clauses = <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>[
(listnum([X|Xs],[Y|Ys]):-num(Y,X),listnum(Xs,Ys)),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(listnum([V|Vs],[W|Ws]):-num(V,W),listnum(Vs,Ws)),<br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>(listnum([],[]):-true) ]</span></p>

<p class=tekst><span lang=EN-US>It should again be noted that the examples need
to be well-chosen and well-ordered. This is particularly true for the recursive
clause. Because of the use of extensional coverage</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;extensional
coverage&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>, all positive examples occurring in a proof should be given;
moreover, it is good practice to supply negative examples for a particular
recursive clause before the positive ones. For this induction program, which
induces by specialising overly general clauses, negative examples are
particularly crucial. </span></p>

<div style='mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm'>

<p class=exercise style='margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm'><i style='mso-bidi-font-style:normal'><span lang=EN-US>Exercise
9.5</span></i><span lang=EN-US>. Replace the iterative deepening search
strategy with beam search</span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;beam
search&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>(see the article by
Quinlan, referred to below, for a possible heuristic</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;heuristic&quot;
</span><![endif]--><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>). </span></p>

</div>

<h3 id="further_reading_9"><span lang=EN-US>Further reading</span></h3>

<p class=sektie1><span lang=EN-US>The program </span><span lang=EN-US
style='font-family:Courier'>induce_rlgg/2</span><span lang=EN-US> is based on
the GOLEM</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;GOLEM&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>system described in
(Muggleton &amp; Feng, 1990). The program </span><span lang=EN-US
style='font-family:Courier'>induce_spec/2</span><span lang=EN-US> is based on
the MIS</span><!--[if supportFields]><span lang=EN-US style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;MIS&quot; </span><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>system described in
(Shapiro, 1983). (Quinlan, 1990) discusses a hill-climbing heuristic for
top-down induction. The notion of generalisation in logic programs is discussed
in (Niblett, 1988). (Gottlob, 1987) precisely characterises the difference
between </span><span lang=EN-US style='font-family:Symbol'>q</span><span
lang=EN-US>-subsumption and logical consequence. </span></p>

<p class=sektie><span lang=EN-US>The subject of inductively inferring logic
programs has been recently named <i style='mso-bidi-font-style:normal'>Inductive
Logic Programming</i></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Inductive Logic Programming&quot; </span></i><![endif]--><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US>. (Muggleton, 1992) is the first collection of papers on this
subject. Recent books are (De Raedt, 1992) and (Lavra</span><span lang=EN-US
style='font-family:YuTimes'>Ë</span><span lang=EN-US> &amp; D</span><span
lang=EN-US style='font-family:YuTimes'>æ</span><span lang=EN-US>eroski, 1994). </span></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>G.
Gottlob (</span><span lang=EN-US>1987)<span style='font-variant:small-caps'>,</span>
‘Subsumption and implication’, <i style='mso-bidi-font-style:normal'>Information
Processing Letters</i> <b style='mso-bidi-font-weight:normal'>24</b>:
109&#8211;111.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Gottlob,
G.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>N. Lavra</span><span
lang=EN-US style='font-size:9.0pt;font-family:YuTimes;font-variant:small-caps'>»</span><span
lang=EN-US style='font-variant:small-caps'> &amp; S. D</span><span lang=EN-US
style='font-family:YuTimes;font-variant:small-caps'>æ</span><span lang=EN-US
style='font-variant:small-caps'>eroski (</span><span lang=EN-US>1994)<span
style='font-variant:small-caps'>,</span> <i style='mso-bidi-font-style:normal'>Inductive
Logic Programming: Techniques and Applications</i>, Ellis Horwood.<span
style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Lavrac,
N.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Dzeroski,
S.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>S.H.
Muggleton &amp; C. Feng (</span><span lang=EN-US>1990)<span style='font-variant:
small-caps'>,</span> ‘Efficient induction of logic programs’. In <i
style='mso-bidi-font-style:normal'>Proc. First Conference on Algorithmic
Learning Theory</i>, Ohmsha, Tokyo. Also in (Muggleton, 1992), pp. 261-280. <span
style='display:none;mso-hide:all'>.H.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Muggleton,
S.H.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span
lang=EN-US style='display:none;mso-hide:all'>.;</span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Feng,
C.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>S.H.
Muggleton</span><span lang=EN-US> (ed.)<span style='font-variant:small-caps'> (</span>1992)<span
style='font-variant:small-caps'>,</span> <i style='mso-bidi-font-style:normal'>Inductive
Logic Programming</i>, Academic Press.<span style='display:none;mso-hide:all'>.H.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Muggleton,
S.H.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>T.
Niblett (</span><span lang=EN-US>1988)<span style='font-variant:small-caps'>,</span>
‘A study of generalisation in logic programs’. In <i style='mso-bidi-font-style:
normal'>Proc. European Working Sessions on Learning</i>, D. Sleeman (ed.), pp.
131-138, Pitman.<span style='display:none;mso-hide:all'>.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Niblett,
T.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>J.R.
Quinlan (</span><span lang=EN-US>1990)<span style='font-variant:small-caps'>,</span>
‘Learning logical definitions from relations’, <i style='mso-bidi-font-style:
normal'>Machine Learning</i> <b style='mso-bidi-font-weight:normal'>5</b>(3):
239-266.<span style='display:none;mso-hide:all'>.R.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Quinlan,
J.R.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>L. de
Raedt (</span><span lang=EN-US>1992)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Interactive Theory Revision: an Inductive
Logic Programming Approach</i>, Academic Press.<span style='display:none;
mso-hide:all'>.;</span></span><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;De
Raedt, L.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class=referenties><span lang=EN-US style='font-variant:small-caps'>E.Y.
Shapiro (</span><span lang=EN-US>1983)<span style='font-variant:small-caps'>,</span>
<i style='mso-bidi-font-style:normal'>Algorithmic Program Debugging</i>, MIT
Press.<span style='display:none;mso-hide:all'>.Y.;</span></span><!--[if supportFields]><span
lang=EN-US style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span lang=EN-US><span style="mso-spacerun:yes">&nbsp;</span>&quot;Shapiro,
E.Y.&quot; </span><![endif]--><!--[if supportFields]><span lang=EN-US
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<div style='mso-element:footnote-list'><![if !supportFootnotes]><br clear=all>

<hr align=left size=1 width="33%">

<![endif]>

<div style='mso-element:footnote' id=ftn1>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn1' href="#_ftnref1"
name="_ftn1" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[18]</span></span><![endif]></span></span></span></a><span
lang=EN-US>Ground literals of the form <i style='mso-bidi-font-style:normal'>t</i></span><span
lang=EN-US style='font-size:7.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US style='font-family:Courier'>=</span><i
style='mso-bidi-font-style:normal'><span lang=EN-US>t</span></i><span
lang=EN-US style='font-size:7.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>2</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>are <b style='mso-bidi-font-weight:normal'>true</b>
in an interpretation if and only if <i style='mso-bidi-font-style:normal'>t</i></span><span
lang=EN-US style='font-size:7.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>1</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>and <i style='mso-bidi-font-style:normal'>t</i></span><span
lang=EN-US style='font-size:7.0pt;position:relative;top:2.0pt;mso-text-raise:
-2.0pt'>2</span><span lang=EN-US><span
style="mso-spacerun:yes">&nbsp;</span>are the same ground term. Thus, the
predicate </span><span lang=EN-US style='font-family:Courier'>=</span><span
lang=EN-US> (which represents, as usual, syntactical identity) is not
explicitly represented in a model. </span></p>

</div>

<div style='mso-element:footnote' id=ftn2>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn2' href="#_ftnref2"
name="_ftn2" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[19]</span></span><![endif]></span></span></span></a><span
lang=EN-US>In SLDNF resolution, </span><span lang=EN-US style='font-family:
Courier'>not</span><span lang=EN-US> is treated as belonging to the language of
general clauses, rather than as a meta-predicate.</span></p>

</div>

<div style='mso-element:footnote' id=ftn3>

<p class=MsoFootnoteText><a style='mso-footnote-id:ftn3' href="#_ftnref3"
name="_ftn3" title=""><span class=MsoFootnoteReference><span lang=EN-US
style='font-size:8.0pt;mso-bidi-font-size:10.0pt'><span style='mso-special-character:
footnote'><![if !supportFootnotes]><span class=MsoFootnoteReference><span
lang=EN-US style='font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;
mso-fareast-font-family:"Times New Roman";mso-bidi-font-family:Times;
mso-ansi-language:EN-US;mso-fareast-language:EN-US;mso-bidi-language:AR-SA'>[20]</span></span><![endif]></span></span></span></a><span
lang=EN-US>If </span><span lang=EN-US style='font-family:Courier'>X</span><span
lang=EN-US> is a variable occurring in </span><span lang=EN-US
style='font-family:Courier'>Body</span><span lang=EN-US> but not in </span><span
lang=EN-US style='font-family:Courier'>Head</span><span lang=EN-US>, the
formula </span><span lang=EN-US style='font-family:Symbol'>&quot;</span><span
lang=EN-US style='font-family:Courier'>X: Head</span><span lang=EN-US
style='font-family:Symbol'>¬</span><span lang=EN-US style='font-family:Courier'>Body</span><span
lang=EN-US> is logically equivalent with </span><span lang=EN-US
style='font-family:Courier'>Head</span><span lang=EN-US style='font-family:
Symbol'>¬$</span><span lang=EN-US style='font-family:Courier'>X:Body</span><span
lang=EN-US>. Such variables are called <i style='mso-bidi-font-style:normal'>existential
variables</i>.</span></p>

</div>

</div>

<script>$(function() { $(".swish").LPN({swish:"http://swish.swi-prolog.org/"}); });</script>

<!-- </body> -->

<!-- </html> -->
