---
layout: paper
part: Part_I
---

<!-- <body bgcolor="white" lang="EN-GB" style="tab-interval:28.0pt"> -->

<div class="WordSection1">

<p id="logic_and_logic_programming" class="romeinscijfer">I<span style="font-size:36.0pt;mso-bidi-font-size:10.0pt"><o:p></o:p></span></p>

<div style="mso-element:para-border-div;border:none;border-bottom:solid windowtext 1.5pt;
padding:0cm 0cm 0cm 0cm;margin-left:1.0cm;margin-right:0cm">

<h1 id="h_logic_and_logic_programming" style="margin-left:0cm">Logic and <br>
Logic Programming</h1>

</div>

<p class="sektie1"><i style="mso-bidi-font-style:normal">Logic Programming</i> is
the name of a programming paradigm which was developed in the 70s. Rather than
viewing a computer program as a step-by-step description of an algorithm, the
program is conceived as a logical theory, and a procedure call is viewed as a
theorem of which the truth needs to be established. Thus, executing a program
means searching for a proof. In traditional (imperative) programming languages,
the program is a <i style="mso-bidi-font-style:normal">procedural</i>
specification of <b style="mso-bidi-font-weight:normal">how</b> a problem needs
to be solved. In contrast, a logic program concentrates on a <i style="mso-bidi-font-style:normal">declarative</i> specification of <b style="mso-bidi-font-weight:normal">what</b> the problem is. Readers familiar
with imperative programming will find that Logic Programming requires quite a
different way of thinking. Indeed, their knowledge of the imperative paradigm
will be partly incompatible with the logic paradigm. </p>

<p class="sektie">This is certainly true with regard to the concept of a program <i style="mso-bidi-font-style:normal">variable</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable</i>:in programming
languages<i style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
In imperative languages, a variable is a name for a memory location which can
store data of certain types. While the contents of the location may vary over
time, the variable always points to the same location. In fact, the term
&lsquo;variable&rsquo; is a bit of a misnomer here, since it refers to a value that is
well-defined at every moment. In contrast, a variable in a logic program is a
variable in the mathematical sense, i.e. a placeholder that can take on any
value. In this respect, Logic Programming is therefore much closer to
mathematical intuition than imperative programming. </p>

<p class="sektie">Imperative programming and Logic Programming also differ with
respect to the <i style="mso-bidi-font-style:normal">machine model</i> they
assume. A machine model is an abstraction of the computer on which programs are
executed. The imperative paradigm assumes a dynamic, state-based machine model,
where the state of the computer is given by the contents of its memory. The
effect of a program statement is a transition from one state to another. Logic
Programming does not assume such a dynamic machine model. Computer plus program
represent a certain amount of knowledge about the world, which is used to
answer queries. </p>

<p class="sektie">The first three chapters of the book are devoted to an
introduction to Logic Programming. Chapter 1, <i style="mso-bidi-font-style:
normal">A brief introduction to clausal logic</i>, is an introductory chapter,
introducing many concepts in Logic Programming by means of examples. These
concepts get a more formal treatment in Chapter 2, <i style="mso-bidi-font-style:
normal">Clausal logic and resolution: theoretical backgrounds</i>. In Chapter
3, <i style="mso-bidi-font-style:normal">Logic Programming and Prolog</i>, we
take a closer look at Prolog as a logic programming language, explaining its
main features and describing some common programming techniques.</p>

</div>

<b style="mso-bidi-font-weight:normal"><span style="font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:
EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes"><br clear="all" style="page-break-before:
right;mso-break-type:section-break">
</span></b>

<div class="WordSection2">

<p id="a_brief_introduction_to_clausal_logic" class="cijfer">1</p>

<h2 id="h_a_brief_introduction_to_clausal_logic">A brief introduction to clausal logic</h2>

<p class="sektie1">In this chapter, we will introduce clausal logic as a
formalism for representing and reasoning with knowledge. The aim of this
chapter is to acquaint the reader with the most important concepts, without
going into too much detail. The theoretical aspects of clausal logic, and the
practical aspects of Logic Programming, will be discussed in Chapters 2 and 3.</p>

<p class="sektie">Our Universe of Discourse<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Universe of
Discourse&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>in this chapter will be the London
Underground<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;London Underground example&quot; \b
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]-->, of which a small part
is shown in fig. 1.1. Note that this picture contains a wealth of information,
about lines, stations, transit between lines, relative distance, etc. We will
try to capture this information in logical statements. Basically, fig. 1.1
specifies which stations are directly connected by which lines. If we follow
the lines from left to right (Northern downwards), we come up with the
following 11 formulas:</p>

<pre class="source swish temp" data-variant-id="group-1" id="swish.1.0.1" style="display: block;">
connected(bond_street,oxford_circus,central).
connected(oxford_circus,tottenham_court_road,central).
connected(bond_street,green_park,jubilee).
connected(green_park,charing_cross,jubilee).
connected(green_park,piccadilly_circus,piccadilly).
connected(piccadilly_circus,leicester_square,piccadilly).
connected(green_park,oxford_circus,victoria).
connected(oxford_circus,piccadilly_circus,bakerloo).
connected(piccadilly_circus,charing_cross,bakerloo).
connected(tottenham_court_road,leicester_square,northern).
connected(leicester_square,charing_cross,northern).
</pre>

<p class="tekst">Let&rsquo;s define two stations to be <i style="mso-bidi-font-style:
normal">nearby</i> if they are on the same line, with at most one station in
between. This relation can also be represented by a set of logical formulas:</p>

<pre class="source swish" data-variant-id="group-1" id="swish.1.0.2" style="display: block;">
nearby(bond_street,oxford_circus).
nearby(oxford_circus,tottenham_court_road).
nearby(bond_street,tottenham_court_road).
nearby(bond_street,green_park).
nearby(green_park,charing_cross).
nearby(bond_street,charing_cross).
nearby(green_park,piccadilly_circus).
nearby(piccadilly_circus,leicester_square).
nearby(green_park,leicester_square).
nearby(green_park,oxford_circus).
nearby(oxford_circus,piccadilly_circus).
nearby(piccadilly_circus,charing_cross).
nearby(oxford_circus,charing_cross).
nearby(tottenham_court_road,leicester_square).
nearby(leicester_square,charing_cross).
nearby(tottenham_court_road,charing_cross).
</pre>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shapetype id="_x0000_t75" coordsize="21600,21600"
   o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe" filled="f"
   stroked="f">
   <v:stroke joinstyle="miter"/>
   <v:formulas>
    <v:f eqn="if lineDrawn pixelLineWidth 0"/>
    <v:f eqn="sum @0 1 0"/>
    <v:f eqn="sum 0 0 @1"/>
    <v:f eqn="prod @2 1 2"/>
    <v:f eqn="prod @3 21600 pixelWidth"/>
    <v:f eqn="prod @3 21600 pixelHeight"/>
    <v:f eqn="sum @0 0 1"/>
    <v:f eqn="prod @6 1 2"/>
    <v:f eqn="prod @7 21600 pixelWidth"/>
    <v:f eqn="sum @8 21600 0"/>
    <v:f eqn="prod @7 21600 pixelHeight"/>
    <v:f eqn="sum @10 21600 0"/>
   </v:formulas>
   <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
   <o:lock v:ext="edit" aspectratio="t"/>
  </v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:281pt;
   height:196pt'>
   <v:imagedata src="Part%20I_files/image001.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image002.svg" v:shapes="_x0000_i1025"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 1.1.</b> Part
  of the London Underground. Reproduced by permission of London Regional
  Transport (LRT Registered User No. 94/1954). </p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="tekst">These 16 formulas have been derived from the previous 11
formulas in a systematic way. If <i style="mso-bidi-font-style:normal">X</i>
and <i style="mso-bidi-font-style:normal">Y</i> are directly connected via some
line <i style="mso-bidi-font-style:normal">L</i>, then <i style="mso-bidi-font-style:
normal">X</i> and <i style="mso-bidi-font-style:normal">Y</i> are nearby.
Alternatively, if there is some <i style="mso-bidi-font-style:normal">Z</i> in
between, such that <i style="mso-bidi-font-style:normal">X</i> and <i style="mso-bidi-font-style:normal">Z</i> are directly connected via <i style="mso-bidi-font-style:normal">L</i>, and <i style="mso-bidi-font-style:
normal">Z</i> and <i style="mso-bidi-font-style:normal">Y</i> are also directly
connected via <i style="mso-bidi-font-style:normal">L</i>, then <i style="mso-bidi-font-style:normal">X</i> and <i style="mso-bidi-font-style:
normal">Y</i> are also nearby. We can formulate this in logic as follows:</p>


<pre class="source swish inherit" inherit-id="swish.1.0.1" data-variant-id="group-1" id="swish.1.0.3" style="display: block;">
nearby(X,Y):-connected(X,Y,L).
nearby(X,Y):-connected(X,Z,L),connected(Z,Y,L).
<!-- nearby(X,Y):-connected(X,Y,L). 
-->
</pre>

<p class="tekst">In these formulas, the symbol &lsquo;<span style="font-family:Courier">:-</span>&rsquo;
should be read as &lsquo;if&rsquo;, and the comma between <span style="font-family:Courier">connected(X,Z,L)</span>
and <span style="font-family:Courier">connected(Z,Y,L)</span> should be read as
&lsquo;and&rsquo;. The uppercase letters stand for universally quantified variables, such
that, for instance, the second formula means:</p>

<p class="citaat"><b style="mso-bidi-font-weight:normal">For any values</b> of <i style="mso-bidi-font-style:normal">X</i>, <i style="mso-bidi-font-style:normal">Y</i>,
<i style="mso-bidi-font-style:normal">Z</i> and <i style="mso-bidi-font-style:
normal">L</i>, <i style="mso-bidi-font-style:normal">X</i> is nearby <i style="mso-bidi-font-style:normal">Y</i> <b style="mso-bidi-font-weight:normal">if</b>
<i style="mso-bidi-font-style:normal">X</i> is directly connected to Z via L, <b style="mso-bidi-font-weight:normal">and</b> Z is directly connected to Y via L.</p>

<p class="sektie">We now have two definitions of the nearby-relation, one which
simply lists all pairs of stations that are nearby each other, and one in terms
of direct connections. Logical formulas of the first type, such as</p>

<p class=p-el>?-nearby(bond_street,oxford_circus) </p>

<p class="tekst">will be called <i style="mso-bidi-font-style:normal">fact</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;fact&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, and formulas of the second type, such
as</p>

<p class=p-el>?-nearby(X,Y):-connected(X,Z,L),connected(Z,Y,L) </p>

<p class="tekst">will be called <i style="mso-bidi-font-style:normal">rule</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;rule&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>. Facts express unconditional truths,
while rules denote conditional truths, i.e. conclusions which can only be drawn
when the premises are known to be true. Obviously, we want these two
definitions to be <i style="mso-bidi-font-style:normal">equivalent</i>: for
each possible query, both definitions should give exactly the same answer. We
will make this more precise in the next section.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 1.1.</i> Two
stations are &lsquo;not too far&rsquo; if they are on the same or a different line, with at
most one station in between. Define rules for the predicate <span style="font-family:Courier">not_too_far</span>.</p>

</div>

<h3 id="answering_queries">1.1<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Answering
queries</h3>

<p class="sektie1">A <i style="mso-bidi-font-style:normal">query</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;query&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>like &lsquo;which station is nearby Tottenham
Court Road?&rsquo; will be written as </p>

<pre class="query" id="query.1.1.1"><span class="swish query">?- nearby(tottenham_court_road,W).</span></pre>

<p class="tekst">where the prefix &lsquo;<span style="font-family:Courier">?-</span>&rsquo;
indicates that this is a query rather than a fact. An <i style="mso-bidi-font-style:
normal">answer</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;answer</i> to a query<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>to this query, e.g. &lsquo;Leicester Square&rsquo;,
will be written {<span style="font-family:Courier">W</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">leicester_square</span>},
indicating a <i style="mso-bidi-font-style:normal">substitution</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;substitution&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of values for variables, such that the
statement in the query, i.e. </p>

<pre class="query" id="query15"><span class="swish query">?-nearby(tottenham_court_road,leicester_square).</span></pre>

<p class="tekst">is true. Now, if the nearby-relation is defined by means of a
list of facts, answers to queries are easily found: just look for a fact that <i style="mso-bidi-font-style:normal">matches</i> the query, by which is meant
that the fact and the query can be made identical by substituting values for
variables in the query. Once we have found such a fact, we also have the
substitution which constitutes the answer to the query.</p>

<p class="sektie">If rules are involved, query-answering can take several of
these steps. For answering the query <span style="font-family:Courier">?-nearby(tottenham_court_road,W)</span>,
we match it with the conclusion of the rule </p>

<p class="p-el">nearby(X,Y):-connected(X,Y,L)</p>

<p class="tekst">yielding the substitution {<span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">tottenham_court_road</span>,
<span style="font-family:Courier">Y</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">W</span>}. We then try to find an answer for the
premises of the rule under this substitution, i.e. we try to answer the query </p>

<pre class="query" id="query15"><span class="swish query">?-connected(tottenham_court_road,W,L). </span></pre>

<p class="tekst">That is, we can find a station nearby Tottenham Court Road, if
we can find a station directly connected to it. This second query is answered
by looking at the facts for direct connections, giving the answer {<span style="font-family:Courier">W</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">leicester_square</span>, <span style="font-family:
Courier">L</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">northern</span>}. Finally, since the variable <span style="font-family:Courier">L</span> does not occur in the initial query, we
just ignore it in the final answer, which becomes {<span style="font-family:
Courier">W</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">leicester_square</span>} as above. In fig. 1.2, we
give a graphical representation of this process. Since we are essentially <i style="mso-bidi-font-style:normal">proving</i> that a statement follows
logically from some other statements, this graphical representation is called a
<i style="mso-bidi-font-style:normal">proof tree</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof tree&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1026" type="#_x0000_t75"
   style='width:332pt;height:94pt'>
   <v:imagedata src="Part%20I_files/image003.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image004.svg" v:shapes="_x0000_i1026"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 1.2.</b> A
  proof tree for the query <span style="font-family:Courier">?-nearby(tottenham_court_road,W)</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">The steps in fig. 1.2 follow a very general reasoning pattern:</p>

<p class="citaat">to answer a query <span style="font-family:Courier">?-</span><i style="mso-bidi-font-style:normal">Q</i><span style="font-size:9.0pt;
mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">1</span><span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">Q</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">2</span><span style="font-family:Courier">,</span>&hellip;<span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">Q</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:
10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">n</span></i>, find a
rule <i style="mso-bidi-font-style:normal">A</i><span style="font-family:Courier">:-</span><i style="mso-bidi-font-style:normal">B</i><span style="font-size:9.0pt;
mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">1</span><span style="font-family:Courier">,</span>&hellip;<span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">B</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">m</span></i><span style="mso-spacerun:yes">&nbsp;</span>such that <i style="mso-bidi-font-style:
normal">A</i> matches with <i style="mso-bidi-font-style:normal">Q</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">1</span>, and answer the query <span style="font-family:
Courier">?-</span><i style="mso-bidi-font-style:normal">B</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">1</span><span style="font-family:Courier">,</span>&hellip;<span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">B</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:
10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">m</span></i><span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">Q</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">2</span><span style="font-family:Courier">,</span>&hellip;<span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">Q</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:
10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">n</span></i>.</p>

<p class="tekst">This reasoning pattern is called <i style="mso-bidi-font-style:
normal">resolution</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;resolution&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and we will study it extensively in Chapters 2 and 3. Resolution adds a <b style="mso-bidi-font-weight:normal">procedural interpretation</b><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><b style='mso-bidi-font-weight:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;procedural interpretation&quot; </b><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>to logical formulas, besides their
declarative interpretation<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;declarative interpretation&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(they can be either true or false). Due
to this procedural interpretation, logic can be used as a programming language.
In an ideal logic programming system, the procedural interpretation would
exactly match the declarative interpretation: everything that is calculated
procedurally is declaratively true, and <i style="mso-bidi-font-style:normal">vice
versa</i>. In such an ideal system, the programmer would just bother about the
declarative interpretation of the formulas she writes down, and leave the
procedural interpretation to the computer. Unfortunately, in current logic
programming systems the procedural interpretation does <b style="mso-bidi-font-weight:
normal">not</b> exactly match the declarative interpretation: for example, some
things that are declaratively true are not calculated at all, because the
system enters an infinite loop. Therefore, the programmer should also be aware
of the procedural interpretation given by the computer to her logical formulas.</p>

<p class="sektie">The resolution proof process makes use of a technique that is
known as <i style="mso-bidi-font-style:normal">reduction to the absurd</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;reduction to the absurd&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
suppose that the formula to be proved is false, and show that this leads to a
contradiction, thereby demonstrating that the formula to be proved is in fact
true. Such a proof is also called a <i style="mso-bidi-font-style:normal">proof
by refutation</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof :by refutation&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
For instance, if we want to know which stations are nearby Tottenham Court
Road, we negate this statement, resulting in &lsquo;there are no stations nearby
Tottenham Court Road&rsquo;. In logic, this is achieved by writing the statement as a
rule with an empty conclusion, i.e. a rule for which the truth of its premises
would lead to falsity: </p>

<p class="p-el">:-nearby(tottenham_court_road,W)</p>

<p class="tekst">Thus, the symbols &lsquo;<span style="font-family:Courier">?-</span>&rsquo;
and &lsquo;<span style="font-family:Courier">:-</span>&rsquo; are in fact equivalent. A
contradiction is found if resolution leads to the empty rule, of which the
premises are always true (since there are none), but the conclusion is always
false. Conventionally, the empty rule is written as &lsquo;<span style="font-family:
Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>&rsquo;.</p>

<p class="sektie">At the beginning of this section, we posed the question: can we
show that our two definitions of the nearby-relation are equivalent? As
indicated before, the idea is that to be equivalent means to provide exactly
the same answers to the same queries. To formalise this, we need some
additional definitions. A <i style="mso-bidi-font-style:normal">ground</i> fact<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ground</i> fact<i style='mso-bidi-font-style:
normal'>&quot; </i><![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a fact without variables. Obviously,
if <span style="font-family:Courier">G</span> is a ground fact, the query <span style="font-family:Courier">?-G</span> never returns a substitution as answer:
either it <i style="mso-bidi-font-style:normal">succeeds</i> <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;succeeding query&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(<span style="font-family:Courier">G</span> does follow from the initial assumptions),
or it <i style="mso-bidi-font-style:normal">fails</i> (<span style="font-family:
Courier">G</span> does not)<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;failing query&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
The set of ground facts <span style="font-family:Courier">G</span> for which
the query <span style="font-family:Courier">?-G</span> succeeds is called the <i style="mso-bidi-font-style:normal">success set</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;success set&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.<span style="mso-spacerun:yes">&nbsp; </span>Thus, the success set for our first
definition of the nearby-relation consists simply of those 16 formulas, since
they are ground facts already, and nothing else is derivable from them. The
success set for the second definition of the nearby-relation is constructed by
applying the two rules to the ground facts for connectedness. Thus we can say:
two definitions of a relation are (procedurally) <i style="mso-bidi-font-style:
normal">equivalent </i>if they have the same success set (restricted to that
relation).</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 1.2.</i>
Construct the proof trees for the query <br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">?-nearby(W,charing_cross)</span>.</p>

</div>

<h3 id="recursion">1.2<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Recursion</h3>

<p class="sektie1">Until now, we have encountered two types of logical formulas:
facts and rules. There is a special kind of rule which deserves special
attention: the rule which defines a relation in terms of itself. This idea of
&lsquo;self-reference&rsquo;, which is called <i style="mso-bidi-font-style:normal">recursion</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;recursion&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
is also present in most procedural programming languages. Recursion is a bit
difficult to grasp, but once you&rsquo;ve mastered it, you can use it to write very
elegant programs, e.g. </p>

<p class="p-el"><span style="font-family:Helvetica">IF N=0 <br>
THEN FAC:=1 <br>
ELSE FAC:=N*FAC(N-1). <o:p></o:p></span></p>

<p class="tekst">is a recursive procedure for calculating the factorial of a
given number, written in a Pascal-like procedural language. However, in such
languages <i style="mso-bidi-font-style:normal">iteration</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;iteration&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(looping a pre-specified number of times)
is usually preferred over recursion, because it uses memory more efficiently.</p>

<p class="sektie">In Prolog, however, recursion is the <b style="mso-bidi-font-weight:
normal">only</b> looping structure<abar><a style="mso-footnote-id:ftn1" href="#_ftn1" name="_ftnref1" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:
footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:
&quot;Times New Roman&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:
EN-GB;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes">[1]</span></span><!--[endif]--></span></span></span></a></abar><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:loops&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;failure-driven loop&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
(This does not necessarily mean that Prolog is always less efficient than a
procedural language, because there are ways to write recursive loops that are
just as efficient as iterative loops, as we will see in section 3.6.) Perhaps
the easiest way to think about recursion is the following: an arbitrarily large
chain is described by describing how one link in the chain is connected to the
next. For instance, let us define the relation of <i style="mso-bidi-font-style:
normal">reachability</i> in our underground example, where a station is
reachable from another station if they are connected by one or more lines. We
could define it by the following 20 ground facts:</p>

<p class="p-el" style="mso-pagination:widow-orphan">reachable(bond_street,charing_cross).<br>
reachable(bond_street,green_park).<br>
reachable(bond_street,leicester_square).<br>
reachable(bond_street,oxford_circus).<br>
reachable(bond_street,piccadilly_circus).<br>
reachable(bond_street,tottenham_court_road).<br>
reachable(green_park,charing_cross).<br>
reachable(green_park,leicester_square).<br>
reachable(green_park,oxford_circus).<br>
reachable(green_park,piccadilly_circus).<br>
reachable(green_park,tottenham_court_road).<br>
reachable(leicester_square,charing_cross).<br>
reachable(oxford_circus,charing_cross).<br>
reachable(oxford_circus,leicester_square).<br>
reachable(oxford_circus,piccadilly_circus).<br>
reachable(oxford_circus,tottenham_court_road).<br>
reachable(piccadilly_circus,charing_cross).<br>
reachable(piccadilly_circus,leicester_square).<br>
reachable(tottenham_court_road,charing_cross).<br>
reachable(tottenham_court_road,leicester_square).</p>

<p class="tekst">Since any station is reachable from any other station by a route
with at most two intermediate stations, we could instead use the following
(non-recursive) definition:</p>

<p class="p-eerst" style="margin-left:119.0pt;text-indent:-102.0pt">reachable(X,Y):-<span style="mso-tab-count:1"> </span>connected(X,Y,L).</p>

<p class="programma" style="margin-left:119.0pt;text-indent:-102.0pt">reachable(X,Y):-<span style="mso-tab-count:1"> </span>connected(X,Z,L1),connected(Z,Y,L2).</p>

<p class="p-laatst" style="margin-left:119.0pt;text-indent:-102.0pt">reachable(X,Y):-<span style="mso-tab-count:1"> </span>connected(X,Z1,L1),connected(Z1,Z2,L2),<br>
connected(Z2,Y,L3).</p>

<p class="tekst">Of course, if we were to define the reachability relation for
the entire London underground, we would need a lot more, longer and longer
rules. Recursion is a much more convenient and natural way to define such
chains of arbitrary length:</p>

<p class="p-eerst">reachable(X,Y):-connected(X,Y,L).</p>

<p class="p-laatst">reachable(X,Y):-connected(X,Z,L),reachable(Z,Y).</p>

<p class="tekst">The reading of the second rule is as follows: &lsquo;<i style="mso-bidi-font-style:normal">Y</i> is reachable from <i style="mso-bidi-font-style:
normal">X</i> if <i style="mso-bidi-font-style:normal">Z</i> is directly
connected to <i style="mso-bidi-font-style:normal">X</i> via line <i style="mso-bidi-font-style:normal">L</i>, and <i style="mso-bidi-font-style:
normal">Y</i> is reachable from <i style="mso-bidi-font-style:normal">Z</i>&rsquo;.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75"
   style='width:310pt;height:273pt'>
   <v:imagedata src="Part%20I_files/image005.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image006.svg" v:shapes="_x0000_i1027"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 1.3.</b> A
  proof tree for the query <span style="font-family:Courier">?-reachable(bond_street,W)</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">We can now use this recursive definition to prove that Leicester
Square is reachable from Bond Street (fig. 1.3). However, just as there are
several routes from Bond Street to Leicester Square, there are several
alternative proofs of the fact that Leicester Square is reachable from Bond
Street. An alternative proof is given in fig. 1.4. The difference between these
two proofs is that in the first proof we use the fact </p>

<p class="p-el">connected(oxford_circus,tottenham_court_road,central)</p>

<p class="tekst">while in the second proof we use </p>

<p class="p-el">connected(oxford_circus,piccadilly_circus,bakerloo)</p>

<p class="tekst">There is no reason to prefer one over the other, but since
Prolog searches the given formulas top-down, it will find the first proof
before the second. Thus, the order of the clauses determines the order in which
answers are found. As we will see in Chapter 3, it sometimes even determines
whether any answers are found at all. </p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 1.3.</i> Give a
third proof tree for the answer {<span style="font-family:Courier">W</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">leicester_square</span>},
and change the order of the facts for connectedness, such that this proof tree
is constructed first.</p>

</div>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1028" type="#_x0000_t75"
   style='width:316pt;height:281pt'>
   <v:imagedata src="Part%20I_files/image007.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image008.svg" v:shapes="_x0000_i1028"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 1.4.</b>
  Alternative proof tree for the query <span style="font-family:Courier">?-reachable(bond_street,W)</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">In other words, Prolog&rsquo;s query-answering process is a <i style="mso-bidi-font-style:normal">search process</i>, in which the answer
depends on all the choices made earlier. A important point is that some of
these choices may lead to a dead-end later. For example, if the recursive
formula for the reachability relation had been tried before the non-recursive
one, the bottom part of fig. 1.3 would have been as in fig. 1.5. This proof
tree cannot be completed, because there are no answers to the query <span style="font-family:Courier">?-reachable(charing_cross,W)</span>, as can easily
be checked. Prolog has to recover from this failure by climbing up the tree,
reconsidering previous choices. This search process, which is called <i style="mso-bidi-font-style:normal">backtracking</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
will be detailed in Chapter 5.</p>

<h3 id="structured_terms">1.3<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Structured terms</h3>

<p class="sektie1">Finally, we illustrate the way Prolog can handle more complex
datastructures, such as a list of stations representing a route. Suppose we
want to redefine the reachability relation, such that it also specifies the intermediate
stations. We could adapt the non-recursive definition of <span style="font-family:Courier">reachable</span> as follows:</p>

<p class="p-eerst" style="margin-left:167.0pt;text-indent:-150.0pt">reachable0(X,Y):-connected(X,Y,L).</p>

<p class="programma" style="margin-left:136.0pt;text-indent:-119.0pt">reachable1(X,Y,Z):-<span style="mso-tab-count:1"> </span>connected(X,Z,L1),<br>
connected(Z,Y,L2).</p>

<p class="p-laatst" style="margin-left:160.0pt;text-indent:-143.0pt">reachable2(X,Y,Z1,Z2):-<span style="mso-tab-count:1"> </span>connected(X,Z1,L1),<br>
connected(Z1,Z2,L2),<br>
connected(Z2,Y,L3).</p>

<p class="tekst">The suffix of reachable indicates the number of intermediate
stations; it is added to stress that relations with different number of
arguments are really different relations, even if their names are the same. The
problem now is that we have to know the number of intermediate stations in
advance, before we can ask the right query. This is, of course, unacceptable.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1029" type="#_x0000_t75"
   style='width:311pt;height:177pt'>
   <v:imagedata src="Part%20I_files/image009.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image010.svg" v:shapes="_x0000_i1029"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 1.5.</b> A
  failing proof tree.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">We can solve this problem by means of <i style="mso-bidi-font-style:
normal">functors</i>. A functor<!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;functor&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>looks just like a mathematical function,
but the important difference is that <i style="mso-bidi-font-style:normal">functor
expressions are never evaluated to determine a value</i>. Instead, they provide
a way to name a complex object composed of simpler objects. For instance, a
route with Oxford Circus and Tottenham Court Road as intermediate stations
could be represented by </p>

<p class="p-el">route(oxford_circus,tottenham_court_road)</p>

<p class="tekst">Note that this is not a ground fact, but rather an argument for
a logical formula. The reachability relation can now be defined as follows:</p>

<p class="p-eerst" style="margin-left:195.0pt;text-indent:-178.0pt">reachable(X,Y,noroute):-connected(X,Y,L).</p>

<p class="programma" style="margin-left:174.0pt;text-indent:-157.0pt">reachable(X,Y,route(Z)):-<span style="mso-tab-count:1"> </span>connected(X,Z,L1),<br>
connected(Z,Y,L2).</p>

<p class="p-laatst" style="margin-left:195.0pt;text-indent:-178.0pt">reachable(X,Y,route(Z1,Z2)):-<span style="mso-tab-count:1"> </span>connected(X,Z1,L1),<br>
connected(Z1,Z2,L2),<br>
connected(Z2,Y,L3).</p>

<p class="tekst">The query <span style="font-family:Courier">?-reachable(oxford_circus,charing_cross,R)</span>
now has three possible answers:</p>

<p class="tekst" style="margin-top:6.0pt;margin-right:0cm;margin-bottom:6.0pt;
margin-left:18.0pt">{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">route(piccadilly_circus)</span>}<br>
{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">route(tottenham_court_road,leicester_square)</span>}<br>
{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">route(piccadilly_circus,leicester_square)</span>}</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1030" type="#_x0000_t75"
   style='width:214pt;height:112pt'>
   <v:imagedata src="Part%20I_files/image011.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image012.svg" v:shapes="_x0000_i1030"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 1.6.</b> A
  complex object as a tree.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">As argued in the previous section, we prefer the recursive
definition of the reachability relation, in which case we use functors in a
somewhat different way.</p>

<p class="p-eerst" style="margin-left:185.0pt;text-indent:-168.0pt">reachable(X,Y,noroute):-connected(X,Y,L).</p>

<p class="p-laatst" style="margin-left:185.0pt;text-indent:-168.0pt">reachable(X,Y,route(Z,R)):-<span style="mso-tab-count:1"> </span>connected(X,Z,L),<br>
reachable(Z,Y,R).</p>

<p class="tekst">At first sight, there does not seem to be a big difference
between this and the use of functors in the non-recursive program. However, the
query</p>

<p class="p-el">?-reachable(oxford_circus,charing_cross,R)</p>

<p class="tekst">now has the following answers: </p>

<p class="p-eerst" style="margin-left:76.0pt;text-indent:-59.0pt">{R<span style="font-family:Symbol">&rarr;</span>route(tottenham_court_road,<br>
route(leicester_square,noroute))}</p>

<p class="programma">{R<span style="font-family:Symbol">&rarr;</span>route(piccadilly_circus,noroute)}</p>

<p class="p-laatst" style="margin-left:76.0pt;text-indent:-59.0pt">{R<span style="font-family:Symbol">&rarr;</span>route(piccadilly_circus,<br>
route(leicester_square,noroute))}</p>

<p class="tekst">The functor <span style="font-family:Courier">route</span> is
now also recursive in nature: its first argument is a station, but <i style="mso-bidi-font-style:normal">its second argument is again a route</i>.
For instance, the object</p>

<p class="p-el" align="right" style="margin-left:0cm;text-align:right">route(tottenham_court_road,route(leicester_square,noroute))</p>

<p class="tekst">can be pictured as in fig. 1.6. Such a figure is called a <i style="mso-bidi-font-style:normal">tree</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tree&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;term: as a tree&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(we will have a lot more to say about
trees in chapter 4). In order to find out the route represented by this complex
object, we read the leaves of this tree from left to right, until we reach the
&lsquo;terminator&rsquo; <span style="font-family:Courier">noroute</span>. This would
result in a linear notation like </p>

<p class="p-el">[tottenham_court_road,leicester_square].</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1031" type="#_x0000_t75"
   style='width:202pt;height:162pt'>
   <v:imagedata src="Part%20I_files/image013.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image014.svg" v:shapes="_x0000_i1031"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 1.7.</b>
  The list <span style="font-family:Courier">[a,b,c</span>] as a tree.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">For user-defined functors, such a linear notation is not
available. However, Prolog provides a built-in &lsquo;datatype&rsquo; called <i style="mso-bidi-font-style:normal">list</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;list&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, for which both the tree-like notation
and the linear notation may be used. The functor for lists is <span style="font-family:Courier">.</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;.</span> (list functor)<span
style='font-family:Courier'>&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(dot), which takes two arguments: the
first element of the list (which may be any object), and the rest of the list
(which must be a list). The list terminator is the special symbol <span style="font-family:Courier">[]</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;[]&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->, denoting the empty list. For instance,
the term </p>

<p class="p-el">.(a,.(b,.(c,[]))) </p>

<p class="tekst">denotes the list consisting of <span style="font-family:Courier">a</span>
followed by <span style="font-family:Courier">b</span> followed by <span style="font-family:Courier">c</span> (fig. 1.7). Alternatively, we may use the
linear notation, which uses square brackets: <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;list:linear notation&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="p-el">[a,b,c]</p>

<p class="tekst">To increase readability of the tree-like notation, instead of </p>

<p class="p-el">.(First,Rest) </p>

<p class="tekst">one can also write </p>

<p class="p-el">[First|Rest]</p>

<p class="tekst">Note that <span style="font-family:Courier">Rest</span> is a
list: e.g., <span style="font-family:Courier">[a,b,c]</span> is the same list
as <span style="font-family:Courier">[a|[b,c]]</span>. <span style="font-family:
Courier">a</span> is called the <i style="mso-bidi-font-style:normal">head</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;head</i>:of a list<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;list:head&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of the list, and <span style="font-family:
Courier">[b,c]</span> is called its <i style="mso-bidi-font-style:normal">tail</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tail</i> of a list<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;list:tail&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Finally, to a certain extent the two notations can be mixed: at the head of the
list, you can write any number of elements in linear notation. For instance, </p>

<p class="p-el">[First,Second,Third|Rest] </p>

<p class="tekst">denotes a list with three or more elements.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 1.4.</i> A list
is either the empty list <span style="font-family:Courier">[]</span>, or a
non-empty list <span style="font-family:Courier">[First|Rest]</span> where <span style="font-family:Courier">Rest</span> is a list. Define a relation <span style="font-family:Courier">list(L)</span>, which checks whether <span style="font-family:Courier">L</span> is a list. Adapt it such that it succeeds
only for lists of (<i style="mso-bidi-font-style:normal">i</i>) even length and
(<i style="mso-bidi-font-style:normal">ii</i>) odd length.</p>

</div>

<p class="sektie">The recursive nature of such datastructures makes it possible
to ignore the size of the objects, which is extremely useful in many
situations. For instance, the definition of a route between two underground
stations does not depend on the length of the route; all that matters is
whether there is an intermediate station or not. For both cases, there is a
clause. Expressing the route as a list, we can state the final definition of
the reachability relation:</p>

<p class="p-eerst">reachable(X,Y,[]):-connected(X,Y,L).</p>

<p class="p-laatst">reachable(X,Y,[Z|R]):-connected(X,Z,L),reachable(Z,Y,R).</p>

<p class="tekst">The query <span style="font-family:Courier">?-reachable(oxford_circus,charing_cross,R)</span>
now results in the following answers:</p>

<p class="tekst" style="margin-top:6.0pt;margin-right:0cm;margin-bottom:6.0pt;
margin-left:18.0pt">{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">[tottenham_court_road,leicester_square]</span>}<br>
{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">[piccadilly_circus]</span>}<br>
{<span style="font-family:Courier">R</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">[piccadilly_circus, leicester_square]</span>}</p>

<p class="tekst">Note that Prolog writes out lists of fixed length in the linear
notation.</p>

<p class="sektie">Should we for some reason want to know from which station
Charing Cross can be reached via a route with four intermediate stations, we
should ask the query</p>

<p class="sektie" style="margin-top:3.0pt;margin-right:0cm;margin-bottom:3.0pt;
margin-left:0cm"><span style="font-family:Courier">?-reachable(X,charing_cross,[A,B,C,D])</span></p>

<p class="tekst">which results in two answers:</p>

<p class="p-eerst" style="margin-left:26.0pt;text-indent:-9.0pt;page-break-after:
auto"><span style="font-family:Times">{<span style="mso-tab-count:1">&nbsp; </span></span>X<span style="font-family:Symbol">&rarr;</span>bond_street<span style="font-family:Times">,
</span>A<span style="font-family:Symbol">&rarr;</span>green_park<span style="font-family:Times">, </span>B<span style="font-family:Symbol">&rarr;</span>oxford_circus<span style="font-family:Times">, </span>C<span style="font-family:Symbol">&rarr;</span>tottenham_court_road<span style="font-family:Times">, </span>D<span style="font-family:Symbol">&rarr;</span>leicester_square<span style="font-family:Times"> }</span></p>

<p class="p-laatst" style="margin-left:26.1pt;text-indent:-9.05pt"><span style="font-family:Times">{<span style="mso-tab-count:1">&nbsp; </span></span>X<span style="font-family:Symbol">&rarr;</span>bond_street<span style="font-family:Times">,
</span>A<span style="font-family:Symbol">&rarr;</span>green_park<span style="font-family:Times">, </span>B<span style="font-family:Symbol">&rarr;</span>oxford_circus<span style="font-family:Times">, </span>C<span style="font-family:Symbol">&rarr;</span>piccadilly_circus<span style="font-family:Times">, </span>D<span style="font-family:Symbol">&rarr;</span>leicester_square<span style="font-family:Times"> }.</span></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 1.5.</i>
Construct a query asking for a route from Bond Street to Piccadilly Circus with
at least two intermediate stations.</p>

</div>

<h3 id="what_else_is_there_to_know_about_clausal_logic">1.4<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>What else is
there to know about clausal logic?</h3>

<p class="sektie1">The main goal of this chapter has been to introduce the most
important concepts in clausal logic, and how it can be used as a reasoning
formalism. Needless to say, a subject like this needs a much more extensive and
precise discussion than has been attempted here, and many important questions
remain. To name a few:</p>

<p class="opsomming" style="margin-left:25.0pt;text-indent:-7.15pt">&bull;<span style="mso-tab-count:1"> </span>what are the limits of expressiveness of
clausal logic, i.e. what can and what cannot be expressed?</p>

<p class="opsomming" style="margin-left:25.0pt;text-indent:-7.15pt">&bull;<span style="mso-tab-count:1"> </span>what are the limits of reasoning with clausal
logic, i.e. what can and what cannot be (efficiently) computed?</p>

<p class="opsomming" style="margin-left:25.0pt;text-indent:-7.15pt">&bull;<span style="mso-tab-count:1"> </span>how are these two limits related: is it for
instance possible to enhance reasoning by limiting expressiveness?</p>

<p class="tekst">In order to start answering such questions, we need to be more
precise in defining what clausal logic is, what expressions in clausal logic
mean, and how we can reason with them. That means that we will have to
introduce some theory in the next chapter. This theory will not only be useful
for a better understanding of Logic Programming, but it will also be the
foundation for most of the topics in Part III (<i style="mso-bidi-font-style:
normal">Advanced reasoning techniques</i>).</p>

<p class="sektie">Another aim of Part I of this book is to teach the skill of
programming in Prolog. For this, theory alone, however important, will not
suffice. Like any programming language, Prolog has a number of built-in
procedures and datastructures that you should know about. Furthermore, there
are of course numerous programming techniques and tricks of the trade, with
which the Prolog programmer should be familiar. These subjects will be
discussed in Chapter 3. Together, Chapters 2 and 3 will provide a solid
foundation for the rest of the book.</p>

</div>

<b style="mso-bidi-font-weight:normal"><span style="font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:
EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes"><br clear="all" style="page-break-before:
right;mso-break-type:section-break">
</span></b>

<div class="WordSection3">

<p id="clausal_logic_and_resolution_theoretical_backgrounds" class="cijfer">2</p>

<h2 id="h_clausal_logic_and_resolution_theoretical_backgrounds">Clausal logic and resolution: <br>
theoretical backgrounds</h2>

<p class="sektie1">In this chapter we develop a more formal view of Logic
Programming by means of a rigorous treatment of clausal logic and resolution
theorem proving<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;theorem proving&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Any such treatment has three parts: syntax<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;syntax: of a
logic&quot; \b <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
semantics<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;semantics: of a logic&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and proof theory<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof theory&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
<i style="mso-bidi-font-style:normal">Syntax</i> defines the logical language
we are using, i.e. the alphabet, different kinds of &lsquo;words&rsquo;, and the allowed
&lsquo;sentences&rsquo;. <i style="mso-bidi-font-style:normal">Semantics</i> defines, in
some formal way, the meaning of words and sentences in the language. As with
most logics, semantics for clausal logic is <i style="mso-bidi-font-style:normal">truth-functional</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;semantics:<i
style='mso-bidi-font-style:normal'>truth-functional</i>&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
i.e. the meaning of a sentence is defined by specifying the conditions under
which it is assigned certain <i style="mso-bidi-font-style:normal">truth value</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;truth value&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i> (in our case: <b style="mso-bidi-font-weight:
normal">true</b> or <b style="mso-bidi-font-weight:normal">false</b>). Finally,
<i style="mso-bidi-font-style:normal">proof theory</i> specifies how we can
obtain new sentences (theorem<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;theorem&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s)
from assumed ones (axiom<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;axiom&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s)
by means of pure symbol manipulation (inference rule<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;inference
rule&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s).</p>

<p class="sektie">Of these three, proof theory is most closely related to Logic
Programming, because answering queries is in fact no different from proving
theorems. In addition to proof theory, we need semantics for deciding whether
the things we prove actually make sense. For instance, we need to be sure that
the truth of the theorems is assured by the truth of the axioms. If our
inference rules guarantee this, they are said to be <i style="mso-bidi-font-style:
normal">sound</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sound</i>ness<i style='mso-bidi-font-style:
normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
But this will not be enough, because sound inference rules can be actually very
weak, and unable to prove anything of interest. We also need to be sure that
the inference rules are powerful enough to eventually prove any possible
theorem: they should be <i style="mso-bidi-font-style:normal">complete</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;complete</i>ness:in logic<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.</p>

<p class="sektie">Concepts like soundness and completeness are called <i style="mso-bidi-font-style:normal">meta-theoretical</i>, since they are not
expressed <b style="mso-bidi-font-weight:normal">in</b> the logic under
discussion, but rather belong to a theory <b style="mso-bidi-font-weight:normal">about</b>
that logic (&lsquo;meta&rsquo; means above)<!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-theory&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Their significance is not merely theoretical, but extends to logic programming
languages like Prolog. For example, if a logic programming language is unsound,
it will give wrong answers to some queries; if it is incomplete, it will give
no answer to some other queries. Ideally, a logic programming language should
be sound and complete; in practice, this will not be the case. For instance, in
the next chapter we will see that Prolog is both unsound and incomplete. This
has been a deliberate design choice: a sound and complete Prolog would be much
less efficient. Nevertheless, any Prolog programmer should know exactly the
circumstances under which Prolog is unsound or incomplete, and avoid these
circumstances in her programs.</p>

<p class="sektie">The structure of this chapter is as follows. We start with a
very simple (propositional) logical language, and enrich this language in two
steps to full clausal logic. For each of these three languages, we discuss syntax,
semantics, proof theory, and meta-theory. We then discuss definite clause
logic, which is the subset of clausal logic used in Prolog. Finally, we relate
clausal logic to Predicate Logic, and show that they are essentially equal in
expressive power.</p>

<h3 id="propositional_clausal_logic">2.1<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Propositional
clausal logic</h3>

<p class="sektie1">Informally, a <i style="mso-bidi-font-style:normal">proposition</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proposition&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is any statement which is either true or
false, such as &lsquo;2 + 2 = 4&rsquo; or &lsquo;the moon is made of green cheese&rsquo;. These are the
building blocks of propositional logic, the weakest form of logic.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal
logic:syntax&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Syntax.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Propositions are abstractly
denoted by <i style="mso-bidi-font-style:normal">atom</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;propositional
clausal logic:<i style='mso-bidi-font-style:normal'>atom</i>&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, which are single words starting with
a lowercase character. For instance, <span style="font-family:Courier">married</span>
is an atom denoting the proposition &lsquo;he/she is married&rsquo;; similarly, <span style="font-family:Courier">man</span> denotes the proposition &lsquo;he is a man&rsquo;.
Using the special symbols &lsquo;<span style="font-family:Courier">:-</span>&rsquo; (<b style="mso-bidi-font-weight:normal">if</b>), &lsquo;<span style="font-family:Courier">;</span>&rsquo;
(<b style="mso-bidi-font-weight:normal">or</b>) and &lsquo;<span style="font-family:
Courier">,</span>&rsquo; (<b style="mso-bidi-font-weight:normal">and</b>), we can
combine atoms to form <i style="mso-bidi-font-style:normal">clauses</i>. For
instance,</p>

<p class="p-el">
	married;bachelor:-man,adult
</p>
<!-- Original text <p class="p-el">married;bachelor:-man,adult</p> -->

<p class="tekst">is a clause<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;clause&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
with intended meaning: &lsquo;somebody is married <b style="mso-bidi-font-weight:
normal">or</b> a bachelor <b style="mso-bidi-font-weight:normal">if</b> he is a
man <b style="mso-bidi-font-weight:normal">and</b> an adult&rsquo;<abar><a style="mso-footnote-id:ftn2" href="#_ftn2" name="_ftnref2" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[2]</span></span><!--[endif]--></span></span></span></a></abar>.
The part to the left of the if-symbol &lsquo;<span style="font-family:Courier">:-</span>&rsquo;
is called the <i style="mso-bidi-font-style:normal">head</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;head</i>:of a clause<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of the clause, and the right part is
called the <i style="mso-bidi-font-style:normal">body</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;body</i> of a clause<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of the clause. The head of a clause is
always a disjunction<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;disjunction&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(<b style="mso-bidi-font-weight:normal">or</b>)
of atoms, and the body of a clause is always a conjunction<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;conjunction&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(<b style="mso-bidi-font-weight:normal">and</b>).
</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.1.</i>
Translate the following statements into clauses, using the atoms <span style="font-family:Courier">person</span>, <span style="font-family:Courier">sad</span>
and <span style="font-family:Courier">happy</span>:<br>
(<i style="mso-bidi-font-style:normal">a</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>persons
are happy or sad;<br>
(<i style="mso-bidi-font-style:normal">b</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>no
person is both happy and sad;<br>
(<i style="mso-bidi-font-style:normal">c</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>sad
persons are not happy;<br>
(<i style="mso-bidi-font-style:normal">d</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>non-happy
persons are sad.</p>

</div>









<p class="sektie">A <i style="mso-bidi-font-style:normal">program</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;program&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a set of clauses, each of them
terminated by a period. The clauses are to be read conjunctively; for example,
the program</p>

<p class="p-el">
woman;man:-human.<br>
human:-woman.<br>
human:-man.</p>

<p class="tekst">has the intended meaning &lsquo;(<b style="mso-bidi-font-weight:normal">if</b>
someone is human <b style="mso-bidi-font-weight:normal">then</b> she/he is a
woman <b style="mso-bidi-font-weight:normal">or</b> a man) <b style="mso-bidi-font-weight:
normal">and</b> (<b style="mso-bidi-font-weight:normal">if</b> someone is a
woman <b style="mso-bidi-font-weight:normal">then</b> she is human) <b style="mso-bidi-font-weight:normal">and</b> (<b style="mso-bidi-font-weight:
normal">if</b> someone is a man <b style="mso-bidi-font-weight:normal">then</b>
he is human)&rsquo;, or, in other words, &lsquo;someone is human <b style="mso-bidi-font-weight:
normal">if and only if</b> she/he is a woman <b style="mso-bidi-font-weight:
normal">or</b> a man&rsquo;.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal
logic:semantics&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Semantics.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>The <i style="mso-bidi-font-style:
normal">Herbrand base</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand base</i>:propositional<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of a program <i style="mso-bidi-font-style:
normal">P</i> is the set of atoms occurring in <i style="mso-bidi-font-style:
normal">P</i>. For the above program, the Herbrand base is {<span style="font-family:Courier">woman</span>, <span style="font-family:Courier">man</span>,
<span style="font-family:Courier">human</span>}. A <i style="mso-bidi-font-style:
normal">Herbrand interpretation</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand interpretation&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(or interpretation for short) for <i style="mso-bidi-font-style:normal">P</i><span style="font-size:9.0pt;
mso-bidi-font-size:10.0pt"> </span>is a mapping from the Herbrand base of <i style="mso-bidi-font-style:normal">P</i> into the set of truth values {<b style="mso-bidi-font-weight:normal">true</b>, <b style="mso-bidi-font-weight:
normal">false</b>}. For example, the mapping {<span style="font-family:Courier">woman</span><span style="font-family:Symbol">&rarr;</span><b style="mso-bidi-font-weight:normal">true</b>,
<span style="font-family:Courier">man</span><span style="font-family:Symbol">&rarr;</span><b style="mso-bidi-font-weight:normal">false</b>, <span style="font-family:Courier">human</span><span style="font-family:Symbol">&rarr;</span><b style="mso-bidi-font-weight:normal">true</b>}
is a Herbrand interpretation for the above program. A Herbrand interpretation
can be viewed as describing a possible state of affairs in the Universe of
Discourse<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Universe of Discourse&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(in this case: &lsquo;she is a woman, she is
not a man, she is human&rsquo;). Since there are only two possible truth values in
the semantics we are considering, we could abbreviate such mappings by listing
only the atoms that are assigned the truth value <b style="mso-bidi-font-weight:
normal">true</b>; by definition, the remaining ones are assigned the truth
value <b style="mso-bidi-font-weight:normal">false</b>. Under this convention,
which we will adopt in this book, a Herbrand interpretation is simply a subset
of the Herbrand base. Thus, the previous Herbrand interpretation would be
represented as {<span style="font-family:Courier">woman</span>, <span style="font-family:Courier">human</span>}. </p>

<p class="sektie">Since a Herbrand interpretation assigns truth values to every
atom in a clause, it also assigns a truth value to the clause as a whole. The
rules for determining the truth value of a clause from the truth values of its
atoms are not so complicated, if you keep in mind that the body of a clause is
a conjunction of atoms, and the head is a disjunction. Consequently, the body
of a clause is <b style="mso-bidi-font-weight:normal">true</b> if every atom in
it is <b style="mso-bidi-font-weight:normal">true</b>, and the head of a clause
is <b style="mso-bidi-font-weight:normal">true</b> if at least one atom in it is
<b style="mso-bidi-font-weight:normal">true</b>. In turn, the truth value of
the clause is determined by the truth values of head and body. There are four
possibilities:</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>the body is <b style="mso-bidi-font-weight:normal">true</b>, and the head is <b style="mso-bidi-font-weight:normal">true</b>;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>the body is <b style="mso-bidi-font-weight:
normal">true</b>, and the head is <b style="mso-bidi-font-weight:normal">false</b>;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iii</i>)<span style="mso-tab-count:1">&nbsp; </span>the body is <b style="mso-bidi-font-weight:
normal">false</b>, and the head is <b style="mso-bidi-font-weight:normal">true</b>;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iv</i>)<span style="mso-tab-count:1">&nbsp; </span>the body is <b style="mso-bidi-font-weight:
normal">false</b>, and the head is <b style="mso-bidi-font-weight:normal">false</b>.</p>

<p class="tekst">The intended meaning of the clause is &lsquo;<b style="mso-bidi-font-weight:
normal">if</b> body <b style="mso-bidi-font-weight:normal">then</b> head&rsquo;,
which is obviously <b style="mso-bidi-font-weight:normal">true</b> in the first
case, and <b style="mso-bidi-font-weight:normal">false</b> in the second case. </p>

<p class="sektie">What about the remaining two cases? They cover statements like
&lsquo;<b style="mso-bidi-font-weight:normal">if</b> the moon is made of green cheese
<b style="mso-bidi-font-weight:normal">then</b> 2 + 2 = 4&rsquo;, in which there is
no connection at all between body and head. One would like to say that such
statements are neither <b style="mso-bidi-font-weight:normal">true</b> nor <b style="mso-bidi-font-weight:normal">false</b>. However, our semantics is not
sophisticated enough to deal with this: it simply insists that clauses should
be assigned a truth value in every possible interpretation. Therefore, we
consider the clause to be <b style="mso-bidi-font-weight:normal">true</b>
whenever its body is <b style="mso-bidi-font-weight:normal">false</b>. It is
not difficult to see that under these truth conditions a clause is equivalent
with the statement &lsquo;head <b style="mso-bidi-font-weight:normal">or not</b>
body&rsquo;. For example, the clause <span style="font-family:Courier">married;bachelor:-man,adult
</span>can also be read as &lsquo;someone is married <b style="mso-bidi-font-weight:
normal">or</b> a bachelor <b style="mso-bidi-font-weight:normal">or</b> <b style="mso-bidi-font-weight:normal">not</b> a man <b style="mso-bidi-font-weight:
normal">or</b> <b style="mso-bidi-font-weight:normal">not</b> an adult&rsquo;. Thus,
a clause is a disjunction of atoms, which are negated if they occur in the body
of the clause. Therefore, the atoms in the body of the clause are often called <i style="mso-bidi-font-style:normal">negative literal</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;negative literal&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, while those in the head of the clause
are called <i style="mso-bidi-font-style:normal">positive literal</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;positive literal&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>.</p>

<p class="sektie">To summarise: a clause is assigned the truth value <b style="mso-bidi-font-weight:normal">true</b> in an interpretation, if and only
if at least one of the following conditions is true: (<i style="mso-bidi-font-style:
normal">a</i>) at least one atom in the body of the clause is <b style="mso-bidi-font-weight:normal">false</b> in the interpretation (cases (<i style="mso-bidi-font-style:normal">iii</i>) and (<i style="mso-bidi-font-style:
normal">iv</i>)), or (<i style="mso-bidi-font-style:normal">b</i>) at least one
atom in the head of the clause is <b style="mso-bidi-font-weight:normal">true</b>
in the interpretation (cases (<i style="mso-bidi-font-style:normal">i</i>) and
(<i style="mso-bidi-font-style:normal">iii</i>)). If a clause is <b style="mso-bidi-font-weight:normal">true</b> in an interpretation, we say that
the interpretation is a <i style="mso-bidi-font-style:normal">model</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;model&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>for the clause. An interpretation is a
model for a program if it is a model for each clause in the program. For
example, the above program has the following models: <span style="font-family:
Symbol">&#8709;</span> (the empty model, assigning <b style="mso-bidi-font-weight:
normal">false</b> to every atom), {<span style="font-family:Courier">woman</span>,
<span style="font-family:Courier">human</span>}, {<span style="font-family:
Courier">man</span>, <span style="font-family:Courier">human</span>}, and {<span style="font-family:Courier">woman</span>, <span style="font-family:Courier">man</span>,
<span style="font-family:Courier">human</span>}. Since there are eight possible
interpretations for a Herbrand base with three atoms, this means that the
program contains enough information to rule out half of these. </p>

<p class="sektie">Adding more clauses to the program means restricting its set of
models. For instance, if we add the clause <span style="font-family:Courier">woman</span>
(a clause with an empty body) to the program, we rule out the first and third
model, which leaves us with the models {<span style="font-family:Courier">woman</span>,
<span style="font-family:Courier">human</span>}, and {<span style="font-family:
Courier">woman</span>, <span style="font-family:Courier">man</span>, <span style="font-family:Courier">human</span>}. Note that in both of these models, <span style="font-family:Courier">human</span> is <b style="mso-bidi-font-weight:
normal">true</b>. We say that <span style="font-family:Courier">human</span> is
a logical consequence of the set of clauses. In general, a clause <i style="mso-bidi-font-style:normal">C</i> is a <i style="mso-bidi-font-style:
normal">logical consequence</i><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;logical consequence&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of a program <i style="mso-bidi-font-style:
normal">P</i> if every model of the program is also a model of the clause; we
write <i style="mso-bidi-font-style:normal">P</i><b style="mso-bidi-font-weight:
normal"> </b><span style="font-family:Extra;mso-hansi-font-family:Extra;
mso-bidi-font-family:&quot;Times New Roman&quot;">=</span><!--[if supportFields]><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman";
display:none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman"'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=&quot; \b </span><![endif]--><!--[if supportFields]><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman";
display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span><i style="mso-bidi-font-style:normal">C</i>.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.2.</i> Given
the program<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">married;bachelor:-man,adult.<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>man.<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>:-bachelor.</span><br>
determine which of the following clauses are logical consequences of this
program:<br>
(<i style="mso-bidi-font-style:normal">a</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">married:-adult</span>;<br>
(<i style="mso-bidi-font-style:normal">b</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">married:-bachelor</span>;<br>
(<i style="mso-bidi-font-style:normal">c</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">bachelor:-man</span>;<br>
(<i style="mso-bidi-font-style:normal">d</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">bachelor:-bachelor</span>.</p>










</div>

<p class="sektie">Of the two remaining models, obviously {<span style="font-family:
Courier">woman</span>, <span style="font-family:Courier">human</span>} is the
intended one; but the program does not yet contain enough information to
distinguish it from the non-intended model {<span style="font-family:Courier">woman</span>,
<span style="font-family:Courier">man</span>, <span style="font-family:Courier">human</span>}.
We can add yet another clause, to make sure that the atom <span style="font-family:Courier">man</span> is mapped to <b style="mso-bidi-font-weight:
normal">false</b>. For instance, we could add </p>

<p class="p-el">:-man </p>

<p class="tekst">(it is not a man) or </p>

<p class="p-el">:-man,woman </p>

<p class="tekst">(nobody is both a man and a woman). However, explicitly stating
everything that is false in the intended model is not always feasible.
Consider, for example, an airline database consulted by travel agencies: we
simply want to say that if a particular flight (i.e., a combination of plane,
origin, destination, date and time) is not listed in the database, then it does
not exist, instead of listing all the dates that a particular plane does <b style="mso-bidi-font-weight:normal">not</b> fly from Amsterdam to London. </p>

<p class="sektie">So, instead of adding clauses until a single model remains, we
want to add a rule to our semantics which tells us which of the several models
is the intended one. The airline example shows us that, in general, we only
want to accept something as <b style="mso-bidi-font-weight:normal">true</b> if
we are really forced to, i.e. if it is <b style="mso-bidi-font-weight:normal">true</b>
in every possible model. This means that we should take the intersection of
every model of a program in order to construct the intended model. In the
example, this is {<span style="font-family:Courier">woman</span>, <span style="font-family:Courier">human</span>}. Note that this model is <i style="mso-bidi-font-style:normal">minimal</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;minimal</i> model<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>in the sense that no subset of it is also
a model. Therefore, this semantics is called a <i style="mso-bidi-font-style:
normal">minimal model semantics</i>. </p>

<p class="sektie">Unfortunately, this approach is only applicable to a restricted
class of programs. Consider the following program:</p>


<p class="p-el">woman;man:-human.<br>
human.</p>

<p class="tekst">This program has three models: {<span style="font-family:Courier">woman</span>,
<span style="font-family:Courier">human</span>}, {<span style="font-family:
Courier">man</span>, <span style="font-family:Courier">human</span>}, and {<span style="font-family:Courier">woman</span>, <span style="font-family:Courier">man</span>,
<span style="font-family:Courier">human</span>}. The intersection of these
models is {<span style="font-family:Courier">human</span>}, but this
interpretation is not a model of the first clause! The program has in fact not
one, but <b style="mso-bidi-font-weight:normal">two</b> minimal models, which
is caused by the fact that the first clause has a disjunctive head. Such a
clause is called <i style="mso-bidi-font-style:normal">indefinite</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;indefinite</i> clause<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
because it does not permit definite conclusions to be drawn. </p>

<p class="sektie">On the other hand, if we would only allow <i style="mso-bidi-font-style:
normal">definite</i> clause<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;definite</i> clause<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s,
i.e. clauses with a single positive literal, minimal models are guaranteed to
be unique. We will deal with definite clauses in section 2.4, because Prolog is
based on definite clause logic. In principle, this means that clauses like <span style="font-family:Courier">woman;man:-human</span> are not expressible in
Prolog. However, such a clause can be transformed into a &lsquo;pseudo-definite&rsquo;
clause by moving one of the literals in the head to the body, extended with an
extra negation. This gives the following two possibilities:</p>



<p class="p-el">woman:-human,not(man).<br>
man:-human,not(woman).</p>

<p class="tekst">In Prolog, we have to choose between these two clauses, which
means that we have only an approximation of the original indefinite clause.
Negation in Prolog is an important subject with many aspects. In Chapter 3, we
will show how Prolog handles negation in the body of clauses. In Chapter 8, we
will discuss particular applications of this kind of negation.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal logic:proof
theory&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Proof theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Recall that a clause <i style="mso-bidi-font-style:normal">C</i> is a logical consequence of a program <i style="mso-bidi-font-style:normal">P</i> (<i style="mso-bidi-font-style:normal">P</i>
<span style="font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:
&quot;Times New Roman&quot;">=</span> <i style="mso-bidi-font-style:normal">C</i>) if
every model of <i style="mso-bidi-font-style:normal">P</i> is a model of <i style="mso-bidi-font-style:normal">C</i>. Checking this condition is, in
general, unfeasible. Therefore, we need a more efficient way of computing
logical consequences, by means of inference rules. If <i style="mso-bidi-font-style:
normal">C</i> can be derived from <i style="mso-bidi-font-style:normal">P</i>
by means of a number of applications of such inference rules, we say that <i style="mso-bidi-font-style:normal">C</i> can be <i style="mso-bidi-font-style:
normal">proved</i> from <i style="mso-bidi-font-style:normal">P</i>. Such
inference rules are purely syntactic, and do not refer to any underlying
semantics.</p>

<p class="sektie">The proof theory for clausal logic consists of a single
inference rule<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inference rule&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>called <i style="mso-bidi-font-style:
normal">resolution</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;resolution&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Resolution is a very powerful inference rule. Consider the following program:</p>

<p class="p-el">married;bachelor:-man,adult.<br>
has_wife:-man,married.</p>

<p class="tekst">This simple program has no less than 26 models, each of which
needs to be considered if we want to check whether a clause is a logical
consequence of it.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.3.</i> Write
down the six Herbrand interpretations that are not models of the program.</p>

</div>

<p class="sektie">The following clause is a logical consequence of this program: </p>

<p class="p-el">has_wife;bachelor:-man,adult </p>

<p class="tekst">By means of resolution, it can be produced in a single step.
This step represents the following line of reasoning: &lsquo;if someone is a man and
an adult, then he is a bachelor or married; but if he is married, he has a
wife; therefore, if someone is a man and an adult, then he is a bachelor or he
has a wife&rsquo;. In this argument, the two clauses in the program are related to
each other by means of the atom <span style="font-family:Courier">married</span>,
which occurs in the head of the first clause (a positive literal<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;positive
literal&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->)
and in the body of the second (a negative literal<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;negative
literal&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->).
The derived clause, which is called the <i style="mso-bidi-font-style:normal">resolvent</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;resolvent&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
consists of all the literals of the two input clauses, except <span style="font-family:Courier">married</span> (the literal <i style="mso-bidi-font-style:
normal">resolved upon</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;literal <i style='mso-bidi-font-style:
normal'>resolved upon</i>&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->).
The negative literal <span style="font-family:Courier">man</span>, which occurs
in both input clauses, appears only once in the derived clause. This process is
depicted in fig. 2.1.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1032" type="#_x0000_t75"
   style='width:272pt;height:59pt'>
   <v:imagedata src="Part%20I_files/image015.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image016.svg" v:shapes="_x0000_i1032"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 2.1.</b> A
  resolution step.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Resolution is most easily understood when applied to definite
clauses. Consider the following program:</p>

<p class="p-el">square:-rectangle,equal_sides.<br>
rectangle:-parallelogram,right_angles.</p>

<p class="tekst">Applying resolution yields the clause</p>

<p class="p-el">square:-parallelogram,right_angles,equal_sides</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
margin;mso-element-top:bottom;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure" style="mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><!--[if gte vml 1]><v:shape
   id="_x0000_i1033" type="#_x0000_t75" style='width:336pt;height:62pt'>
   <v:imagedata src="Part%20I_files/image017.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image018.svg" v:shapes="_x0000_i1033"><!--[endif]--></p>
  </div>
  <p class="caption" style="mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><b style="mso-bidi-font-weight:
  normal">Figure 2.2.</b> Resolution with definite clauses.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="tekst">That is, the atom <span style="font-family:Courier">rectangle</span>
in the body of the first clause is replaced by the body of the second clause
(which has <span style="font-family:Courier">rectangle</span> as its head).
This process is also referred to as <i style="mso-bidi-font-style:normal">unfolding</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unfolding&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>the second clause into the first one
(fig. 2.2).</p>

<p class="sektie">A resolvent resulting from one resolution step can be used as
input for the next. A <i style="mso-bidi-font-style:normal">proof</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>or <i style="mso-bidi-font-style:normal">derivation</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;derivation&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of a clause <i style="mso-bidi-font-style:
normal">C</i> from a program <i style="mso-bidi-font-style:normal">P</i> is a
sequence of clauses such that each clause is either in the program, or the
resolvent of two previous clauses, and the last clause is <i style="mso-bidi-font-style:
normal">C</i>. If there is a proof of <i style="mso-bidi-font-style:normal">C</i>
from <i style="mso-bidi-font-style:normal">P</i>, we write <i style="mso-bidi-font-style:
normal">P</i> <span style="font-family:Extra;mso-hansi-font-family:Extra;
mso-bidi-font-family:&quot;Times New Roman&quot;">|</span><!--[if supportFields]><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman";
display:none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman"'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;|&quot; \b </span><![endif]--><!--[if supportFields]><span
style='font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:"Times New Roman";
display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span><i style="mso-bidi-font-style:normal">C</i>.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.4.</i> Give a
derivation of <span style="font-family:Courier">friendly</span> from the
following program:<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">happy;friendly:-teacher.<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly:-teacher,happy.<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher;wise.<br>
<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span><span style="mso-tab-count:
1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>teacher:-wise.</span></p>
</div>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal
logic:meta-theory&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Meta-theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>It is easy to show that
propositional resolution is <b style="mso-bidi-font-weight:normal">sound</b>:
you have to establish that every model for the two input clauses is a model for
the resolvent<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal
logic:soundness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
In our earlier example, every model of <span style="font-family:Courier">married;bachelor:-man,adult</span>
and <span style="font-family:Courier">has_wife:-man,married</span> must be a
model of <span style="font-family:Courier">has_wife;bachelor:-man,adult</span>.
Now, the literal resolved upon (in this case <span style="font-family:Courier">married</span>)
is either assigned the truth value <b style="mso-bidi-font-weight:normal">true</b>
or <b style="mso-bidi-font-weight:normal">false</b>. In the first case, every
model of <span style="font-family:Courier">has_wife:-man,married</span> is also
a model of <span style="font-family:Courier">has_wife:-man</span>; in the
second case, every model of <span style="font-family:Courier">married;bachelor:-man,adult</span>
is also a model of <span style="font-family:Courier">bachelor:-man,adult</span>.<b style="mso-bidi-font-weight:normal"> </b>In both cases, these models are models
of a subclause of the resolvent, which means that they are also models of the
resolvent itself.</p>

<p class="sektie">In general, proving <b style="mso-bidi-font-weight:normal">completeness</b>
is more complicated than proving soundness<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;propositional
clausal logic:completeness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Still worse, proving completeness of resolution is impossible, because
resolution is not complete at all! For instance, consider the clause <span style="font-family:Courier">a:-a</span>. This clause is a so-called <i style="mso-bidi-font-style:normal">tautology</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;tautology&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
it is true under any interpretation. Therefore, any model of an arbitrary
program <i style="mso-bidi-font-style:normal">P</i> is a model for it, and thus
<i style="mso-bidi-font-style:normal">P</i> <span style="font-family:Extra;
mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;">=</span> <span style="font-family:Courier">a:-a</span> for any program <i style="mso-bidi-font-style:
normal">P</i>. If resolution were complete, it would be possible to derive the
clause <span style="font-family:Courier">a:-a</span> from some program <i style="mso-bidi-font-style:normal">P</i> in which the literal <span style="font-family:Courier">a</span> doesn&rsquo;t even occur! It is clear that
resolution is unable to do this. </p>

<p class="sektie">However, this is not necessarily bad, because although
tautologies follow from any set of clauses, they are not very interesting.
Resolution makes it possible to guide the inference process, by implementing
the question &lsquo;is <i style="mso-bidi-font-style:normal">C</i> a logical
consequence of <i style="mso-bidi-font-style:normal">P</i>?&rsquo; rather than &lsquo;what
are the logical consequences of <i style="mso-bidi-font-style:normal">P</i>?&rsquo;.
We will see that, although resolution is unable to generate every logical
consequence of a set of clauses, it is complete in the sense that resolution
can always determine whether a specific clause is a logical consequence of a
set of clauses.</p>

<p class="sektie">The idea is analogous to a proof technique in mathematics
called &lsquo;reduction to the absurd<!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;reduction to the absurd&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->&rsquo;.
Suppose for the moment that <i style="mso-bidi-font-style:normal">C</i>
consists of a single positive literal <span style="font-family:Courier">a</span>;
we want to know whether <i style="mso-bidi-font-style:normal">P</i> <span style="font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;">=</span>
<span style="font-family:Courier">a</span>, i.e. whether every model of <i style="mso-bidi-font-style:normal">P</i> is also a model of <span style="font-family:Courier">a</span>. It is easily checked that an
interpretation is a model of <span style="font-family:Courier">a</span> if, and
only if, it is <b style="mso-bidi-font-weight:normal">not</b> a model of <span style="font-family:Courier">:-a</span>. Therefore, every model of <i style="mso-bidi-font-style:normal">P</i> is a model of <span style="font-family:
Courier">a</span> if, and only if, there is no interpretation which is a model
of both <span style="font-family:Courier">:-a</span> and <i style="mso-bidi-font-style:
normal">P</i>. In other words, <span style="font-family:Courier">a</span> is a
logical consequence of <i style="mso-bidi-font-style:normal">P</i> if, and only
if, <span style="font-family:Courier">:-a</span> and <i style="mso-bidi-font-style:
normal">P</i> are mutually <i style="mso-bidi-font-style:normal">inconsistent</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;inconsistent&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(don&rsquo;t have a common model). So, checking
whether <i style="mso-bidi-font-style:normal">P</i> <span style="font-family:
Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;">=</span>
<span style="font-family:Courier">a</span> is equivalent to checking whether <i style="mso-bidi-font-style:normal">P</i> <span style="font-family:Symbol">&cup;</span>{<span style="font-family:Courier">:-a</span>} is inconsistent. </p>

<p class="sektie">Resolution provides a way to check this condition. Note that,
since an inconsistent set of clauses doesn&rsquo;t have a model, it trivially
satisfies the condition that any model of it is a model of any other clause;
therefore, an inconsistent set of clauses has every possible clause as its
logical consequence. In particular, the absurd or <i style="mso-bidi-font-style:
normal">empty</i> clause<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;empty</i> clause<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
denoted by <span style="font-family:Extra;mso-hansi-font-family:Extra;
mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style='font-family:Extra;mso-hansi-font-family:Extra;
mso-bidi-font-family:"Times New Roman"'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;<span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span>&quot; \b </span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><abar><a style="mso-footnote-id:ftn3" href="#_ftn3" name="_ftnref3" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[3]</span></span><!--[endif]--></span></span></span></a></abar>,
is a logical consequence of an inconsistent set of clauses. Conversely, if <span style="font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><br>
<br>
<span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>
is a logical consequence of a set of clauses, we know it must be inconsistent.
Now, resolution is complete in the sense that <i style="mso-bidi-font-style:
normal">if P set of clauses is inconsistent, it is always possible to derive </i><i style="mso-bidi-font-style:normal"><span style="font-family:Extra;mso-hansi-font-family:
Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span> by resolution</i>. Since
resolution is sound, we already know that if we can derive <span style="font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>
then the input clauses must be inconsistent. So we conclude: <span style="font-family:Courier">a</span> is a logical consequence of <i style="mso-bidi-font-style:normal">P</i> if, and only if, the empty clause can
be deduced by resolution from <i style="mso-bidi-font-style:normal">P</i>
augmented with <span style="font-family:Courier">:-a</span>.<b style="mso-bidi-font-weight:normal"> </b>This process is called <i style="mso-bidi-font-style:normal">proof by refutation</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof :by refutation&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and resolution is called <i style="mso-bidi-font-style:normal">refutation
complete</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;refutation
complete&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.</p>

<p class="sektie">This proof method can be generalised to the case where <i style="mso-bidi-font-style:normal">B</i> is not a single atom. For instance,
let us check by resolution that <span style="font-family:Courier">a:-a</span>
is a tautology, i.e. a logical consequence of any set of clauses. Logically
speaking, this clause is equivalent to &lsquo;<span style="font-family:Courier">a</span><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt"> </span><b style="mso-bidi-font-weight:
normal">or not</b> <span style="font-family:Courier">a</span>&rsquo;, the negation of
which is &lsquo;<b style="mso-bidi-font-weight:normal">not</b> <span style="font-family:Courier">a</span> <b style="mso-bidi-font-weight:normal">and</b>
<span style="font-family:Courier">a</span>&rsquo;, which is represented by two
separate clauses <span style="font-family:Courier">:-a</span> and <span style="font-family:Courier">a</span>. Since we can derive the empty clause from
these two clauses in a single resolution step without using any other clauses,
we have in fact proved that <span style="font-family:Courier">a:-a</span> is a
logical consequence of an empty set of clauses, hence a tautology.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.5.</i> Prove
by refutation that <span style="font-family:Courier">friendly:-has_friends</span>
is a logical consequence of the following clauses: <br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">happy:-has_friends.<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly:-happy.</span></p>

</div>

<p class="sektie"><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;propositional clausal
logic:decidability&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->Finally,
we mention that although resolution can always be used to prove inconsistency
of a set of clauses it is not always fit to prove the opposite, i.e.
consistency of a set of clauses. For instance, <span style="font-family:Courier">a</span>
is not a logical consequence of <span style="font-family:Courier">a:-a</span>;
yet, if we try to prove the inconsistency of <span style="font-family:Courier">:-a</span>
and <span style="font-family:Courier">a:-a</span> (which should fail) we can go
on applying resolution forever! The reason, of course, is that there is a loop
in the system: applying resolution to <span style="font-family:Courier">:-a</span>
and <span style="font-family:Courier">a:-a</span> again yields <span style="font-family:Courier">:-a</span>. In this simple case it is easy to check
for loops: just maintain a list of previously derived clauses, and do not
proceed with clauses that have been derived previously. </p>

<p class="sektie">However, as we will see, this is not possible in the general
case of full clausal logic, which is <i style="mso-bidi-font-style:normal">semi-decidable</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;semi-decidable&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>with respect to the question &lsquo;is <i style="mso-bidi-font-style:normal">B</i> a logical consequence of <i style="mso-bidi-font-style:normal">A</i>&rsquo;: there is an algorithm which derives,
in finite time, a proof if one exists, but there is no algorithm which, for any
<i style="mso-bidi-font-style:normal">A</i> and <i style="mso-bidi-font-style:
normal">B</i>, halts and returns &lsquo;no&rsquo; if no proof exists. The reason for this
is that interpretations for full clausal logic are in general infinite. As a
consequence, some Prolog programs may loop forever (just like some Pascal
programs). One might suggest that it should be possible to check, just by
examining the source code, whether a program is going to loop or not, but, as
Alan Turing showed, this is, in general, impossible (the Halting Problem). That
is, you can write programs for checking termination of programs, but for any
such termination checking program you can write a program on which it will not
terminate itself!</p>

<h3 id="relational_clausal_logic">2.2<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Relational
clausal logic</h3>

<p class="sektie1">Propositional clausal logic is rather coarse-grained, because
it takes propositions (i.e. anything that can be assigned a truth value) as its
basic building blocks. For example, it is not possible to formulate the
following argument in propositional logic:</p>

<p class="opsomming" style="margin-top:3.0pt">Peter likes all his students</p>

<p class="opsomming">Maria is one of Peter&rsquo;s students</p>

<p class="opsomming" style="margin-bottom:3.0pt">Therefore, Peter likes Maria</p>

<p class="tekst">In order to formalise this type of reasoning, we need to talk
about individuals like Peter and Maria, sets of individuals like Peter&rsquo;s
students, and relations between individuals, such as &lsquo;likes&rsquo;. This refinement
of propositional clausal logic leads us into relational clausal logic.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:syntax&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Syntax.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Individual names are called <i style="mso-bidi-font-style:normal">constant</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;constant&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>; we follow the Prolog convention of
writing them as single words starting with a lowercase character (or as
arbitrary strings enclosed in single quotes, like <span style="font-family:
Courier">'this is a constant'</span>). Arbitrary individuals are denoted by <i style="mso-bidi-font-style:normal">variable</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, which are single words starting with
an uppercase character. Jointly, constants and variables are denoted as <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal logic:term&quot;
\b <![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:
normal">terms</i>. A <i style="mso-bidi-font-style:normal">ground</i> term<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ground</i> term<i style='mso-bidi-font-style:
normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a term without variables<abar><a style="mso-footnote-id:ftn4" href="#_ftn4" name="_ftnref4" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[4]</span></span><!--[endif]--></span></span></span></a></abar>.</p>

<p class="sektie">Relations between individuals are abstractly denoted by <i style="mso-bidi-font-style:normal">predicate</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;predicate&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i> (which follow the same notational
conventions as constants). An <i style="mso-bidi-font-style:normal">atom</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;atom&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a predicate followed by a number of
terms, enclosed in brackets and separated by commas, e.g. <span style="font-family:Courier">likes(peter,maria)</span>. The terms between
brackets are called the <i style="mso-bidi-font-style:normal">arguments</i> of
the predicate<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;argument:of a predicate&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and the number of arguments is the predicate&rsquo;s <i style="mso-bidi-font-style:
normal">arity</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;arity</i>:of a predicate<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
The arity of a predicate is assumed to be fixed, and predicates with the same
name but different arity are assumed to be different. A <i style="mso-bidi-font-style:
normal">ground </i>atom<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ground </i>atom<i style='mso-bidi-font-style:
normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is an atom without variables.</p>

<p class="sektie">All the remaining definitions pertaining to the syntax of
propositional clausal logic, in particular those of literal, clause and
program, stay the same. So, the following clauses are meant to represent the
above statements:</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.1" style="display: block;"
query-text="?- likes(peter,S)."
>
likes(peter,S):-student_of(S,peter).
student_of(maria,peter).
</pre>
<pre class="swish query" source-id="swish.2.2.1">
?- likes(peter,maria).
</pre>
<p class="tekst">The intended meaning of these clauses are, respectively, &lsquo;<b style="mso-bidi-font-weight:normal">if</b> <i style="mso-bidi-font-style:normal">S</i>
is a student of Peter <b style="mso-bidi-font-weight:normal">then</b> Peter
likes <i style="mso-bidi-font-style:normal">S</i>&rsquo;, &lsquo;Maria is a student of
Peter&rsquo;, and &lsquo;Peter likes Maria&rsquo;. Clearly, we want our logic to be such that the
third clause follows logically from the first two, and we want to be able to
prove this by resolution. Therefore, we must extend the semantics and proof
theory in order to deal with variables.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:semantics&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Semantics.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>The <i style="mso-bidi-font-style:
normal">Herbrand universe</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal logic:<i
style='mso-bidi-font-style:normal'>Herbrand universe</i>&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of a program <i style="mso-bidi-font-style:
normal">P</i> is the set of ground terms (i.e. constants) occurring in it. For
the above program, the Herbrand universe is {<span style="font-family:Courier">peter</span>,
<span style="font-family:Courier">maria</span>}. The Herbrand universe is the
set of all individuals we are talking about in our clauses. The <i style="mso-bidi-font-style:normal">Herbrand base</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand base&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of <i style="mso-bidi-font-style:normal">P</i>
is the set of <b style="mso-bidi-font-weight:normal">ground</b> atoms that can
be constructed using the predicates in <i style="mso-bidi-font-style:normal">P</i>
and the ground terms in the Herbrand universe. This set represents all the
things we can say about the individuals in the Herbrand universe. </p>

<p class="sektie">The Herbrand base of the above program is</p>

<p class="p-el" style="margin-left:28.0pt;text-indent:-11.0pt"><span style="font-family:Times">{<span style="mso-tab-count:1">&nbsp; </span></span>likes(peter,peter)<span style="font-family:Times">, </span>likes(peter,maria)<span style="font-family:
Times">, <br>
</span>likes(maria,peter)<span style="font-family:Times">, </span>likes(maria,maria)<span style="font-family:Times">, <br>
</span>student_of(peter,peter)<span style="font-family:Times">, </span>student_of(peter,maria)<span style="font-family:Times">, <br>
</span>student_of(maria,peter)<span style="font-family:Times">, </span>student_of(maria,maria)<span style="font-family:Times"> }</span></p>

<p class="tekst">As before, a <i style="mso-bidi-font-style:normal">Herbrand
interpretation</i> is the subset of the Herbrand base whose elements are
assigned the truth value <b style="mso-bidi-font-weight:normal">true</b>. For
instance, </p>

<p class="p-el"><span style="font-family:Times">{</span>likes(peter,maria)<span style="font-family:Times">, </span>student_of(maria,peter)<span style="font-family:Times">} </span></p>

<p class="tekst">is an interpretation of the above program.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Logical variable<!--[if supportFields]><span style='display:
  none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;variable:in logic programs&quot; <![endif]--><!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s</p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Variables in clausal logic are very similar to variables in
  mathematical formulas: they are placeholders that can be substituted by
  arbitrary ground terms from the Herbrand universe. It is very important to
  notice that <i style="mso-bidi-font-style:normal">logical variables are
  global within a clause</i> (i.e. if the variable occurs at several positions
  within a clause, it should be substituted everywhere by the same term), <i style="mso-bidi-font-style:normal">but not within a program</i>. This can be
  clearly seen from the semantics of relational clausal logic, where grounding
  substitutions are applied to clauses rather than programs. As a consequence,
  variables in two different clauses are distinct by definition, <br>
  even if they have the same name. It will sometimes be useful to rename the
  variables in clauses, such that no two clauses share a variable; this is
  called <i style="mso-bidi-font-style:normal">standardising</i><!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><i style='mso-bidi-font-style:normal'><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;standardising</i> apart<i
  style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>the clauses <i style="mso-bidi-font-style:
  normal">apart</i>.</p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Clearly, we want this interpretation to be a model of the
program, but now we have to deal with the variables in the program. A <i style="mso-bidi-font-style:normal">substitution</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;substitution&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a mapping from variables to terms. For
example, {<span style="font-family:Courier">S</span><span style="font-family:
Symbol">&rarr;</span><span style="font-family:Courier">maria</span>} and {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">X</span>} are substitutions. A substitution can be <i style="mso-bidi-font-style:normal">applied</i> to a clause<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;substitution:application of&quot;
\b <![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]-->, which means that all
occurrences of a variable occurring on the lefthand side in a substitution are
replaced by the term on the righthand side. For instance, if <i style="mso-bidi-font-style:normal">C</i> is the clause</p>

<p class="p-el">likes(peter,S):-student_of(S,peter)</p>

<p class="tekst">then the above substitutions yield the clauses</p>

<p class="p-el">likes(peter,maria):-student_of(maria,peter)</p>

<p class="pi-laatst">likes(peter,X):-student_of(X,peter)</p>

<p class="tekst">Notice that the first clause is ground; it is said to be a <i style="mso-bidi-font-style:normal">ground instance</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ground instance&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of <i style="mso-bidi-font-style:normal">C</i>,
and the substitution {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>}
is called a <i style="mso-bidi-font-style:normal">grounding substitution</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;grounding substitution&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;substitution:grounding&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
All the atoms in a ground clause occur in the Herbrand base, so reasoning with
ground clauses is just like reasoning with propositional clauses. An
interpretation is a model for a non-ground clause if it is a model for every
ground instance of the clause. Thus, in order to show that </p>

<p class="p-el"><i style="mso-bidi-font-style:normal"><span style="font-family:
Times">M</span></i><span style="font-family:Times"> = {</span>likes(peter,maria)<span style="font-family:Times">, </span>student_of(maria,peter)<span style="font-family:Times">} <o:p></o:p></span></p>

<p class="tekst">is a model of the clause <i style="mso-bidi-font-style:normal">C</i>
above, we have to construct the set of the ground instances of <i style="mso-bidi-font-style:normal">C</i> over the Herbrand universe {<span style="font-family:Courier">peter</span>, <span style="font-family:Courier">maria</span>},
which is</p>

<p class="p-el" style="margin-left:24.0pt;text-indent:-7.0pt"><span style="font-family:Times">{ </span>likes(peter,maria):-student_of(maria,peter)<span style="font-family:Times">, </span><br>
likes(peter,peter):-student_of(peter,peter)<span style="font-family:Times"> }</span></p>

<p class="tekst">and show that <i style="mso-bidi-font-style:normal">M</i> is a
model of every element of this set.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.6.</i> How
many models does <i style="mso-bidi-font-style:normal">C</i> have over the
Herbrand universe <br>
{<span style="font-family:Courier">peter</span>, <span style="font-family:Courier">maria</span>}?
</p>
</div>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal logic:proof
theory&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Proof theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Because reasoning with ground
clauses is just like reasoning with propositional clauses, a naive proof method
in relational clausal logic would apply grounding substitutions to every clause
in the program before applying resolution. Such a method is naive, because a
program has many different grounding substitutions, most of which do not lead
to a resolution proof. For instance, if the Herbrand universe contains four
constants, then a clause with two distinct variables has 16 different grounding
substitutions, and a program consisting of three such clauses has 4096
different grounding substitutions.</p>

<p class="sektie">Instead of applying arbitrary grounding substitutions before
trying to apply resolution, we will derive the required substitutions from the
clauses themselves. Recall that in order to apply propositional resolution, the
literal resolved upon should occur in both input clauses (positive in one
clause and negative in the other). In relational clausal logic, atoms can
contain variables. Therefore, we do not require that exactly the same atom
occurs in both clauses; rather, we require that there is a pair of atoms <i style="mso-bidi-font-style:normal">which can be made equal by substituting
terms for variables</i>. For instance, let <i style="mso-bidi-font-style:normal">P</i>
be the following program:</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.2" style="display: block;">
likes(peter,S):-student_of(S,peter).
student_of(maria,T):-follows(maria,C),teaches(T,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">The second clause is intended to mean: &lsquo;Maria is a student of
any teacher who teaches a course she follows&rsquo;. From these two clauses we should
be able to prove that &lsquo;Peter likes Maria <b style="mso-bidi-font-weight:normal">if</b>
Maria follows a course taught by Peter&rsquo;. This means that we want to resolve the
two clauses on the <span style="font-family:Courier">student_of</span>
literals. </p>

<p class="sektie">The two atoms </p>
<pre class="swish query" source-id="swish.2.2.2">?- student_of(S,peter). </pre> 
<p class="sektie"> and </p>
<pre class="swish query" source-id="swish.2.2.2">?- student_of(maria,T). </pre> 
<p class="sektie"> can be made equal by replacing <span style="font-family:Courier">S</span> by <span style="font-family:Courier">maria</span> and <span style="font-family:Courier">T</span>
by <span style="font-family:Courier">peter</span>, by means of the substitution
{<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>, <span style="font-family:Courier">T</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>}.
This process is called <i style="mso-bidi-font-style:normal">unification</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unification&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and the substitution is called a <i style="mso-bidi-font-style:normal">unifier</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unifier&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Applying this substitution yields the following two clauses:</p>

<p class="p-el">likes(peter,maria):-student_of(maria,peter).<br>
student_of(maria,peter):-follows(maria,C), <br>
<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>teaches(peter,C).</p>

<p class="tekst">(Note that the second clause is not ground.) We can now
construct the resolvent in the usual way, by dropping the literal resolved upon
and combining the remaining literals, which yields the required clause</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.3" style="display: block;">
likes(peter,maria):-follows(maria,C),teaches(peter,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<div style="mso-element:frame;mso-element-frame-hspace:0cm;mso-element-frame-vspace:
0cm;mso-element-wrap:auto;mso-element-anchor-vertical:page;mso-element-anchor-horizontal:
margin;mso-element-top:123.95pt;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:0cm;padding-right:0cm;
  padding-bottom:0cm;padding-left:0cm">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

   <p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-frame-hspace:0cm;
  mso-element-frame-vspace:0cm;mso-element-wrap:auto;mso-element-anchor-vertical:
  page;mso-element-anchor-horizontal:margin;mso-element-top:123.95pt;
  mso-height-rule:exactly"><i style="mso-bidi-font-style:normal">Exercise 2.7</i>.
  Write a clause expressing that Peter teaches all the first-year courses, and
  apply resolution to this clause and the above resolvent.</p> 
  </div>
  </td>
 </tr>
</tbody></table>
</div>

<p class="sektie">Consider the following two-clause program <i style="mso-bidi-font-style:
normal">P</i><span style="font-family:Symbol">&prime;</span>:</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.4" style="display: block;">
likes(peter,S):-student_of(S,peter).
student_of(X,T):-follows(X,C),teaches(T,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">which differs from the previous program <i style="mso-bidi-font-style:
normal">P</i> in that the constant <span style="font-family:Courier">maria</span>
in the second clause has been replaced by a variable. Since this generalises
the applicability of this clause from Maria to any of Peter&rsquo;s students, it
follows that any model for <i style="mso-bidi-font-style:normal">P</i><span style="font-family:Symbol">&prime;</span> over a Herbrand universe including <span style="font-family:Courier">maria</span> is also a model for <i style="mso-bidi-font-style:normal">P</i>, and therefore <i style="mso-bidi-font-style:
normal">P</i><span style="font-family:Symbol">&prime;</span> <span style="font-family:
Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;">=</span>
<i style="mso-bidi-font-style:normal">P</i>. In particular, this means that all
the logical consequences of <i style="mso-bidi-font-style:normal">P</i><span style="font-family:Symbol">&prime;</span> are also logical consequences of <i style="mso-bidi-font-style:normal">P</i>. For instance, we can again derive the
clause </p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.5" style="display: block;">
likes(peter,maria):-follows(maria,C),teaches(peter,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">from <i style="mso-bidi-font-style:normal">P</i><span style="font-family:Symbol">&prime;</span> by means of the unifier {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>, <span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>,
<span style="font-family:Courier">T</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>}.</p>

<p class="sektie">Unifiers are not necessarily grounding substitutions: the
substitution {<span style="font-family:Courier">X</span><span style="font-family:
Symbol">&rarr;</span><span style="font-family:Courier">S</span>, <span style="font-family:Courier">T</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>} also unifies the two <span style="font-family:Courier">student_of</span> literals, and the two clauses
then resolve to</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.6" style="display: block;">
likes(peter,S):-follows(S,C),teaches(peter,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">The first unifier replaces more variables by terms than strictly
necessary, while the second contains only those substitutions that are needed
to unify the two atoms in the input clauses. As a result, the first resolvent
is a special case of the second resolvent, that can be obtained by means of the
additional substitution {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>}.
Therefore, the second resolvent is said to be <i style="mso-bidi-font-style:
normal">more general</i> than the first<abar><a style="mso-footnote-id:ftn5" href="#_ftn5" name="_ftnref5" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:
footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:
&quot;Times New Roman&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:
EN-GB;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes">[5]</span></span><!--[endif]--></span></span></span></a></abar><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;generality of
clauses&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Likewise, the second unifier is called a more general unifier than the first. </p>

<p class="sektie">As it were, more general resolvents summarise a lot of less
general ones. It therefore makes sense to derive only those resolvents that are
as general as possible, when applying resolution to clauses with variables.
This means that we are only interested in a <i style="mso-bidi-font-style:normal">most
general unifier</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;most general unifier&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unifier:most general&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(mgu<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;mgu&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->)
of two literals. Such an mgu, if it exists, is always unique, apart from an
arbitrary renaming of variables (e.g. we could decide to keep the variable <span style="font-family:Courier">X</span>, and replace <span style="font-family:
Courier">S</span> by <span style="font-family:Courier">X</span>). If a unifier
does not exist, we say that the two atoms are not unifiable. For instance, the
atoms <span style="font-family:Courier">student_of(maria,peter)</span> and <span style="font-family:Courier">student_of(S,maria)</span> are not unifiable.</p>

<p class="sektie">As we have seen before, the actual proof method in clausal
logic is proof by refutation<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof: by refutation&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
If we succeed in deriving the empty clause, then we have demonstrated that the
set of clauses is inconsistent <i style="mso-bidi-font-style:normal">under the
substitutions that are needed for unification of literals</i>. For instance,
consider the program</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.7" style="display: block;">
likes(peter,S):-student_of(S,peter).
student_of(S,T):-follows(S,C),teaches(T,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">If we want to find out if there is anyone whom Peter likes, we
add to the program the negation of this statement, i.e. &lsquo;Peter likes nobody&rsquo; or
<span style="font-family:Courier">:-likes(peter,N)</span>; this clause is
called a <i style="mso-bidi-font-style:normal">query</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;query&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>or a <i style="mso-bidi-font-style:normal">goal</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;goal&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
We then try to refute this query by finding an inconsistency by means of
resolution. A refutation proof is given in fig. 2.3. In this figure, which is
called a <i style="mso-bidi-font-style:normal">proof tree</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;proof tree&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
two clauses on a row are input clauses for a resolution step, and they are
connected by lines to their resolvent, which is then again an input clause for
a resolution step, together with another program clause. The mgu&rsquo;s are also
shown. Since the empty clause is derived, the query is indeed refuted, but only
under the substitution {<span style="font-family:Courier">N</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>},
which constitutes the <i style="mso-bidi-font-style:normal">answer</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;answer</i> to a query<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>to the query. </p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1034" type="#_x0000_t75"
   style='width:327pt;height:147pt'>
   <v:imagedata src="Part%20I_files/image019.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image020.svg" v:shapes="_x0000_i1034"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 2.3.</b> A
  refutation proof which finds someone whom Peter likes.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">In general, a query can have several answers. For instance,
suppose that Peter does not only like his students, but also the people his
students like (and the people those people like, and &hellip;):</p>

<pre class="source swish" data-variant-id="group-1" id="swish.2.2.8" style="display: block;">
likes(peter,S):-student_of(S,peter).
likes(peter,Y):-likes(peter,X),likes(X,Y),!.
likes(maria,paul).
student_of(S,T):-follows(S,C),teaches(T,C).
teaches(peter,ai_techniques).
follows(maria,ai_techniques).
</pre>

<p class="tekst">The query</p> 
<pre class="swish query" source-id="swish.2.2.3 swish.2.2.4 swish.2.2.5 swish.2.2.6 swish.2.2.7 swish.2.2.8">?- likes(peter,N).</pre>
<p class="tekst">will now have two answers.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.8</i>. Draw
the proof tree for the answer {<span style="font-family:Courier">N</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">paul</span>}.</p>

</div>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:meta-theory&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Meta-theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>As with propositional
resolution, relational resolution is sound<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:soundness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(i.e. it always produces logical
consequences of the input clauses), refutation complete (i.e. it always detects
an inconsistency in a set of clauses), but not complete<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:completeness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(i.e. it does not always generate every
logical consequence of the input clauses). An important characteristic of relational
clausal logic is that the Herbrand universe (the set of individuals we can
reason about) is always finite. Consequently, models are finite as well, and
there are a finite number of different models for any program. This means that,
in principle, we could answer the question &lsquo;is <i style="mso-bidi-font-style:
normal">C</i> a logical consequence of <i style="mso-bidi-font-style:normal">P</i>?&rsquo;
by enumerating all the models of <i style="mso-bidi-font-style:normal">P</i>,
and checking whether they are also models of <i style="mso-bidi-font-style:
normal">C</i>. The finiteness of the Herbrand universe will ensure that this
procedure always terminates. This demonstrates that relational clausal logic is
decidable, and therefore it is (in principle) possible to prevent resolution
from looping if no more answers can be found<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;relational clausal
logic:decidability&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
As we will see in the next section, this does not hold for full clausal logic.</p>

<h3 id="full_clausal_logic">2.3<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Full clausal
logic</h3>

<p class="sektie1">Relational logic extends propositional logic by means of the
logical variable, which enables us to talk about arbitrary un-named
individuals. However, consider the following statement:</p>

<p class="sektie" style="margin-top:3.0pt;margin-right:0cm;margin-bottom:3.0pt;
margin-left:0cm">Everybody loves somebody.</p>

<p class="tekst">The only way to express this statement in relational clausal
logic, is by explicitly listing every pair of persons such that the first loves
the second, e.g.</p>

<p class="p-el">
loves(peter,peter).<br/>
loves(anna,paul).<br/>
loves(paul,anna).<br/>
</p>

<p class="tekst">First of all, this is not a precise translation of the above
statement into logic, because it is too explicit (e.g. the fact that Peter
loves himself does not follow from the original statement). Secondly, this
translation works only for <i style="mso-bidi-font-style:normal">finite</i>
domains, while the original statement also allows infinite domains. Many
interesting domains are infinite, such as the set of natural numbers. Full
clausal logic allows us to reason about infinite domains by introducing more
complex terms besides constants and variables. The above statement translates
into full clausal logic as</p>

<p class="p-el">loves(X,person_loved_by(X))</p>

<p class="tekst">The fact <span style="font-family:Courier">loves(peter,person_loved_by(peter))</span>
is a logical consequence of this clause. Since we know that everybody loves
somebody, there must exist someone whom Peter loves. We have given this person
the <i style="mso-bidi-font-style:normal">abstract name</i> </p>

<p class="p-el">person_loved_by(peter) </p>

<p class="tekst">without explicitly stating whom it is that Peter loves. As we
will see, this way of composing complex names from simple names also gives us
the possibility to reflect the structure of the domain in our logical formulas.
<span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;position:relative;
top:-3.0pt;mso-text-raise:3.0pt"><o:p></o:p></span></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.9</i>.
Translate to clausal logic:<br>
(<i style="mso-bidi-font-style:normal">a</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>every
mouse has a tail;<br>
(<i style="mso-bidi-font-style:normal">b</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>somebody
loves everybody;<br>
(<i style="mso-bidi-font-style:normal">c</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span>every
two numbers have a maximum.</p>
</div>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal logic:syntax&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Syntax.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>A <i style="mso-bidi-font-style:
normal">term</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;term&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is either simple or complex. Constants
and variables are <i style="mso-bidi-font-style:normal">simple term</i><!--[if supportFields]><i
style='mso-bidi-font-style:normal'><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;simple term&quot; \b </i><![endif]--><!--[if supportFields]><i
style='mso-bidi-font-style:normal'><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span></i><![endif]--><i style="mso-bidi-font-style:normal">s</i>. A <i style="mso-bidi-font-style:normal">complex
term</i><!--[if supportFields]><i style='mso-bidi-font-style:normal'><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;complex term&quot;
\b </i><![endif]--><!--[if supportFields]><i style='mso-bidi-font-style:normal'><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span></i><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a functor (which follows the same
notational conventions as constants and predicates) followed by a number of
terms, enclosed in brackets and separated by commas, e.g. <span style="font-family:Courier">eldest_child_of(anna,paul)</span>. The terms
between brackets are called the <i style="mso-bidi-font-style:normal">argument</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;argument</i>:of a functor<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i> of the functor, and the number of
arguments is the functor&rsquo;s <i style="mso-bidi-font-style:normal">arity</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;arity</i>:of a functor<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Again, a <i style="mso-bidi-font-style:normal">ground</i> term<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;ground</i> term<i style='mso-bidi-font-style:
normal'>&quot; </i><![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a term without variables. All the
other definitions (atom, clause, literal, program) are the same as for
relational clausal logic.</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal logic:semantics&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Semantics.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Although there is no <b style="mso-bidi-font-weight:normal">syntactic</b> difference in full clausal
logic between terms and atoms, their <b style="mso-bidi-font-weight:normal">meaning</b>
and use is totally different, a fact which should be adequately reflected in
the semantics. A term always denotes an individual from the domain, while an
atom denotes a proposition about individuals, which can get a truth value.
Consequently, we must change the definition of the Herbrand universe in order
to accomodate for complex terms: given a program <i style="mso-bidi-font-style:
normal">P</i>, the <i style="mso-bidi-font-style:normal">Herbrand universe</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand universe&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is the set of ground terms that can be
constructed from the constants and functors in <i style="mso-bidi-font-style:
normal">P</i> (if <i style="mso-bidi-font-style:normal">P</i> contains no
constants, choose an arbitrary one). For instance, let <i style="mso-bidi-font-style:
normal">P</i> be the program</p>
<p class="p-el">
plus(0,X,X).<br/>
plus(s(X),Y,s(Z)):-plus(X,Y,Z).<br/>
</p>

<p class="tekst">then the Herbrand universe of <i style="mso-bidi-font-style:
normal">P</i> is {<span style="font-family:Courier">0</span>, <span style="font-family:Courier">s(0)</span>, <span style="font-family:Courier">s(s(0))</span>,
<span style="font-family:Courier">s(s(s(0)))</span>, &hellip;}. Thus, as soon as a
program contains a functor, the Herbrand universe (the set of individuals we
can reason about) is an infinite set.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.10</i>.
Determine the Herbrand universe of the following program:<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">length([],0).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>length([X|Y],s(L)):-length(Y,L).<br>
</span>(Hint: recall that <span style="font-family:Courier">[]</span> is a constant,
and that <span style="font-family:Courier">[X|Y]</span> is an alternative
notation for the complex term <span style="font-family:Courier">.(X,Y)</span>
with binary functor &lsquo;<span style="font-family:Courier">.</span>&rsquo;!)</p>

</div>

<p class="sektie">The <i style="mso-bidi-font-style:normal">Herbrand base</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand base&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of <i style="mso-bidi-font-style:normal">P</i>
remains the set of ground atoms that can be constructed using the predicates in
<i style="mso-bidi-font-style:normal">P</i> and the ground terms in the
Herbrand universe. For the above program, the Herbrand base is </p>

<p class="p-el" style="margin-left:21.0pt;text-indent:-4.0pt"><span style="font-family:Times">{</span>plus(0,0,0)<span style="font-family:Times">, </span>plus(s(0),0,0)<span style="font-family:Times">, &hellip;,</span><br>
plus(0,s(0),0)<span style="font-family:Times">, </span>plus(s(0),s(0),0)<span style="font-family:Times">, &hellip;,</span><br>
<span style="font-family:Times">&hellip;,</span><br>
plus(s(0),s(s(0)),s(s(s(0))))<span style="font-family:Times">, &hellip;}</span></p>

<p class="tekst">As before, a <i style="mso-bidi-font-style:normal">Herbrand
interpretation</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Herbrand interpretation&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a subset of the Herbrand base, whose
elements are assigned the truth value <b style="mso-bidi-font-weight:normal">true</b>.
For instance, </p>

<p class="p-el"><span style="font-family:Times">{</span>plus(0,0,0)<span style="font-family:Times">, </span>plus(s(0),0,s(0))<span style="font-family:
Times">, </span>plus(0,s(0),s(0))<span style="font-family:Times">} </span></p>

<p class="tekst">is an interpretation of the above program.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Unification vs. evaluation<!--[if supportFields]><span
  style='mso-element:field-begin'></span> XE<span
  style="mso-spacerun:yes">&nbsp; </span>&quot;Unification: vs.
  evaluation&quot; <![endif]--><!--[if supportFields]><span style='mso-element:
  field-end'></span><![endif]--></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Functors should not be confused with mathematical functions.
  Although both can be viewed as mappings from objects to objects, <i style="mso-bidi-font-style:normal">an expression containing a functor is not
  evaluated</i> to determine the value of the mapping, as in mathematics.
  Rather, the outcome of the mapping is a name, which is determined by <i style="mso-bidi-font-style:normal">unification</i>. For instance, given the
  complex term <span style="font-family:Courier">person_loved_by(X)</span>, if
  we want to know the name of the object to which Peter is mapped, we unify <span style="font-family:Courier">X</span> with <span style="font-family:Courier">peter</span>
  to get <span style="font-family:Courier">person_loved_by(peter)</span>; this
  ground term is not evaluated any further.</p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">This approach has the disadvantage that we introduce different
  names for individuals that might turn out to be identical, e.g. <span style="font-family:Courier">person_loved_by(peter)</span> might be the same
  as <span style="font-family:Courier">peter</span>. Consequently, reasoning
  about equality (of different names for the same object) is a problem in
  clausal logic. Several possible solutions exist, but they fall outside the
  scope of this book.</p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Is this interpretation also a model<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;model&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of the program? As in the propositional
case, we define an interpretation to be a model of a program if it is a model
of every ground instance of every clause in the program. But since the Herbrand
universe is infinite, there are an infinite number of grounding substitutions,
hence we must generate the ground clauses in a systematic way, e.g.</p>

<p class="p-el" style="tab-stops:right 371.0pt">plus(0,0,0)<br>
plus(s(0),0,s(0)):-plus(0,0,0)<br>
plus(s(s(0)),0,s(s(0))):-plus(s(0),0,s(0))<br>
plus(s(s(s(0))),0,s(s(s(0)))):-plus(s(s(0)),0,s(s(0)))<br>
&hellip;<br>
plus(0,s(0),s(0))<br>
plus(s(0),s(0),s(s(0))):-plus(0,s(0),s(0))<br>
plus(s(s(0)),s(0),s(s(s(0)))):-plus(s(0),s(0),s(s(0)))<br>
&hellip;<br>
plus(0,s(s(0)),s(s(0)))<br>
plus(s(0),s(s(0)),s(s(s(0)))):-plus(0,s(s(0)),s(s(0)))<br>
plus(s(s(0)),s(s(0)),s(s(s(s(0))))):-<br>
<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>plus(s(0),s(s(0)),s(s(s(0))))<br>
&hellip;</p>

<p class="tekst">Now we can reason as follows: according to the first ground
clause, <span style="font-family:Courier">plus(0,0,0)</span> must be in any
model; but then the second ground clause requires that <span style="font-family:
Courier">plus(s(0),0,s(0))</span> must be in any model, the third ground clause
requires <span style="font-family:Courier">plus(s(s(0)),0,s(s(0)))</span> to be
in any model, and so on. Likewise, the second group of ground clauses demands
that </p>

<p class="p-el">plus(0,s(0),s(0))<br>
plus(s(0),s(0),s(s(0)))<br>
plus(s(s(0)),s(0),s(s(s(0))))<br>
&hellip;</p>

<p class="tekst">are in the model; the third group of ground clauses requires
that </p>

<p class="p-el">plus(0,s(s(0)),s(s(0)))<br>
plus(s(0),s(s(0)),s(s(s(0))))<br>
plus(s(s(0)),s(s(0)),s(s(s(s(0)))))<br>
&hellip;</p>

<p class="tekst">are in the model, and so forth.</p>

<p class="sektie">In other words, <i style="mso-bidi-font-style:normal">every
model of this program is necessarily infinite</i>. Moreover, as you should have
guessed by now, it contains every ground atom such that the number of <span style="font-family:Courier">s</span>&rsquo;s in the third argument equals the number
of <span style="font-family:Courier">s</span>&rsquo;s in the first argument <b style="mso-bidi-font-weight:normal">plus</b> the number of <span style="font-family:Courier">s</span>&rsquo;s in the second argument. The way we
generated this infinite model is particularly interesting, because it is
essentially what was called the naive proof method in the relational case:
generate all possible ground instances of program clauses by applying every
possible grounding substitution, and then apply (propositional) resolution as
long as you can. While, in the case of relational clausal logic, there
inevitably comes a point where applying resolution will not give any new
results (i.e. you reach a <i style="mso-bidi-font-style:normal">fixpoint</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;fixpoint&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->),
in the case of full clausal logic with infinite Herbrand universe you can go on
applying resolution forever. On the other hand, as we saw above, we get a clear
idea of what the infinite model<abar><a style="mso-footnote-id:ftn6" href="#_ftn6" name="_ftnref6" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:
footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:
&quot;Times New Roman&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:
EN-GB;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes">[6]</span></span><!--[endif]--></span></span></span></a></abar>
we&rsquo;re constructing looks like, which means that it is still a fixpoint in some
sense. There are mathematical techniques to deal with such infinitary
fixpoints, but we will not dive into this subject here. </p>

<!--


<pre class="source swish" data-variant-id="group-1" id="swish.2.3.1" style="display: block;">
reachable(oxford,charing_cross,piccadilly).
reachable(X,Y,route(Z,R)):- connected(X,Z,L), reachable(Z,Y,R).
connected(bond_street,oxford,central).
</pre>

-->



<p class="sektie">Although the introduction of only a single functor already
results in an infinite Herbrand universe, models are not necessarily infinite.
Consider the following program:</p>

<p class="p-eerst">reachable(oxford,charing_cross,piccadilly).</p>

<p class="pi">reachable(X,Y,route(Z,R)):-<br>
connected(X,Z,L),<br>
reachable(Z,Y,R).</p>

<p class="p-laatst">connected(bond_street,oxford,central).</p>

<p class="tekst">with intended meaning &lsquo;Charing Cross is reachable from Oxford
Circus via Piccadilly Circus&rsquo;, &lsquo;<b style="mso-bidi-font-weight:normal">if</b><span style="font-family:Courier"> </span><i style="mso-bidi-font-style:normal">X</i>
is connected to <i style="mso-bidi-font-style:normal">Z</i> by line <i style="mso-bidi-font-style:normal">L</i> <b style="mso-bidi-font-weight:normal">and</b>
<i style="mso-bidi-font-style:normal">Y</i> is reachable from <i style="mso-bidi-font-style:normal">Z</i> via <i style="mso-bidi-font-style:
normal">R</i> <b style="mso-bidi-font-weight:normal">then</b> <i style="mso-bidi-font-style:normal">Y</i> is reachable from <i style="mso-bidi-font-style:
normal">X</i> via a route consisting of <i style="mso-bidi-font-style:normal">Z</i>
and <i style="mso-bidi-font-style:normal">R</i>&rsquo; and &lsquo;Bond Street is connected
to Oxford Circus by the Central line&rsquo;. The minimal model of this program is the
finite set</p>

<p class="p-el" style="margin-left:0cm"><span style="font-family:Times">{</span>connected(bond_street,oxford,central)<span style="font-family:Times">,<br>
</span>reachable(oxford,charing_cross,piccadilly)<span style="font-family:Times">,<br>
</span>reachable(bond_street,charing_cross,route(oxford,piccadilly))<span style="font-family:Times">}<o:p></o:p></span></p>

<p class="sektie">A Prolog program for constructing models of a given set of
clauses (or submodels if the models are infinite) can be found in section 5.4. </p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal logic:proof
theory&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Proof theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal logic:resolution&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]-->Resolution for full
clausal logic is very similar to resolution for relational clausal logic: we
only have to modify the unification<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;unification&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>algorithm in order to deal with complex
term<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;complex term&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s.
For instance, consider the atoms </p>

<p class="p-el">plus(s(0),X,s(X)) </p>

<p class="tekst">and </p>

<p class="p-el">plus(s(Y),s(0),s(s(Y)))</p>

<p class="tekst">Their mgu<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;mgu&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is {<span style="font-family:Courier">Y</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">0</span>, <span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">s(0)</span>}, yielding the atom </p>

<p class="p-el">plus(s(0),s(0),s(s(0)))</p>

<p class="tekst">In order to find this mgu, we first of all have to make sure
that the two atoms do not have any variables in common; if needed some of the
variables should be renamed. Then, after making sure that both atoms contain
the same predicate (with the same arity), we scan the atoms from left to right,
searching for the first <b style="mso-bidi-font-weight:normal">subterms</b> at
which the two atoms differ. In our example, these are <span style="font-family:
Courier">0</span> and <span style="font-family:Courier">Y</span>. If one of
these subterms is not a variable, then the two atoms are not unifiable;
otherwise, substitute the other term for all occurrences of the variable in
both atoms, and remember this partial substitution (in the above example: {<span style="font-family:Courier">Y</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">0</span>}), because it is going to be part of the
unifier we are constructing. Then, proceed with the next subterms at which the
two atoms differ. Unification is finished when no such subterms can be found
(the two atoms are made equal).</p>

<p class="sektie">Although the two atoms initially have no variables in common,
this may change during the unification process. Therefore, it is important
that, before a variable is replaced by a term, we check whether the variable
already occurs in that term; this is called the <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unification:occur check&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">occur check</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;occur check&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
If the variable does not occur in the term by which it is to be replaced,
everything is in order and we can proceed; if it does, the unification should
fail, because it would lead to circular substitutions and infinite terms. To
illustrate this, consider again the clause</p>

<p class="p-el">loves(X,person_loved_by(X))</p>

<p class="tekst">We want to know whether this implies that someone loves herself;
thus, we add the query <span style="font-family:Courier">:-loves(Y,Y)</span> to
this clause and try to apply resolution. To this end, we must unify the two
atoms. The first subterms at which they differ are the first arguments, so we
apply the partial substitution <span style="font-family:Courier">Y</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">X</span>
to the two atoms, resulting in </p>

<p class="p-el">loves(X,person_loved_by(X)) </p>

<p class="tekst">and </p>

<p class="p-el">loves(X,X)</p>

<p class="tekst">The next subterms at which these atoms differ are their second
arguments, one of which is a variable. Suppose that we ignore the fact that
this variable, <span style="font-family:Courier">X</span>, already occurs in the
other term; we construct the substitution <span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">person_loved_by(X)</span>.
Now, we have reached the end of the two atoms, so unification has succeeded, we
have derived the empty clause, and the answer to the query is</p>

<p class="p-el">X<span style="font-family:Symbol">&rarr;</span>person_loved_by(person_loved_by(person_loved_by(&hellip;)))</p>

<p class="tekst">which is an infinite term. </p>

<p class="sektie">Now we have two problems. The first is that we did not define
any semantics for infinite terms, because there are no infinite terms in the
Herbrand base. But even worse, the fact that there exists someone who loves
herself is not a logical consequence of the above clause! That is, this clause
has models in which nobody loves herself. So, <i style="mso-bidi-font-style:
normal">unification without occur check would make resolution unsound</i>.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;occur check:and
soundness of resolution&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.11</i>. If
possible, unify the following pairs of terms:<br>
(<i style="mso-bidi-font-style:normal">a</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">plus(X,Y,s(Y))</span> and <span style="font-family:
Courier">plus(s(V),W,s(s(V)))</span>;<br>
(<i style="mso-bidi-font-style:normal">b</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">length([X|Y],s(0))</span> and <span style="font-family:Courier">length([V],V)</span>;<br>
(<i style="mso-bidi-font-style:normal">c</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">larger(s(s(X)),X)</span> and <span style="font-family:Courier">larger(V,s(V))</span>.</p>

</div>

<p class="sektie">The disadvantage of the occur check<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;occur
check:computational cost&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is that it can be computationally very
costly. Suppose that you need to unify <span style="font-family:Courier">X</span>
with a list of thousand elements, then the complete list has to be searched in
order to check whether <span style="font-family:Courier">X</span> occurs
somewhere in it. Moreover, cases in which the occur check is needed often look
somewhat exotic. Since the developers of Prolog were also taking the efficiency
of the Prolog interpreter into consideration, they decided to omit the occur
check from Prolog&rsquo;s unification algorithm. On the whole, this makes Prolog
unsound; but this unsoundness only occurs in very specific cases, and it is the
duty of the programmer to avoid such cases.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:unsoundness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>In case you really need sound
unification, most available Prolog implementations provide it as a library
routine, but you must build your own Prolog interpreter in order to incorporate
it. In Chapter 3, we will see that this is in fact amazingly simple: it can
even be done in Prolog!</p>

<p class="sektie1"><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal
logic:meta-theory&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">Meta-theory.<span style="mso-spacerun:yes">&nbsp;&nbsp; </span></i>Most meta-theoretical results
concerning full clausal logic have already been mentioned. Full clausal
resolution is sound<!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal logic:soundness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(as long as unification is performed with
the occur check), refutation complete but not complete<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal
logic:completeness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Moreover, due to the possibility of infinite interpretations full clausal logic
is only semi-decidable<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;semi-decidable&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
that is, if <i style="mso-bidi-font-style:normal">A</i> is a logical
consequence of <i style="mso-bidi-font-style:normal">B</i>, then there is an
algorithm that will check this in finite time; however, if <i style="mso-bidi-font-style:
normal">A</i> is not a logical consequence of <i style="mso-bidi-font-style:
normal">B</i>, then there is no algorithm which is guaranteed to check this in
finite time for arbitrary <i style="mso-bidi-font-style:normal">A</i> and <i style="mso-bidi-font-style:normal">B</i>. <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal
logic:decidability&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->Consequently,
there is no general way to prevent Prolog from looping if no (further) answers
to a query can be found.</p>

<h3 id="definite_clause_logic">2.4<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Definite clause
logic</h3>

<p class="sektie1">In the foregoing three sections, we introduced and discussed
three variants of clausal logic, in order of increasing expressiveness. In this
section, we will show how an additional restriction on each of these variants
will significantly improve the efficiency of a computational reasoning system
for clausal logic. This is the restriction to definite clauses, on which Prolog
is based. On the other hand, this restriction also means that definite clause
logic is less expressive than full clausal logic, the main difference being
that clausal logic can handle negative information. If we allow negated
literals in the body of a definite clause then we obtain a so-called general
clause, which is probably the closest we can get to full clausal logic without
having to sacrifice efficiency. </p>

<p class="sektie" style="page-break-after:avoid">Consider the following program:</p>

<p class="p-el">married(X);bachelor(X):-man(X),adult(X).<br>
man(peter).<br>
adult(peter).<br>
:-married(maria).<br>
:-bachelor(maria).<br>
man(paul).<br>
:-bachelor(paul).</p>

<p class="tekst">There are many clauses that are logical consequences of this
program. In particular, the following three clauses can be derived by
resolution:</p>

<p class="p-el">married(peter);bachelor(peter)<br>
:-man(maria),adult(maria)<br>
married(paul):-adult(paul)</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.12</i>. Draw
the proof tree for each of these derivations.</p>
</div>

<p class="sektie">In each of these derivations, the first clause in the program
is used in a different way. In the first one, only literals in the body are
resolved away; one could say that the clause is used from right to left. In the
second derivation<span style="mso-spacerun:yes">&nbsp; </span>the clause is
used from left to right, and in the third one literals from both the head and
the body are resolved away. The way in which a clause is used in a resolution
proof cannot be fixed in advance, because it depends on the thing we want to
prove (the query in refutation proofs).</p>

<p class="sektie">On the other hand, this indeterminacy substantially increases
the time it takes to find a refutation. Let us decide for the moment to use
clauses only in one direction, say from right to left. That is, we can only resolve
the negative literals away in a clause, as in the first derivation above, but
not the positive literals. But now we have a problem: how are we going to
decide whether Peter is married or a bachelor? We are stuck with a clause with
two positive literals, representing a disjunctive or <i style="mso-bidi-font-style:
normal">indefinite</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;indefinite</i> clause<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>conclusion.</p>

<p class="sektie">This problem can in turn be solved by requiring that clauses
have exactly one positive literal, which leads us into <i style="mso-bidi-font-style:
normal">definite clause logic</i>. Consequently, a definite clause<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;definite
clause&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span></p>

<p class="sektie" style="margin-top:6.0pt;margin-right:0cm;margin-bottom:6.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">A</i><span style="font-family:Courier">:-</span><i style="mso-bidi-font-style:normal">B</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">1</span><span style="font-family:Courier">,</span>&hellip;<span style="font-family:Courier">,</span><i style="mso-bidi-font-style:normal">B</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:
10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">n</span></i><span style="mso-spacerun:yes">&nbsp;</span></p>

<p class="tekst">will always be used in the following way: <i style="mso-bidi-font-style:
normal">A</i> is proved by proving each of <i style="mso-bidi-font-style:normal">B</i><span style="font-size:9.0pt;mso-bidi-font-size:10.0pt;position:relative;top:2.0pt;
mso-text-raise:-2.0pt">1</span>,&hellip;,<i style="mso-bidi-font-style:normal">B</i><i style="mso-bidi-font-style:normal"><span style="font-size:9.0pt;mso-bidi-font-size:
10.0pt;position:relative;top:2.0pt;mso-text-raise:-2.0pt">n</span></i>. This is
called the <!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;definite clause:procedural
interpretation&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">;</span><i style="mso-bidi-font-style:normal">procedural
interpretation</i><!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;procedural interpretation&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of definite clauses, and its simplicity
makes the search for a refutation much more efficient than in the indefinite
case. Moreover, it allows for an implementation which limits the amount of
memory needed, as will be explained in more detail in Chapter 5.</p>

<p class="sektie">But how do we express in definite clause logic that adult men
are bachelors or married? Even if we read the corresponding indefinite clause
from right to left only, it basically has two different procedural
interpretations: </p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>to prove that someone is married,
prove that he is a man and an adult, and prove that he is not a bachelor;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>to prove that someone is a
bachelor, prove that he is a man and an adult, and prove that he is not
married.</p>

<p class="tekst">We should first choose one of these procedural interpretations, and
then convert it into a &lsquo;pseudo-definite&rsquo; clause. In case (<i style="mso-bidi-font-style:
normal">i</i>), this would be</p>

<p class="p-el">married(X):-man(X),adult(X),not bachelor(X)<span style="font-family:Times"><o:p></o:p></span></p>

<p class="tekst">and case (<i style="mso-bidi-font-style:normal">ii</i>) becomes</p>

<p class="p-el">bachelor(X):-man(X),adult(X),not married(X)<span style="font-family:Times"><o:p></o:p></span></p>

<p class="tekst">These clauses do not conform to the syntax of definite clause
logic, because of the negation symbol <span style="font-family:Courier">not</span>.
We will call them <i style="mso-bidi-font-style:normal">general clause</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;general clause&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s.
</p>

<p class="sektie">If we want to extend definite clause logic to cover general
clauses, we should extend resolution in order to deal with negated literals in
the body of a clause. In addition, we should extend the semantics. This topic
will be addressed in section 8.2. Without going into too much detail here, we
will demonstrate that preferring a certain procedural interpretation
corresponds to preferring a certain minimal model. Reconsider the original
indefinite clause</p>

<p class="p-el">married(X);bachelor(X):-man(X),adult(X)</p>

<p class="tekst">Supposing that <span style="font-family:Courier">john</span> is
the only individual in the Herbrand universe, and that <span style="font-family:
Courier">man(john)</span> and <span style="font-family:Courier">adult(john)</span>
are both true, then the models of this clause are</p>

<p class="p-el"><span style="font-family:Times">{</span>man(john)<span style="font-family:Times">, </span>adult(john)<span style="font-family:Times">,
</span>married(john)<span style="font-family:Times">}<br>
{</span>man(john)<span style="font-family:Times">, </span>adult(john)<span style="font-family:Times">, </span>bachelor(john)<span style="font-family:Times">}<br>
{</span>man(john)<span style="font-family:Times">, </span>adult(john)<span style="font-family:Times">, </span>married(john)<span style="font-family:Times">,
</span>bachelor(john)<span style="font-family:Times">}</span></p>

<p class="tekst">Note that the first <b style="mso-bidi-font-weight:normal">two</b>
models are minimal, as is characteristic for indefinite clauses. If we want to
make the clause definite, we should single out one of these two minimal model<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;minimal model&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]-->s as the <i style="mso-bidi-font-style:normal">intended</i> model<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;intended</i> model<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
If we choose the first model, in which John is married but not a bachelor, we
are actually preferring the general clause</p>

<p class="p-el">married(X):-man(X),adult(X),not bachelor(X)<span style="font-family:Times"><o:p></o:p></span></p>

<p class="tekst">Likewise, the second model corresponds to the general clause</p>

<p class="p-el">bachelor(X):-man(X),adult(X),not married(X)<span style="font-family:Times"><o:p></o:p></span></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.13.</i> Write
a clause for the statement &lsquo;somebody is innocent unless proven guilty&rsquo;, and
give its intended model (supposing that <span style="font-family:Courier">john</span>
is the only individual in the Herbrand universe).</p>
</div>

<p class="sektie">An alternative approach to general clauses is to treat <span style="font-family:Courier">not</span> as a special Prolog predicate, as will
be discussed in the next chapter. This has the advantage that we need not
extend the proof theory and semantics to incorporate general clauses. However,
a disadvantage is that in this way <span style="font-family:Courier">not</span>
can only be understood procedurally. </p>

<h3 id="the_relation_between_clausal_logic_and_predicate_logic">2.5<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>The relation
between clausal logic and Predicate Logic</h3>

<p class="sektie1">Clausal logic is a formalism especially suited for automated
reasoning. However, the form of logic usually presented in courses on Symbolic
Logic is (first-order) <a name="bk0">Predicate Logic. Predicate logic is more
expressive in the sense that statements expressed in Predicate Logic often
result in shorter formulas than would result if they were expressed in clausal
logic. This is due to the larger vocabulary and less restrictive syntax of
Predicate Logic, which includes quantifiers (&lsquo;for all&rsquo; (</a><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>) and
&lsquo;there exists&rsquo; (</span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&exist;</span>)), and various logical connectives (conjunction</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;conjunction&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>(</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;</span>),
disjunction</span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;disjunction&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>(</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span>), negation (</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span>),
implication</span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;implication&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>(</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&rarr;</span>), and
equivalence</span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;equivalence&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>(</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&harr;</span>)) which may
occur anywhere within a formula. </span></p>

<p class="sektie"><span style="mso-bookmark:bk0">Being syntactically quite
different, clausal logic and Predicate Logic are semantically equivalent in the
following sense: every set of clauses is, after minor modifications, a formula
in Predicate Logic, and conversely, every formula in Predicate Logic can be
rewritten to an &lsquo;almost&rsquo; equivalent set of clauses. Why then bother about
Predicate Logic at all in this book? The main reason is that in Chapter 8, we
will discuss an alternative semantics of logic programs, defined in terms of
Predicate Logic. In this section, we will illustrate the semantic equivalence
of clausal logic and Predicate Logic. We will assume a basic knowledge of the
syntax and semantics of Predicate Logic. </span></p>

<p class="sektie"><span style="mso-bookmark:bk0">We start with the propositional
case. Any clause like</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">married;bachelor:-man,adult</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">can be rewritten by reversing
head</span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;head:of a clause&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>and body</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;body of a clause&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>and
replacing the &lsquo;</span><span style="mso-bookmark:bk0"><span style="font-family:
Courier">:-</span>&rsquo; sign by an implication &lsquo;</span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol">&rarr;</span>&rsquo;, replacing &lsquo;</span><span style="mso-bookmark:bk0"><span style="font-family:Courier">,</span>&rsquo; by a
conjunction &lsquo;</span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&and;</span>&rsquo;, and replacing &lsquo;</span><span style="mso-bookmark:bk0"><span style="font-family:Courier">;</span>&rsquo; by a disjunction &lsquo;</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span>&rsquo;, which
yields</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">man</span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol"> &and; </span>adult</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &rarr; </span>married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>bachelor</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">By using the logical laws <i style="mso-bidi-font-style:normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&rarr;</span><i style="mso-bidi-font-style:normal">B</i> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&equiv;</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span><i style="mso-bidi-font-style:normal">B</i>
and </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span>(<i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;</span><i style="mso-bidi-font-style:normal">D</i>)
</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&equiv;</span>
</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;&not;</span><i style="mso-bidi-font-style:normal">D</i>,
this can be rewritten into the logically equivalent formula</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">&not;man</span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol"> &or; </span>&not;adult</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>bachelor</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">which, by the way, clearly
demonstrates the origin of the terms <i style="mso-bidi-font-style:normal">negative</i>
literal</span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;negative</i> literal<i
style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>and <i style="mso-bidi-font-style:normal">positive</i> literal</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;positive</i> literal<i
style='mso-bidi-font-style:normal'>&quot; </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">!</span></p>

<p class="sektie"><span style="mso-bookmark:bk0">A set of clauses can be
rewritten by rewriting each clause separately, and combining the results into a
single conjunction, e.g.</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">married;bachelor:-man,adult.<br>
has_wife:-man,married.</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">becomes</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">(&not;man</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>&not;adult</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>bachelor)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &and; <br>
</span>(&not;man</span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol"> &or; </span>&not;married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>has_wife)</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">Formulas like these, i.e.
conjunctions of disjunctions of atoms and negated atoms, are said to be in <i style="mso-bidi-font-style:normal">conjunctive normal form</i></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;conjunctive normal form&quot; \b </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>(CNF). </span></p>

<p class="sektie"><span style="mso-bookmark:bk0">The term &lsquo;normal form&rsquo; here
indicates that <i style="mso-bidi-font-style:normal">every formula of Predicate
Logic can be rewritten into a unique equivalent formula in conjunctive normal
form</i>, and therefore to a unique equivalent set of clauses. For instance,
the formula</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">(married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>&not;child)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &rarr; </span>(adult</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &and; </span>(man</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>woman))</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">can be rewritten into CNF as
(replace <i style="mso-bidi-font-style:normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&rarr;</span><i style="mso-bidi-font-style:normal">B</i> by </span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:
normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&or;</span><i style="mso-bidi-font-style:normal">B</i>, push negations
inside by means of De Morgan&rsquo;s laws: </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span>(<i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;</span><i style="mso-bidi-font-style:normal">D</i>) </span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol">&equiv;</span> </span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:
normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&or;&not;</span><i style="mso-bidi-font-style:normal">D</i> and </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span>(<i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span><i style="mso-bidi-font-style:normal">D</i>)
</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&equiv;</span>
</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;&not;</span><i style="mso-bidi-font-style:normal">D</i>,
and distribute </span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&and;</span> over </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span> by means of (<i style="mso-bidi-font-style:
normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol">&and;</span><i style="mso-bidi-font-style:normal">B</i>)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span><i style="mso-bidi-font-style:normal">C</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &equiv; </span>(<i style="mso-bidi-font-style:normal">A</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span><i style="mso-bidi-font-style:normal">C</i>)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;</span>(<i style="mso-bidi-font-style:normal">B</i></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&or;</span><i style="mso-bidi-font-style:normal">C</i>)):</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">(&not;married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>adult)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &and; </span>(&not;married</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>man</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>woman)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &and; <br>
</span>(child</span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol"> &or; </span>adult)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &and; </span>(child</span><span style="mso-bookmark:
bk0"><span style="font-family:Symbol"> &or; </span>man</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; </span>woman)</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">and hence into clausal form as</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">adult:-married.<br>
man;woman:-married.<br>
child;adult.<br>
child;man;woman.</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">Using a normal form has the
advantage that the language contains no redundancy: formulas are only
equivalent if they are <b style="mso-bidi-font-weight:normal">identical</b> (up
to the order of the subformulas). A slight disadvantage is that normal forms
are often longer and less understandable (the same objection can be made
against resolution proofs).</span></p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">The order of logics</span><!--[if supportFields]><span
  style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
  style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;order of a logic&quot; \b </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span
  style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"></span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">A logic with propositions
  (statements that can be either true or false) as basic building blocks is
  called a propositional logic; a logic built on predicates is called a
  Predicate Logic. Since propositions can be viewed as nullary predicates (i.e.
  predicates without arguments), any propositional logic is also a Predicate
  Logic.</span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">A logic may or may not have
  variables for its basic building blocks. If it does not include such
  variables, both the logic and its building blocks are called <i style="mso-bidi-font-style:normal">first-order</i>; this is the normal case.
  Thus, in first-order Predicate Logic, there are no <br>
  predicate variables, but only first-order predicates. </span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">Otherwise, an <i style="mso-bidi-font-style:normal">n</i><span style="position:relative;
  top:-3.0pt;mso-text-raise:3.0pt">th</span><span style="mso-spacerun:yes">&nbsp;</span>order logic has variables (and thus
  quantifiers) for its (<i style="mso-bidi-font-style:normal">n</i>-1)<span style="position:relative;top:-3.0pt;mso-text-raise:3.0pt">th</span><span style="mso-spacerun:yes">&nbsp;</span>order building blocks. For instance, the
  statement </span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">X</span></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">Y</span>: </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">equal(X,Y)</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&harr;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier"> (</span></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P</span>: </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P(X)</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&harr;</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P(Y))</span></span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">defining two individuals to be
  equal if they have the same properties, <br>
  is a statement from second-order Predicate Logic, because </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P</span> is a <br>
  variable ranging over first-order predicates.</span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">Another example of a statement
  from second-order Predicate Logic is </span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  3.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P</span>: </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">transitive(P)</span>
  </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&harr;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier"> (</span></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">X</span></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">Y</span></span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">Z</span>: </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P(X,Y)</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&and;</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P(Y,Z)</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&rarr;</span> </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">P(X,Z))</span></span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto"><span style="mso-bookmark:bk0">This statement defines the
  transitivity of binary relations. Since </span><span style="mso-bookmark:
  bk0"><span style="font-family:Courier">transitive</span> has a second-order
  variable as argument, it is called a <i style="mso-bidi-font-style:normal">second-order
  predicate</i>. </span></p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie"><span style="mso-bookmark:bk0">For rewriting clauses from full
clausal logic to Predicate Logic</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Logic:translation from
clausal logic&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">, we use the same rewrite rules as for propositional
clauses. Additionally, we have to add universal quantifier</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;universal quantifier&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">s for every variable in the clause. For example, the
clause</span></p>

<p class="pi-el"><span style="mso-bookmark:bk0">reachable(X,Y,route(Z,R)):-<br>
connected(X,Z,L),<br>
reachable(Z,Y,R).</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">becomes</span></p>

<p class="p-el" align="center" style="text-align:center"><span style="mso-bookmark:
bk0"><span style="font-family:Symbol">&forall;</span>X</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>Y</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>Z</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>R</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>L:
&not;connected(X,Z,L)</span><span style="mso-bookmark:bk0"><span style="font-family:
Symbol"> &or; </span>&not;reachable(Z,Y,R)</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol"> &or; <br>
</span>reachable(X,Y,route(Z,R))</span></p>

<p class="sektie"><span style="mso-bookmark:bk0">The reverse process of rewriting
a formula of Predicate Logic</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate Logic:translation to
clausal logic&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>into an
equivalent set of clauses is somewhat complicated if existential quantifiers
are involved (the exact procedure is given as a Prolog program in Appendix
B.1). An existential quantifier</span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;existential quantifier&quot; </span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0"><span style="mso-spacerun:yes">&nbsp;</span>allows us
to reason about individuals without naming them. For example, the statement
&lsquo;everybody loves somebody&rsquo; is represented by the Predicate Logic formula</span></p>

<p class="p-el"><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>X</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&exist;</span>Y: loves(X,Y)</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">Recall that we translated this
same statement into clausal logic as</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">loves(X,person_loved_by(X))</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">These two formulas are not
logically equivalent! That is, the Predicate Logic formula has models like {</span><span style="mso-bookmark:bk0"><span style="font-family:Courier">loves(paul,anna)</span>}
which are <b style="mso-bidi-font-weight:normal">not</b> models of the clause.
The reason for this is, that in clausal logic we are forced to introduce
abstract names, while in Predicate Logic we are not (we use existential
quantification instead). On the other hand, every model of the Predicate Logic
formula, if not a model of the clause, can always be converted to a model of
the clause, like {</span><span style="mso-bookmark:bk0"><span style="font-family:
Courier">loves(paul,person_loved_by(paul))</span>}. Thus, we have that the
formula has a model if and only if the clause has a model (but not necessarily
the same model).</span></p>

<p class="sektie"><span style="mso-bookmark:bk0">So, existential quantifiers are
replaced by functors. The arguments of the functor are given by the universal
quantifiers in whose scope the existential quantifier occurs. In the above
example, </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&exist;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">Y</span> occurs
within the scope of </span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span></span><span style="mso-bookmark:bk0"><span style="font-family:Courier">X</span>, so we replace </span><span style="mso-bookmark:bk0"><span style="font-family:Courier">Y</span> everywhere
in the formula by </span><span style="mso-bookmark:bk0"><span style="font-family:
Courier">person_loved_by(X)</span>, where </span><span style="mso-bookmark:
bk0"><span style="font-family:Courier">person_loved_by</span> should be a <b style="mso-bidi-font-weight:normal">new</b> functor, not occurring anywhere
else in the clause (or in any other clause). This new functor is called a <i style="mso-bidi-font-style:normal">Skolem functor</i></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Skolem functor&quot; \b </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">, and the whole process is called <i style="mso-bidi-font-style:
normal">Skolemisation</i></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk0'><span style='display:none;mso-hide:all'> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Skolemisation&quot; \b </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span style='mso-bookmark:
bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">. Note that, if the existential quantifier does not
occur inside the scope of a universal quantifier, the Skolem functor does not
get any arguments, i.e. it becomes a <i style="mso-bidi-font-style:normal">Skolem
constant</i></span><!--[if supportFields]><span style='mso-bookmark:bk0'></span><span
style='mso-element:field-begin'></span><span style='mso-bookmark:bk0'><span
style='display:none;mso-hide:all'> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;Skolem constant&quot;
\b </i></span><![endif]--><span style="mso-bookmark:bk0"></span><!--[if supportFields]><span
style='mso-bookmark:bk0'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk0">. For example, the formula</span></p>

<p class="p-el"><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&exist;</span>X</span><span style="mso-bookmark:bk0"><span style="font-family:Symbol">&forall;</span>Y:
loves(X,Y)</span></p>

<p class="tekst"><span style="mso-bookmark:bk0">(&lsquo;somebody loves everybody&rsquo;) is
translated to the clause</span></p>

<p class="p-el"><span style="mso-bookmark:bk0">loves(someone_who_loves_everybody,X)</span></p>

<p class="sektie"><span style="mso-bookmark:bk0">Finally, we illustrate the whole
process of converting from Predicate Logic</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate
Logic&quot; \r &quot;bk0&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>to clausal logic by means of an example.
Consider the sentence &lsquo;Everyone has a mother, but not every woman has a child&rsquo;.
In Predicate Logic, this can be represented as</p>

<p class="p-el"><span style="font-family:Symbol">&forall;</span>Y<span style="font-family:Symbol">&exist;</span>X: mother_of(X,Y) <span style="font-family:
Symbol">&and;</span> &not;<span style="font-family:Symbol">&forall;</span>Z<span style="font-family:Symbol">&exist;</span>W: woman(Z)<span style="font-family:Symbol">&rarr;</span>mother_of(Z,W)</p>

<p class="tekst">First, we push the negation inside by means of the equivalences <span style="font-family:Symbol">&not;&forall;</span><i style="mso-bidi-font-style:normal">X</i>:
<i style="mso-bidi-font-style:normal">F</i><span style="font-family:Symbol"> &equiv;
&exist;</span><i style="mso-bidi-font-style:normal">X</i>: <span style="font-family:
Symbol">&not;</span><i style="mso-bidi-font-style:normal">F</i> and <span style="font-family:Symbol">&not;&exist;</span><i style="mso-bidi-font-style:normal">Y</i>:
<i style="mso-bidi-font-style:normal">G</i><span style="font-family:Symbol"> &equiv;
&forall;</span><i style="mso-bidi-font-style:normal">Y</i>: <span style="font-family:Symbol">&not;</span><i style="mso-bidi-font-style:normal">G</i>,
and the previously given propositional equivalences, giving</p>

<p class="p-el"><span style="font-family:Symbol">&forall;</span>Y<span style="font-family:Symbol">&exist;</span>X: mother_of(X,Y) <span style="font-family:
Symbol">&and;</span> <span style="font-family:Symbol">&exist;</span>Z<span style="font-family:Symbol">&forall;</span>W: woman(Z)<span style="font-family:
Symbol"> &and; </span>&not;mother_of(Z,W)</p>

<p class="tekst">The existential quantifiers are Skolemised: <span style="font-family:Courier">X</span> is replaced by <span style="font-family:
Courier">mother(Y)</span>, because it is in the scope of the universal
quantifier <span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">Y</span>. <span style="font-family:Courier">Z</span>,
however, is not in the scope of a universal quantifier; therefore it is
replaced by a Skolem constant <span style="font-family:Courier">childless_woman</span>.
The universal quantifiers can now be dropped:</p>

<p class="p-el">mother_of(mother(Y),Y) <span style="font-family:Symbol">&and;</span>
woman(childless_woman)<span style="font-family:Symbol"> &and; </span>&not;mother_of(childless_woman,W)</p>

<p class="tekst">This formula is already in CNF, so we obtain the following set
of clauses:</p>

<p class="p-el">mother_of(mother(Y),Y).<br>
woman(childless_woman).<span style="font-family:Symbol"><br>
:-</span>mother_of(childless_woman,W).</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 2.14</i>.
Translate to clausal logic:<br>
(<i style="mso-bidi-font-style:normal">a</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">X</span><span style="font-family:Symbol">&exist;</span><span style="font-family:Courier">Y: mouse(X)</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:
Courier">tail_of(Y,X)</span>;<br>
(<i style="mso-bidi-font-style:normal">b</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">X</span><span style="font-family:Symbol">&exist;</span><span style="font-family:Courier">Y: loves(X,Y)</span><span style="font-family:Symbol">&and;</span><span style="font-family:Courier">(</span><span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">Z: loves(Y,Z))</span>;<br>
(<i style="mso-bidi-font-style:normal">c</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">X</span><span style="font-family:Symbol">&forall;</span><span style="font-family:Courier">Y</span><span style="font-family:Symbol">&exist;</span><span style="font-family:Courier">Z: number(X)</span><span style="font-family:Symbol">&and;</span><span style="font-family:Courier">number(Y)</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maximum(X,Y,Z)</span>.</p>

</div>

<h3 id="further_reading_2">Further reading</h3>

<p class="sektie1">Many (but not all) aspects of Artificial Intelligence are
amenable to logical analysis. An early advocate of this approach is Kowalski
(1979). Overviews of different types of logics used in Artificial Intelligence
can be found in (Turner, 1984; Genesereth &amp; Nilsson, 1987; Ramsay, 1988).
Bl&auml;sius and B&uuml;rckert (1989) discuss more technical aspects of automated theorem
proving. </p>

<p class="sektie">The main source for theoretical results in Logic Programming is
(Lloyd, 1987). Hogger (1990) gives a more accessible introduction to this
theory. (Mendelson, 1987) is an excellent introduction to Predicate Logic<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Predicate
Logic&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->. </p>

<p class="referenties"><span style="font-variant:small-caps">K.H. Bl&auml;sius &amp;
H.J. B&uuml;rckert</span> (eds)<span style="font-variant:small-caps"> (</span>1989)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Deduction
Systems in Artificial Intelligence</i>, Ellis Horwood.<span style="display:
none;mso-hide:all">.H.;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Bl&auml;sius, K.H.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.J.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;B&uuml;rckert,
H.J.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">M.R. Genesereth
&amp; N.J. Nilsson (</span>1987)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Logical Foundations of Artificial
Intelligence</i>, Morgan Kaufmann.<span style="display:none;mso-hide:all">.R.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Genesereth,
M.R.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.J.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Nilsson, N.J.&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">C.J. Hogger (</span>1990)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Essentials
of Logic Programming</i>, Oxford University Press.<span style="display:none;
mso-hide:all">.J.;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Hogger, C.J.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">R.A. Kowalski (</span>1979)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Logic
for Problem Solving</i>, North-Holland.<span style="display:none;mso-hide:all">.A.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Kowalski,
R.A.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">J.W. Lloyd (</span>1987)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Foundations
of Logic Programming</i>, Springer-Verlag, second edition.<span style="display:none;mso-hide:all">.W.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Lloyd, J.W.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">E. Mendelson (</span>1987)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Introduction
to Mathematical Logic</i>, Wadsworth &amp; Brooks/Cole, third edition.<span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Mendelson, E.&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">R. Turner (</span>1984)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Logics
for Artificial Intelligence</i>, Ellis Horwood.<span style="display:none;
mso-hide:all">.;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Turner, R.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">A. Ramsay (</span>1988)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Formal
Methods in Artificial Intelligence</i>, Cambridge University Press.<span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Ramsay, A.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<b style="mso-bidi-font-weight:normal"><span style="font-size:18.0pt;
mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:
EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes"><br clear="all" style="page-break-before:
right;mso-break-type:section-break">
</span></b>

<div class="WordSection4">

<p id="logic_programming_and_prolog" class="cijfer">3</p>

<h2 id="h_logic_programming_and_prolog">Logic Programming and Prolog</h2>

<p class="sektie1">In the previous chapters we have seen how logic can be used to
represent knowledge about a particular domain, and to derive new knowledge by
means of logical inference. A distinct feature of logical reasoning is the
separation between model theory and proof theory: a set of logical formulas
determines the set of its models, but also the set of formulas that can be
derived by applying inference rules. Another way to say the same thing is:
logical formulas have both a <i style="mso-bidi-font-style:normal">declarative</i>
meaning and a <i style="mso-bidi-font-style:normal">procedural</i> meaning. For
instance, declaratively the order of the atoms in the body of a clause is
irrelevant, but procedurally it may determine the order in which different
answers to a query are found.</p>

<p class="sektie">Because of this procedural meaning of logical formulas, logic
can be used as a programming language. If we want to solve a problem in a
particular domain, we write down the required knowledge and apply the inference
rules built into the logic programming language. Declaratively, this knowledge
specifies <b style="mso-bidi-font-weight:normal">what</b> the problem is,
rather than <b style="mso-bidi-font-weight:normal">how</b> it should be solved.
The distinction between declarative and procedural aspects of problem solving
is succinctly expressed by Kowalski&rsquo;s equation </p>

<p class="p-el"><i style="mso-bidi-font-style:normal"><span style="font-family:
Times">algorithm = logic + control</span></i><!--[if supportFields]><span
style='font-family:Times;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><i style='mso-bidi-font-style:normal'><span
style='font-family:Times'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;algorithm = logic + control&quot; </span></i><![endif]--><!--[if supportFields]><span
style='font-family:Times;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span><i style="mso-bidi-font-style:normal"><span style="font-family:Times"><o:p></o:p></span></i></p>

<p class="tekst">Here, <i style="mso-bidi-font-style:normal">logic</i> refers to
declarative knowledge, and <i style="mso-bidi-font-style:normal">control</i>
refers to procedural knowledge. The equation expresses that both components are
needed to solve a problem algorithmically. </p>

<p class="sektie">In a purely declarative programming language, the programmer
would have no means to express procedural knowledge, because logically
equivalent programs would behave identical. However, Prolog is not a purely
declarative language, and therefore the procedural meaning of Prolog programs
cannot be ignored. For instance, the order of the literals in the body of a
clause usually influences the efficiency of the program to a large degree.
Similarly, the order of clauses in a program often determines whether a program
will give an answer at all. Therefore, in this chapter we will take a closer
look at Prolog&rsquo;s inference engine and its built-in features (some of which are
non-declarative). Also, we will discuss some common programming techniques. </p>

<h3 id="sld_resolution">3.1<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>SLD-resolution</h3>

<p class="sektie1">Prolog&rsquo;s proof procedure is based on resolution refutation in
definite clause logic. Resolution refutation has been explained in the previous
chapter. In order to turn it into an executable proof procedure, we have to
specify how a literal to resolve upon is selected, and how the second input
clause is found. Jointly, this is called a <i style="mso-bidi-font-style:normal">resolution
strategy</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;resolution:
strategy&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Consider the following program:</p>

<pre class="source swish temp" data-variant-id="group-2" id="swish.3.1.1" style="display: block;">
student_of(X,T):-follows(X,C),teaches(T,C).
follows(paul,computer_science).
follows(paul,expert_systems).
follows(maria,ai_techniques).
teaches(adrian,expert_systems).
teaches(peter,ai_techniques).
teaches(peter,computer_science).
</pre>

<p class="tekst">The query</p><pre class="swish query" id="query3.1.1"> ?- student_of(S,peter).</pre><p class="tekst">has two possible answers: {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">paul</span>}
and {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>}. In order to find these answers, we
first resolve the query with the first clause, yielding </p>
<pre class="swish query" id="query3.1.2">
?- follows(S,C),teaches(peter,C).
</pre>
<p class="tekst">Now we have to decide whether we will search for a clause which
resolves on <span style="font-family:Courier">follows(S,C)</span>, or for a
clause which resolves on <span style="font-family:Courier">teaches(peter,C)</span>.
This decision is governed by a <i style="mso-bidi-font-style:normal">selection
rule</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;selection rule&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Prolog&rsquo;s selection rule is left to right, thus Prolog will search for a clause
with a positive literal unifying with <span style="font-family:Courier">follows(S,C)</span>.
There are three of these, so now we must decide which one to try first. Prolog
searches the clauses in the program top-down, so Prolog finds the answer {<span style="font-family:Courier">S</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">paul</span>} first. Note that the second choice
leads to a dead end: the resolvent is </p>

<pre class="source swish inherit" inherit-id="swish.3.1.1" data-variant-id="group-1" query-id="query3.1.1 query3.1.2" id="swish.3.1.2" style="display: block;">
teaches(peter,expert_systems).
</pre>
<p class="tekst">which doesn&rsquo;t resolve with any clause in the program.</p>

<p class="sektie">This process is called <i style="mso-bidi-font-style:normal">SLD-resolution</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-resolution&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
<b style="mso-bidi-font-weight:normal">S</b> for selection rule<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;selection
rule&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->, <b style="mso-bidi-font-weight:normal">L</b> for <i style="mso-bidi-font-style:
normal">linear</i> resolution<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;linear</i> resolution<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(which refers to the shape of the proof
trees obtained), and <b style="mso-bidi-font-weight:normal">D</b> for <i style="mso-bidi-font-style:normal">definite</i> clause<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;definite</i> clause<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s.
Graphically, SLD-resolution can be depicted as in fig. 3.1. This <i style="mso-bidi-font-style:normal">SLD-tree</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-tree&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>should not be confused with a proof tree:
first, only the resolvents are shown (no input clauses or unifiers), and
second, it contains every possible resolution step. Thus, every leaf of an
SLD-tree which contains the empty clause<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;empty clause&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span><span style="font-family:Extra;
mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>
corresponds to a refutation and hence to a proof tree; such a leaf is also
called a <i style="mso-bidi-font-style:normal">success branch</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;success branch&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
An underlined leaf which does not contain <span style="font-family:Extra;
mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>
represents a <i style="mso-bidi-font-style:normal">failure branch</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;failure branch&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.1.</i> Draw
the proof trees for the two success branches in fig. 3.1.</p>

</div>

<p class="sektie">As remarked already, Prolog searches the clauses in the program
top-down, which is the same as traversing the SLD-tree from left to right. This
not only determines the order in which answers (i.e. success branches) are
found: it also determines whether any answers are found at all, because an
SLD-tree may contain infinite branches, if some predicates in the program are
recursive. As an example, consider the following program: </p>


<pre class="source swish" data-variant-id="group-2" id="swish.3.1.3" style="display: block;">
brother_of(paul,peter).
brother_of(X,Y):-brother_of(Y,X).
</pre>


<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1035" type="#_x0000_t75"
   style='width:307pt;height:120pt'>
   <v:imagedata src="Part%20I_files/image021.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image022.svg" v:shapes="_x0000_i1035"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 3.1.</b> An
  SLD-tree.</p>
  </td>
 </tr>
</tbody></table>

</div>

<div style="mso-element:frame;mso-element-frame-hspace:9.05pt;mso-element-frame-vspace:
9.05pt;mso-element-wrap:no-wrap-beside;mso-element-anchor-horizontal:margin;
mso-element-top:bottom;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.05pt;padding-right:9.05pt;
  padding-bottom:9.05pt;padding-left:9.05pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-frame-hspace:9.05pt;
  mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><!--[if gte vml 1]><v:shape
   id="_x0000_i1036" type="#_x0000_t75" style='width:120pt;height:125pt'>
   <v:imagedata src="Part%20I_files/image023.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image024.svg" v:shapes="_x0000_i1036"><!--[endif]--></p>
  </div>
  <p class="med-caption" style="mso-element:frame;mso-element-frame-hspace:9.05pt;
  mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><b style="mso-bidi-font-weight:
  normal">Figure 3.2.</b> An SLD-tree with infinite branches.</p>
  </td>
 </tr>
</tbody></table>

</div>

<!--[if !supportTextWrap]--><br clear="ALL">
<!--[endif]-->

<p class="tekst">An SLD-tree for the query</p>
<pre class="swish query" id="query3.1.3">
?- brother_of(peter,B).</pre><p class="tekst">
is depicted in fig. 3.2. If we descend this tree taking the left branch at
every node, we will never reach a leaf. On the other hand, if we take the right
branch at every node, we almost immediately reach a success branch. Taking
right branches instead of left branches in an SLD-tree corresponds to searching
the clauses from bottom to top. The same effect would be obtained by reversing
the order of the clauses in the program, and the SLD-tree clearly shows that
this is enough to prevent Prolog from looping on this query. This is a rule of
thumb that applies to most cases: <i style="mso-bidi-font-style:normal">put
non-recursive clauses before recursive ones</i>.</p>

<p class="sektie">However, note that, even after this modification, the program
still has some problems. For one thing, the query <span style="font-family:
Courier">?-brother_of(peter,B)</span> will be answered an infinite number of
times, because there are infinitely many refutations of it. But, even worse,
consider a query that does <b style="mso-bidi-font-weight:normal">not</b> have
an answer, like </p><pre class="swish query" id="query3.1.4">?- brother_of(peter,maria).</pre><p class="sektie">
No matter the order in which the SLD-tree is descended, Prolog will never
discover that the query has in fact no answer, <i style="mso-bidi-font-style:
normal">simply because the SLD-tree is infinite</i>. So, one should be careful
with programs like the above, which define a predicate to be <i style="mso-bidi-font-style:normal">symmetric</i>. <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;symmetric predicates&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1037" type="#_x0000_t75"
   style='width:342pt;height:2in'>
   <v:imagedata src="Part%20I_files/image025.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image026.svg" v:shapes="_x0000_i1037"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 3.3.</b> An
  SLD-tree with infinite branches and expanding resolvents.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Another property of predicates which can cause similar problems
is <i style="mso-bidi-font-style:normal">transitivity</i>. <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;transitive predicates&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->Consider
the following program:</p>

<pre class="source swish temp" data-variant-id="group-2" id="swish.3.1.4" style="display: block;">
brother_of(paul,peter).
brother_of(peter,adrian).
brother_of(X,Y):-brother_of(X,Z),brother_of(Z,Y).
</pre>

<p class="tekst">The third clause ensures that </p><pre class="swish query" id="query3.1.5">?- brother_of(paul,adrian).</pre><p class="tekst">
is a logical consequence of the program. The SLD-tree for the query </p><pre class="swish query" id="query3.1.6">?- brother_of(paul,B).</pre><p class="tekst"> is depicted in fig.
3.3. Not only is this SLD-tree infinite, but the resolvents get longer and
longer on deeper levels in the tree. </p>

<p class="sektie">We have encountered two problems with SLD-resolution: (<i style="mso-bidi-font-style:normal">i</i>) we might never reach a success branch
in the SLD-tree, because we get &lsquo;trapped&rsquo; into an infinite subtree, and (<i style="mso-bidi-font-style:normal">ii</i>) any infinite SLD-tree causes the
inference engine to loop if no (more) answers are to be found. The first
problem means that Prolog is <i style="mso-bidi-font-style:normal">incomplete</i>:
some logical consequences of a program may never be found.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:incompleteness&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>Note carefully that this incompleteness
is <b style="mso-bidi-font-weight:normal">not</b> caused by the inference rule
of resolution, which is refutation complete. Indeed, for any program and any
query, all the possible answers will be represented by success branches in the
SLD-tree. The incompleteness of SLD-resolution<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;SLD-resolution:incompleteness&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is caused by the way the SLD-tree is
searched. </p>

<p class="sektie">There exists a solution to this problem: if we descend the tree
layer by layer rather than branch-by-branch, we will find any leaf before we
descend to the next level. However, this also means that we must keep track of <b style="mso-bidi-font-weight:normal">all</b> the resolvents on a level, instead
of just a single one. Therefore, this <i style="mso-bidi-font-style:normal">breadth-first</i>
search<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;breadth-first</i>
search<i style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>strategy needs much more memory than the <i style="mso-bidi-font-style:normal">depth-first</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;depth-first</i> search<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>strategy used by Prolog. In fact,
Prolog&rsquo;s incompleteness was a deliberate design choice, sacrifying completeness
in order to obtain an efficient use of memory<abar><a style="mso-footnote-id:ftn7" href="#_ftn7" name="_ftnref7" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:
footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:
&quot;Times New Roman&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:
EN-GB;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes">[7]</span></span><!--[endif]--></span></span></span></a></abar>.
As we saw above, this problem can often be avoided by ordering the clauses in
the program in a specific way (which means that we have to take the procedural
meaning of the program into account). </p>

<p class="sektie">As for the second problem, we already saw that this is due to
the semi-decidability of full clausal logic<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;full clausal
logic:decidability&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
which means that there is no general solution to it.</p>



<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.2.</i> Draw
the SLD-tree for the following program:<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">list([]).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>list([H|T]):-list(T).</span><br>
and the query <span style="font-family:Courier">?-list(L)</span>.</p>

</div>

<h3 id="pruning_the_search_by_means_of_cut">3.2<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Pruning the search by means of cut</h3>

<p class="sektie1">As shown in the previous section, Prolog constantly searches
the clauses in a program in order to reach a success branch in the SLD-tree for
a query. If a failure branch is reached (i.e., a non-empty resolvent which
cannot be reduced any further), Prolog has to &lsquo;unchoose&rsquo; the last-chosen
program clause, and try another one. This amounts to going up one level in the
SLD-tree, and trying the next branch to the right. This process of
reconsidering previous choices is called <i style="mso-bidi-font-style:normal">backtracking</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;backtracking&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
Note that backtracking requires that all previous resolvents are remembered for
which not all alternatives have been tried yet, together with a pointer to the
most recent program clause that has been tried at that point. Because of
Prolog&rsquo;s depth-first search<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:depth-first search&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>strategy, we can easily record all
previous resolvents in a <i style="mso-bidi-font-style:normal">goal stack</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:<i
style='mso-bidi-font-style:normal'>goal stack</i>&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
backtracking<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:backtracking&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is then implemented by popping the upper
resolvent from the stack, and searching for the next program clause to resolve
with.</p>

<p class="sektie">As an illustration, consider again the SLD-tree in fig. 3.1.
The resolvent<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;resolvent&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>in the middle branch </p>
<pre class="source swish inherit" inherit-id="swish.3.1.1" data-variant-id="group-1" id="swish.3.2.1" style="display: block;">
teaches(peter,expert_systems).
</pre>
<p class="tekst">cannot be reduced any further, and thus represents a failure
branch<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;failure branch&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
At that point, the stack contains (top-down) the previous resolvents </p>

<pre class="swish query" id="query3.2.1">
?- follows(S,C),teaches(peter,C).
</pre>
<pre class="swish query" id="query3.2.2">
?- student_of(S,peter).
</pre>

<p class="tekst">The top one is popped from the stack; it has been most recently
resolved with <span style="font-family:Courier">follows(paul,expert_systems)</span>,
so we continue searching the program from that clause, finding <span style="font-family:Courier">follows(maria,ai_techniques)</span> as the next
alternative.</p>

<p class="sektie">A node in the SLD-tree which is not a leaf is called a <i style="mso-bidi-font-style:normal">choice point</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;choice point&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
because the subtree rooted at that node may contain several success branches,
each of which may be reached by a different choice for a program clause to
resolve with. Now, suppose a subtree contains only one success branch, yielding
an answer to our query. If we want to know whether there are any alternative
answers, we can force Prolog to backtrack. However, since the rest of the
subtree does not contain any success branches, we might as well skip it
altogether, thus speeding up backtracking. But how do we tell Prolog that a
subtree contains only one success branch? For this, Prolog provides a control
device which is called <i style="mso-bidi-font-style:normal">cut</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;cut&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(written <span style="font-family:Courier">!</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;!/0&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->), because it cuts away (or prunes<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;pruning&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->)
part of the SLD-tree.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1038" type="#_x0000_t75"
   style='width:201pt;height:83pt'>
   <v:imagedata src="Part%20I_files/image027.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image028.svg" v:shapes="_x0000_i1038"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 3.4.</b>
  SLD-tree for the query <br>
  <span style="font-family:Courier">?-parent(john,C)</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">To illustrate the effect of cut, consider the following
program.</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.2.2" style="display: block;"
query-text="?- parent(mary,Y)."
>
parent(X,Y):-father(X,Y).
parent(X,Y):-mother(X,Y).
father(john,paul).
mother(mary,paul).
</pre>
<p class="tekst">The SLD-tree for the query <pre class="swish query" id="query3.2.3">?- parent(john,C).</pre>
is given in fig. 3.4. The answer given by Prolog is {<span style="font-family:
Courier">C</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">paul</span>}. By asking whether there are any other
answers, we force Prolog to backtrack to the most recent choice point for which
there are any alternatives left, which is the root of the SLD-tree (i.e. the
original query). Prolog tries the second clause for <span style="font-family:
Courier">parent</span>, but discovers that this leads to a failure branch.</p>

<p class="sektie">Of course, <b style="mso-bidi-font-weight:normal">we</b> know
that this backtracking step did not make sense: if John is a father of anyone,
he can&rsquo;t be a mother. We can express this by adding a cut to the first <span style="font-family:Courier">parent</span> clause:</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.2.3" query-id="query3.2.3" style="display: block;">
parent(X,Y):-father(X,Y),!.
parent(X,Y):-mother(X,Y).
father(john,paul).
mother(mary,paul).
</pre>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1039" type="#_x0000_t75"
   style='width:3in;height:121pt'>
   <v:imagedata src="Part%20I_files/image029.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image030.svg" v:shapes="_x0000_i1039"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 3.5.</b>
  The effect of cut.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="tekst">The cut says: <i style="mso-bidi-font-style:normal">once you&rsquo;ve
reached me, stick to all the variable substitutions you&rsquo;ve found after you
entered my clause</i>. That is: don&rsquo;t try to find any alternative solutions to
the literals left of the cut, and also: don&rsquo;t try any alternative clauses for
the one in which the cut is found. Given this modified program, the SLD-tree
for the same query is shown in fig. 3.5. Since <span style="font-family:Courier">!</span>
is true by definition, the resolvent <span style="font-family:Courier">:-!</span>
reduces to the empty clause. The shaded part represents the part of the
SLD-tree which is pruned as a result of the cut. That is: every alternative at
choice points below and including <span style="font-family:Courier">?-parent(john,C)</span>,
which are on the stack when the cut is reached, are pruned. Note carefully that
a cut does not prune <b style="mso-bidi-font-weight:normal">every</b> choice
point<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;choice point:pruning of&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
First of all, pruning does not occur above the choice point containing the head
of the clause in which the cut is found. Secondly, choice points created by
literals to the right of the cut, which are below the cut in the SLD-tree but
are not yet on the stack when the cut is reached, are not pruned either (fig.
3.6). </p>

<p class="sektie">A cut is harmless if it does not cut away subtrees containing
success branches.<!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;success branch:pruning of&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>If a cut prunes success branches, then
some logical consequences of the program are not returned as answers, resulting
in a procedural meaning different from the declarative meaning. Cuts of the
first kind are called <i style="mso-bidi-font-style:normal">green</i> cut<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;green</i> cut<i style='mso-bidi-font-style:
normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s,
while cuts of the second kind are called <i style="mso-bidi-font-style:normal">red</i>
cut<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;red</i> cut<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s.
A green cut merely stresses that the conjunction of literals to its left is <i style="mso-bidi-font-style:normal">deterministic</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;deterministic</i> literals<i
style='mso-bidi-font-style:normal'>&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
it does not give alternative solutions. In addition, it signifies that if those
literals give a solution, the clauses below it will not result in any
alternatives.</p>

<p class="sektie">This seems to be true for the above program: John is the father
of only one child, and no-one is both a father and a mother. However, note that
we only analysed the situation with regard to a particular query. We can show
that the cut is in fact red by asking the query </p><pre class="swish query" id="query3.2.3" source-id="swish.3.2.2 swish.3.2.3">?- parent(P,paul).</pre><p class="sektie">
(fig. 3.7). The answer {<span style="font-family:Courier">P</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">mary</span>}
is pruned by the cut. That is, the </p>

<span style="font-size:10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;
mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:
EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes"><br clear="all" style="page-break-before:
always">
</span>

<p class="sektie" style="text-indent:0cm">literal <span style="font-family:Courier">father(X,Y)</span>
left to the cut is only deterministic if <span style="font-family:Courier">X</span>
is <i style="mso-bidi-font-style:normal">instantiated</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;instantiated&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(is substituted by a non-variable value).</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1040" type="#_x0000_t75"
   style='width:174pt;height:263pt'>
   <v:imagedata src="Part%20I_files/image031.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image032.svg" v:shapes="_x0000_i1040"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 3.6.</b>
  Cut prunes away alternative solutions for <span style="font-family:Courier">s</span>,
  but not for <span style="font-family:Courier">t</span>. Also, choice points
  above <span style="font-family:Courier">:&#8209;q(X,Y)</span> are not pruned.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Note that success branches are also pruned for the first query
if John has several children:</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.2.4" style="display: block;"
query-text="?- parent(mary,Y)."
>
parent(X,Y):-father(X,Y),!.
parent(X,Y):-mother(X,Y).
father(john,paul).
father(john,peter).
mother(mary,paul).
mother(mary,peter).
</pre>

<p class="tekst">The SLD-tree for the query </p><pre class="swish query" id="query3.2.4">?- parent(john,C).</pre><p class="tekst">
is given in fig. 3.8. Indeed, the second answer {<span style="font-family:Courier">C</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>}
is pruned by the cut. This clearly shows that the effect of a cut is not only
determined by the clause in which it occurs but also by other clauses.
Therefore, the effect of a cut is often hard to understand. </p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="small-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1041" type="#_x0000_t75"
   style='width:212pt;height:120pt'>
   <v:imagedata src="Part%20I_files/image033.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image034.svg" v:shapes="_x0000_i1041"><!--[endif]--></p>
  </div>
  <p class="small-caption"><b style="mso-bidi-font-weight:normal">Figure 3.7.</b>
  A success branch is pruned.</p>
  </td>
 </tr>
</tbody></table>

</div>

<div style="mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
margin;mso-element-top:bottom;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><!--[if gte vml 1]><v:shape
   id="_x0000_i1042" type="#_x0000_t75" style='width:204pt;height:122pt'>
   <v:imagedata src="Part%20I_files/image035.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image036.svg" v:shapes="_x0000_i1042"><!--[endif]--></p>
  </div>
  <p class="med-caption" style="mso-element:frame;mso-element-wrap:auto;
  mso-element-anchor-horizontal:margin;mso-element-top:bottom;mso-height-rule:
  exactly"><b style="mso-bidi-font-weight:normal">Figure 3.8.</b> Another
  success branch is pruned.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Programs with cuts are not only difficult to understand; this
last example also shows that their procedural interpretation<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;procedural
interpretation&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(the set of answers they produce to a
query) may be different from their declarative interpretation<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;declarative
interpretation&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(the set of its logical consequences).
Logically, cut has no meaning: it always evaluates to <b style="mso-bidi-font-weight:
normal">true</b>, and therefore it can always be added or removed from the body
of a clause without affecting its declarative interpretation. Procedurally, cut
may have many effects, as the preceding examples show. This<br style="mso-special-character:line-break">
<!--[if !supportLineBreakNewLine]--><br style="mso-special-character:line-break">
<!--[endif]--></p>

<p class="sektie" style="text-indent:0cm"><span style="mso-spacerun:yes">&nbsp;</span>incompatibility between declarative and
procedural interpretation makes it a very problematic concept.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;cut:problems
with&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>Much research in Logic Programming aims
at replacing it by higher-level constructs which have cleaner declarative
meanings and which are easier to understand. The most important of these will
be considered in the next two sections. </p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.3.</i> Draw
the SLD-tree for the query <span style="font-family:Courier">?-likes(A,B)</span>,
given the following program:<br>
<span style="font-family:Courier"><span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>likes(peter,Y):-friendly(Y).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>likes(T,S):-student_of(S,T).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>student_of(maria,peter).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>student_of(paul,peter).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>friendly(maria).<br>
</span>Add a cut in order to prune away one of the answers {<span style="font-family:Courier">A</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>, <span style="font-family:Courier">B</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">maria</span>},
and indicate the result in the SLD-tree. Can this be done without pruning away
the third answer?<span style="font-family:Courier"><o:p></o:p></span></p>
</div>

<h3 id="negation_as_failure">3.3<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Negation as
failure</h3>

<p class="sektie1">The following program computes the maximum of two integers: </p>


<pre class="source swish" data-variant-id="group-2" id="swish.3.3.1" style="display: block;">
max(M,N,M):- M >= N.
max(M,N,N):- M =< N.
</pre>


<p class="tekst"><span style="font-family:Courier">&gt;=</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;&gt;=/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>and <span style="font-family:Courier">=&lt;</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=&lt;/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>are built-in predicates with meaning
&lsquo;greater than or equal&rsquo; and &lsquo;less than or equal&rsquo;, respectively<abar><a style="mso-footnote-id:ftn8" href="#_ftn8" name="_ftnref8" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[8]</span></span><!--[endif]--></span></span></span></a></abar>.
Declaratively, the program captures the intended meaning, but procedurally
there are two different ways to solve queries of the form <span style="font-family:Courier">?-max(N,N,M)</span>. The reason for this is that
the bodies of the two clauses are not exclusive: they both succeed if the first
two values of the <span style="font-family:Courier">max</span> predicate are
equal. We could of course remove one of the equality symbols, but suppose that
we use a cut instead:</p>


<pre class="source swish" data-variant-id="group-2" id="swish.3.3.2" style="display: block;"
query-text="?- max(3,X,6).">
max(M,N,M):- M >= N,!.
max(_M,N,N).
</pre>

<p class="tekst">With a red cut, this program can only be understood
procedurally. The question is: does the procedural meaning correspond to the
intended meaning? Perhaps surprisingly, the answer is no! For instance, the
query </p>

<pre class="swish query" id="query3.3.1" source-id="swish.3.3.1 swish.3.3.2">
?- max(5,3,X).
</pre>
<p class="tekst">succeeds: the cut is never reached, because the literal in the
query does not unify with the head of the first clause. The second program is
in fact a very bad program: the declarative and procedural meanings differ, and
<b style="mso-bidi-font-weight:normal">neither</b> of them captures the
intended meaning.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
margin;mso-element-left:center;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-wrap:auto;mso-element-anchor-horizontal:
  margin;mso-element-left:center;mso-height-rule:exactly"><i style="mso-bidi-font-style:
  normal">Exercise 3.4.</i> Show that this cut is red, by drawing an SLD-tree
  in which a success branch is pruned.</p>

  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">The procedural meaning of the program would be correct if its
use is restricted to queries with uninstantiated third argument. It illustrates
a very common use of cut: to ensure that the bodies of the clauses are mutually
exclusive. In general, if we have a program of the form</p>

<p class="p-el">p:-q,!,r.<br>
p:-s.</p>

<p class="tekst">its meaning is something like</p>

<p class="p-el">p:-q,r.<br>
p:-not_q,s.</p>

<p class="tekst">How should <span style="font-family:Courier">not_q</span> be
defined, in order to make the second program work? If <span style="font-family:
Courier">q</span> succeeds, <span style="font-family:Courier">not_q</span>
should fail. This is expressed by the following clause:</p>

<p class="p-el">not_q:-q,fail</p>

<p class="tekst">where <span style="font-family:Courier">fail</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;fail/0&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is a built-in predicate, which is always <b style="mso-bidi-font-weight:normal">false</b>. If <span style="font-family:
Courier">q</span> fails, <span style="font-family:Courier">not_q</span> should
succeed. This can be realised by the program</p>

<p class="p-el">not_q:-q,!,fail.<br>
not_q.</p>

<p class="tekst">The cut in the first clause is needed to prevent backtracking to
the second clause when <span style="font-family:Courier">q</span> succeeds.</p>

<p class="sektie">This approach is not very practical, because it only works for
a single proposition symbol, without variables. We would like to treat the
literal to be negated as a parameter, as in</p>

<p class="p-el">
not(Goal):- /* execute Goal, */ !,fail. <br/>
not(Goal).
</p>
<p class="tekst">The problem now is to execute a goal which is passed to the
predicate <span style="font-family:Courier">not</span> as a term. Prolog
provides two facilities for this. One is the built-in predicate <span style="font-family:Courier">call</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;call/1&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->, which takes a goal as argument and
succeeds if and only if execution of that goal succeeds. The second facility<abar><a style="mso-footnote-id:ftn9" href="#_ftn9" name="_ftnref9" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[9]</span></span><!--[endif]--></span></span></span></a></abar>
is merely a shorthand for this: instead of writing <span style="font-family:
Courier">call(Goal)</span>, one may simply write <span style="font-family:Courier">Goal</span>,
as in</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.3.2" style="display: block;"
query-text="?- not(true). ?- not(false).">
not(Goal):- Goal,!,fail.
not(_Goal).
</pre>

<p class="tekst">This is a slight abuse of the syntax rules, because a variable
(a term) occurs in a position where only atoms are allowed.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;variable:in literal
position&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>As long as the variable is instantiated
to a goal before it is reached, this will, however, cause no problem (if it is
not correctly instantiated, Prolog will generate an error-message). Predicates
like <span style="font-family:Courier">not</span> and <span style="font-family:
Courier">call</span> are called <i style="mso-bidi-font-style:normal">meta-predicate</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-predicate&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>, that take formulas from the same
logical language in which they are written as arguments. As we will see in
later chapters, meta-predicates play an important role in this book. <b style="mso-bidi-font-weight:normal"><o:p></o:p></b></p>

<div style="mso-element:frame;mso-element-frame-hspace:9.05pt;mso-element-frame-vspace:
9.05pt;mso-element-wrap:no-wrap-beside;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.05pt;padding-right:9.05pt;
  padding-bottom:9.05pt;padding-left:9.05pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-frame-hspace:9.05pt;
  mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;mso-height-rule:
  exactly"><!--[if gte vml 1]><v:shape id="_x0000_i1043" type="#_x0000_t75"
   style='width:127pt;height:137pt'>
   <v:imagedata src="Part%20I_files/image037.emz" o:title="" croptop="-1195f"
    cropbottom="-1195f" cropleft="-3870f" cropright="-3870f"/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image038.svg" v:shapes="_x0000_i1043"><!--[endif]--></p>
  </div>
  <p class="med-caption" style="mso-element:frame;mso-element-frame-hspace:9.05pt;
  mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;mso-height-rule:
  exactly"><b style="mso-bidi-font-weight:normal">Figure 3.9.</b> SLD-tree with
  <span style="font-family:Courier">not</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<!--[if !supportTextWrap]--><br clear="ALL">
<!--[endif]-->

<div style="mso-element:frame;mso-element-frame-hspace:9.05pt;mso-element-frame-vspace:
9.05pt;mso-element-wrap:no-wrap-beside;mso-element-anchor-horizontal:margin;
mso-element-top:bottom;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.05pt;padding-right:9.05pt;
  padding-bottom:9.05pt;padding-left:9.05pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="small-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;mso-element:frame;mso-element-frame-hspace:9.05pt;
  mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;mso-element-anchor-horizontal:
  margin;mso-element-top:bottom;mso-height-rule:exactly"><!--[if gte vml 1]><v:shape
   id="_x0000_i1044" type="#_x0000_t75" style='width:104pt;height:102pt'>
   <v:imagedata src="Part%20I_files/image039.emz" o:title="" croptop="-1927f"
    cropbottom="-1927f" cropleft="-11972f" cropright="-11972f"/>
  </v:shape><![endif]--><!--[if !vml]--><img width=70% src="Part%20I_files/image040.svg" v:shapes="_x0000_i1044"><!--[endif]--></p>
  </div>
  <p class="small-caption" style="mso-element:frame;mso-element-frame-hspace:
  9.05pt;mso-element-frame-vspace:9.05pt;mso-element-wrap:no-wrap-beside;
  mso-element-anchor-horizontal:margin;mso-element-top:bottom;mso-height-rule:
  exactly"><b style="mso-bidi-font-weight:normal">Figure 3.10.</b> Equivalent
  SLD-tree with cut.</p>
  </td>
 </tr>
</tbody></table>

</div>

<!--[if !supportTextWrap]--><br clear="ALL">
<!--[endif]-->

<p class="sektie">We illustrate the operation of <span style="font-family:Courier">not</span>
by means of the following propositional program:</p>

<p class="p-el">p:-q,r.<br>
p:-not(q),s.<br>
s.</p>

<p class="tekst">and the query <span style="font-family:Courier">?-p</span>. The
SLD-tree is shown in fig. 3.9. The first clause for <span style="font-family:
Courier">p</span> leads to a failure branch, because <span style="font-family:
Courier">q</span> cannot be proved. The second clause for <span style="font-family:Courier">p</span> is tried, and <span style="font-family:
Courier">not(q)</span> is evaluated by trying to prove <span style="font-family:
Courier">q</span>. Again, this fails, which means that the second clause for <span style="font-family:Courier">not</span> is tried, which succeeds. Thus, <span style="font-family:Courier">not(q)</span><i style="mso-bidi-font-style:normal">
is proved by failing to prove</i> <span style="font-family:Courier">q</span>!
Therefore, this kind of negation is called <i style="mso-bidi-font-style:normal">negation
as failure</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;negation as
failure&quot; \b </i><![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
</p>

<p class="sektie">Fig. 3.9 shows, that Prolog tries to prove <span style="font-family:Courier">q</span> twice. Consequently, the program with <span style="font-family:Courier">not</span> is slightly less efficient than the
version with cut:</p>

<p class="p-el">p:-q,!,r.<br>
p:-s.<br>
s.</p>

<p class="tekst">which leads to the SLD-tree shown in fig. 3.10. Here, <span style="font-family:Courier">q</span> is tried only once. However, in general we
prefer the use of <span style="font-family:Courier">not</span>, because it
leads to programs of which the declarative meaning corresponds more closely to
the procedural meaning.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
  <p class="med-figure" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm"><!--[if gte vml 1]><v:shape id="_x0000_i1045" type="#_x0000_t75"
   style='width:157pt;height:182pt'>
   <v:imagedata src="Part%20I_files/image041.emz" o:title="" croptop="-900f"
    cropbottom="-900f" cropleft="-11479f" cropright="-11479f"/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image042.svg" v:shapes="_x0000_i1045"><!--[endif]--></p>
  </div>
  <p class="med-caption"><b style="mso-bidi-font-weight:normal">Figure 3.11.</b> <span style="font-family:Courier">:-not(q)</span> fails because <span style="font-family:Courier">:-q</span> succeeds.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">In the following program, <span style="font-family:Courier">:-not(q)</span>
fails because <span style="font-family:Courier">:-q</span> succeeds: </p>

<p class="p-el">p:-not(q),r.<br>
p:-q.<br>
q.<br>
r.</p>

<p class="tekst">The SLD-tree for the query <span style="font-family:Courier">?-p</span>
is shown in fig. 3.11. Since <span style="font-family:Courier">q</span>
succeeds, <span style="font-family:Courier">fail</span> ensures that <span style="font-family:Courier">not(q)</span> fails. The cut is needed to ensure
that everything following the <span style="font-family:Courier">not</span> is
pruned, even if it contains a success branch.</p>

<p class="sektie">The implementation of <span style="font-family:Courier">not</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;not/1</span>:problems with<span
style='font-family:Courier'>&quot; </span><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>illustrated above can lead to problems if
variables are involved. Take a look at the following program:</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.3.3" style="display: block;"
query-text="?- bachelor(fred). ?- bachelor(peter).">
bachelor(X):-man(X),not(married(X)).
man(fred).
man(peter).
married(fred).
</pre>


<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.5.</i> Draw
the SLD-trees for the queries <span style="font-family:Courier">?-bachelor(fred)</span>
and <br>
<span style="font-family:Courier">?-bachelor(peter)</span>.</p>
</div>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1046" type="#_x0000_t75"
   style='width:245pt;height:192pt'>
   <v:imagedata src="Part%20I_files/image043.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=100% src="Part%20I_files/image044.svg" v:shapes="_x0000_i1046"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 3.12.</b>
  There are no bachelors?!</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Consider the query </p>
<pre class="query" id="query3.3.2"><span class="swish query">
?- bachelor(X).
</pre>
<p class="tekst">for which the SLD-tree is depicted in fig. 3.12. According to
negation as failure, Prolog tries to prove <span style="font-family:Courier">not(married(X))</span>
by trying <span style="font-family:Courier">married(X)</span> first. Since this
succeeds for <span style="font-family:Courier">X</span>=<span style="font-family:
Courier">fred</span>, the cut is reached and the success branch to the right
(representing the correct answer {<span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">peter</span>})
is pruned. Thus, <span style="font-family:Courier">:&#8209;not(married(X))</span>
fails because <span style="font-family:Courier">:&#8209;married(X)</span>
succeeds for one value of <span style="font-family:Courier">X</span>. That is, <span style="font-family:Courier">not(married(X))</span> is interpreted as &lsquo;it is
false that somebody is married&rsquo;, or equivalently, &lsquo;nobody is married&rsquo;. But this
means that the clause </p>

<p class="p-el">bachelor(X):-not(married(X)),man(X)</p>

<p class="tekst">is interpreted as &lsquo;<i style="mso-bidi-font-style:normal">X</i>
is a bachelor if nobody is married and <i style="mso-bidi-font-style:normal">X</i>
is a man&rsquo;, which is of course not as intended.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Negation as failure vs. logical negation<!--[if supportFields]><span
  style='mso-element:field-begin'></span> XE<span
  style="mso-spacerun:yes">&nbsp; </span>&quot;Negation as failure: vs. logical
  negation&quot; <![endif]--><!--[if supportFields]><span style='mso-element:
  field-end'></span><![endif]--></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Negation as failure is not the same as logical negation: if we
  cannot prove <span style="font-family:Courier">q</span>, we know that <span style="font-family:Courier">q</span> is not a logical consequence of the
  program, but this does not mean that its negation <span style="font-family:
  Courier">:-q</span> is a logical consequence of the program. Adopting
  negation as failure is similar to saying &lsquo;I cannot prove that God exists,
  therefore I conclude God does not exist&rsquo;. It is a kind of reasoning that is
  applicable in some contexts, but inadequate in others. Logical negation can
  only be expressed by <br>
  indefinite clauses, as in the following program:</p>
  <p class="intermezzo" align="left" style="margin-top:0cm;margin-right:0cm;
  margin-bottom:6.0pt;margin-left:0cm;text-align:left;tab-stops:170.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto"><span style="font-family:Courier"><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p:-q,r.<br>
  <span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>p;q:-s.<br>
  <span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>s.<o:p></o:p></span></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Semantically speaking, if we don&rsquo;t have enough information to
  conclude that a formula <i style="mso-bidi-font-style:normal">F</i> is true
  or false, the truth value of its logical negation will also be undecided, but
  <span style="font-family:Courier">not</span>(<i style="mso-bidi-font-style:
  normal">F</i>) will be true. This property of negation as failure can be very
  useful when dealing with exceptions to rules: if we don&rsquo;t know that something
  is an exception to a rule, we assume that it&rsquo;s not, so we only have to list
  the exceptions and not the normal cases. This approach will be extensively
  discussed in Chapter 8 on reasoning with incomplete information. </p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">Thus, if <span style="font-family:Courier">G</span> is
instantiated<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;instantiated&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>to a goal containing variables at the
time <span style="font-family:Courier">not(G)</span> is called, the result may
be not in accordance with negation as failure<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;negation as
failure:problems with&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
<i style="mso-bidi-font-style:normal">It is the programmer&rsquo;s responsibility to
avoid this.</i> A simple remedy that will often work is to ensure the grounding
of <span style="font-family:Courier">G</span> by literals preceding <span style="font-family:Courier">not(G)</span> in the body of the clause, i.e.</p>

<p class="p-el">bachelor(X):-man(X),not(married(X))</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.6.</i> Show
that the modified program produces the right answer, by drawing the SLD-tree
for the query <span style="font-family:Courier">?-bachelor(X)</span>.</p>

</div>

<p class="sektie">Thus, we see that changing the order of the literals in the
body of a clause does not only affect the order in which answers to a query are
found, but it may also change the set of answers! Of course, this is very much
against the spirit of declarative programming, because the declarative
interpretation<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;declarative interpretation&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>of a clause does not depend on the order
of the literals. Therefore, some Prolog interpreters provide a mechanism which
defers the evaluation of <span style="font-family:Courier">not(G)</span> until <span style="font-family:Courier">G</span> is ground. However, with standard Prolog
it is the programmer&rsquo;s duty to ensure that <span style="font-family:Courier">not</span>
is never called with a non-ground argument.</p>

<p class="sektie">Let&rsquo;s summarise the points made about negation in Prolog. It is
often used to ensure that only one of several possible clauses is applicable.
The same effect can be achieved by means of cut, but in general we prefer the
use of <span style="font-family:Courier">not</span>, although it is somewhat
less efficient<abar><a style="mso-footnote-id:ftn10" href="#_ftn10" name="_ftnref10" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;
mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[10]</span></span><!--[endif]--></span></span></span></a></abar>.
<span style="font-family:Courier">not</span> is supplied by Prolog as a
meta-predicate (i.e. a predicate which takes formulas from the same logical
language in which it is written as arguments). It is only a partially correct
implementation of negation as failure, since it does not operate correctly when
its argument is a goal containing variables.</p>

<h3 id="other_uses_of_cut">3.4<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Other uses of
cut</h3>

<p class="sektie1">Consider the following propositional program:</p>

<p class="p-el">p:-q,r,s,!,t.<br>
p:-q,r,u.<br>
q.<br>
r.<br>
u.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.7.</i> Show
that the query <span style="font-family:Courier">?-p</span> succeeds, but that <span style="font-family:Courier">q</span> and <span style="font-family:Courier">r</span>
are tried twice.</p>
</div>

<p class="tekst">This inefficiency can be avoided by putting <span style="font-family:Courier">s,!</span> at the beginning of the body of the
first clause. However, in full clausal logic the goals preceding <span style="font-family:Courier">s</span> might supply necessary variable bindings,
which requires them to be called first. A possible solution would be the
introduction of an extra proposition symbol:</p>

<p class="p-el">p:-q,r,if_s_then_t_else_u.<br>
if_s_then_t_else_u:-s,!,t.<br>
if_s_then_t_else_u:-u.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">
<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.8.</i> Show
that <span style="font-family:Courier">q</span> and <span style="font-family:
Courier">r</span> are now tried only once.</p>
</div>

<p class="sektie">Just as we did with <span style="font-family:Courier">not</span>,
we can rewrite this new proposition symbol to a generally applicable
meta-predicate:</p>

<p class="p-el">if_then_else(S,T,U):-S,!,T.<br>
if_then_else(S,T,U):-U.</p>

<p class="tekst">Note that we can nest applications of <span style="font-family:
Courier">if_then_else</span>, for instance</p>

<p class="pi-el">if_then_else_else(P,Q,R,S,T):-<br>
if_then_else(P,Q,if_then_else(R,S,T)).</p>

<p class="tekst">Unfolding the definition of <span style="font-family:Courier">if_then_else</span>
yields</p>

<p class="p-el">if_then_else_else(P,Q,R,S,T):-P,!,Q.<br>
if_then_else_else(P,Q,R,S,T):-R,!,S.<br>
if_then_else_else(P,Q,R,S,T):-T.</p>

<p class="tekst">which clearly shows the meaning of the predicate: &lsquo;if <i style="mso-bidi-font-style:normal">P</i> then <i style="mso-bidi-font-style:
normal">Q</i> else if <i style="mso-bidi-font-style:normal">R</i> then <i style="mso-bidi-font-style:normal">S</i> else <i style="mso-bidi-font-style:
normal">T</i> &rsquo;. This resembles the CASE-statement of procedural languages,
only the above notation is much more clumsy. Most Prolog interpreters provide
the notation <span style="font-family:Courier">P-&gt;</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;-&gt;/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="font-family:Courier">Q;R</span>
for if-then-else<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;if-then-else&quot; \b <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->;
the nested variant then becomes <span style="font-family:Courier">P-&gt;Q;(R-&gt;S;T)</span>.
The parentheses are not strictly necessary, but in general the outermost
if-then-else literal should be enclosed in parentheses. A useful lay-out is
shown by the following program:</p>

<p class="pi-el" style="tab-stops:123.0pt 147.0pt">diagnosis(Patient,Condition):-<br>
temperature(Patient,T),<br>
( T=&lt;37<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>-&gt;<span style="mso-tab-count:1">&nbsp; </span>blood_pressure(Patient,Condition)<br>
; T&gt;37,T&lt;38<span style="mso-tab-count:1">&nbsp; </span>-&gt;<span style="mso-tab-count:1">&nbsp; </span>Condition=ok<br>
; otherwise<span style="mso-tab-count:1">&nbsp; </span>-&gt;<span style="mso-tab-count:1">&nbsp; </span>diagnose_fever(Patient,Condition)<br>
).</p>

<p class="tekst"><span style="font-family:Courier">otherwise</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;otherwise/0&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is always assigned the truthvalue <b style="mso-bidi-font-weight:normal">true</b>, so the last rule applies if all
the others fail.</p>

<p class="sektie"><span style="font-family:Courier">not</span> and if-then-else
show that many uses of cut can be replaced by higher-level constructs, which
are easier to understand. However, this is not true for every use of cut. For
instance, consider the following program: </p>

<p class="pi-eerst">play(Board,Player):-<br>
lost(Board,Player).</p>

<p class="pi-laatst">play(Board,Player):-<br>
find_move(Board,Player,Move),<br>
make_move(Board,Move,NewBoard),<br>
next_player(Player,Next),<br>
play(NewBoard,Next).</p>

<p class="tekst">This program plays a game by recursively looking for best moves.
Suppose one game has been finished; that is, the query <span style="font-family:
Courier">?-play(Start,First)</span> (with appropriate instantiations of the
variables) has succeeded. As usual, we can ask Prolog whether there are any
alternative solutions. Prolog will start backtracking, looking for alternatives
for the most recent move, then for the move before that one, and so on. That
is, <i style="mso-bidi-font-style:normal">Prolog has maintained all previous
board situations, and every move made can be undone</i>. Although this seems a
desirable feature, in reality it is totally unpractical because of the memory
requirements<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;memory requirements&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
after a few moves you would get a stack overflow. In such cases, we tell Prolog
not to reconsider any previous moves, by placing a cut just before the
recursive call. This way, we pop the remaining choice points from the stack
before entering the next recursion. In fact, this technique results in a use of
memory similar to that of iterative loops in procedural languages.</p>

<p class="sektie">Note that this only works if the recursive call is the last
call in the body. In general, it is advisable to write your recursive
predicates like <span style="font-family:Courier">play</span> above: the
non-recursive clause before the recursive one, and the recursive call at the
end of the body. A recursive predicate written this way is said to be <i style="mso-bidi-font-style:normal">tail recursive</i>.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;tail
recursion&quot; \b <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>If in addition the literals before the
recursive call are deterministic (yield only one solution), some Prolog
interpreters may recognise this and change recursion into iteration. This
process is called <i style="mso-bidi-font-style:normal">tail recursion
optimisation</i><!--[if supportFields]><i style='mso-bidi-font-style:normal'><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;tail recursion</i>:<i
style='mso-bidi-font-style:normal'> optimisation&quot; </i><![endif]--><!--[if supportFields]><i
style='mso-bidi-font-style:normal'><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span></i><![endif]-->. As illustrated
above, you can force this optimisation by placing a cut before the recursive
call.</p>

<h3 id="arithmetic_expressions">3.5<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Arithmetic
expressions</h3>

<p class="sektie1">In Logic Programming, recursion<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;recursion&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is the only looping control structure.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:loops&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>Consequently, recursive datatypes<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;recursive
datatypes&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>such as lists can be expressed very
naturally. Natural numbers also have a recursive nature: &lsquo;0 is a natural
number, and if <i style="mso-bidi-font-style:normal">X</i> is a natural number,
then the successor of <i style="mso-bidi-font-style:normal">X</i> is also a
natural number&rsquo;. In Prolog, this is expressed as</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.5.0" style="display: block;"
query-text="?- nat(s(s(0))).">
nat(0).
nat(s(X)):-nat(X).
</pre>

<p class="tekst">Addition of natural numbers is defined in terms of successors:</p>

<pre class="source swish temp" data-variant-id="group-2" id="swish.3.5.1" style="display: block;"
query-text="?- add(s(s(0)),Y,s(s(s(0)))).">
add(0,X,X).
add(s(X),Y,s(Z)):-add(X,Y,Z).
</pre>

<p class="tekst">The following query asks for the sum of two and three: </p>

<pre class="swish query" id="query3.5.1">
?- add(s(s(0)),s(s(s(0))),Z).
</pre>
<p class="p-el">Z = s(s(s(s(s(0)))))</p>

<p class="tekst">We can also find an <i style="mso-bidi-font-style:normal">X</i>
such that the sum of <i style="mso-bidi-font-style:normal">X</i> and <i style="mso-bidi-font-style:normal">Y</i> is <i style="mso-bidi-font-style:normal">Z</i>
(i.e., subtract <i style="mso-bidi-font-style:normal">Y</i> from <i style="mso-bidi-font-style:normal">Z</i>): </p>


<pre class="swish query" id="query3.5.1">
?- add(X,s(s(s(0))),s(s(s(s(s(0)))))).
</pre>
<p class="p-el">X = s(s(0))</p>

<p class="tekst">We can even find all <i style="mso-bidi-font-style:normal">X</i>
and <i style="mso-bidi-font-style:normal">Y</i> which add up to a given sum.
Thus, this program is fully declarative. Similarly, multiplication is repeated
addition:</p>


<pre class="source swish inherit" data-variant-id="group-2" id="swish.3.5.2" inherit-id="swish.3.5.1" style="display: block;"
query-text="?- mul(0,X,0). ?- mul(s(s(0)),s(s(s(0))),Z).">
mul(0,_X,0).
mul(s(X),Y,Z):-mul(X,Y,Z1),add(Y,Z1,Z).
</pre>

<p class="sektie">There are two problems with this approach to representing and
manipulating natural numbers. First, naming natural numbers by means of the
constant symbol <span style="font-family:Courier">0</span> and the functor <span style="font-family:Courier">s</span> is very clumsy, especially for large
numbers. Of course, it would be possible to write a translator from decimal
notation to successor notation, and back. However, the second problem is more
fundamental: multiplication as repeated addition is extremely inefficient
compared to the algorithm for multiplicating numbers in decimal notation.
Therefore, Prolog has built-in arithmetic facilities, which we will discuss
now.</p>

<p class="sektie">Consider the arithmetic expression <span style="font-family:
Courier">5+7-3</span>. Prolog will view this expression as the term <span style="font-family:Courier">+(5,-(7,3))</span>, with the functors <span style="font-family:Courier">+</span> and <span style="font-family:Courier">-</span>
written as infix operators. We want to <i style="mso-bidi-font-style:normal">evaluate</i>
this expression, i.e. we want a single numerical value which represents somehow
the same number as the expression. A program for doing this would look
something like</p>

<p class="pi-eerst">is(V,E1+E2):-<br>
is(V1,E1),is(V2,E2),<br>
fast_add(V1,V2,V).</p>

<p class="pi">is(V,E1-E2):-<br>
is(V1,E1,),is(V2,E2),<br>
fast_sub(V1,V2,V).</p>

<p class="pi-laatst">is(E,E):-<br>
number(E).</p>

<p class="tekst">Here, <span style="font-family:Courier">fast_add</span> and <span style="font-family:Courier">fast_sub</span> represent the fast, built-in
procedures for addition and subtraction, which are not directly available to
the user. These procedures are <b style="mso-bidi-font-weight:normal">not</b>
reversible: its first two arguments must be instantiated. Therefore, the
predicate <span style="font-family:Courier">is</span> will include a test for
groundness of its second argument (the arithmetic expression), and will quit
with an error-message if this test fails.</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Operator<!--[if supportFields]><span style='display:none;
  mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;Operator&quot; \b <![endif]--><!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->s</p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">In Prolog, functors and predicates are collectively called <i style="mso-bidi-font-style:normal">operators</i>. An operator is declared by
  the query <span style="font-family:Courier">?-op</span><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-begin'></span> XE </span><span style='font-family:Courier'><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;op/3&quot; </span><![endif]--><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-end'></span></span><![endif]--><span style="font-family:Courier">(Priority,Type,Name)</span>,
  where <span style="font-family:Courier">Priority</span> is a number between 0
  and 1200 (lower priority binds stronger), and <span style="font-family:Courier">Type</span>
  is <span style="font-family:Courier">fx</span> or <span style="font-family:
  Courier">fy</span> for prefix, <span style="font-family:Courier">xfx</span>, <span style="font-family:Courier">xfy</span> or <span style="font-family:Courier">yfx</span>
  for infix, and <span style="font-family:Courier">xf</span> or <span style="font-family:Courier">yf</span> for postfix. The <span style="font-family:Courier">x</span> and <span style="font-family:Courier">y</span>
  determine associativity: for instance, <span style="font-family:Courier">xfx</span>
  means not associative (you cannot write <span style="font-family:Courier">X
  op Y op Z</span>, but must either write <span style="font-family:Courier">(X
  op Y) op Z</span> or <span style="font-family:Courier">X op (Y op Z)</span>),
  <span style="font-family:Courier">xfy</span> means right-associative (<span style="font-family:Courier">X op Y op Z</span> means <span style="font-family:
  Courier">op(X,op(Y,Z))</span>), and <span style="font-family:Courier">yfx</span>
  means left-associative (<span style="font-family:Courier">X op Y op Z</span>
  means <span style="font-family:Courier">op(op(X,Y),Z)</span>). Every special
  symbol of Prolog, such as &lsquo;<span style="font-family:Courier">:-</span>&rsquo; and &lsquo;<span style="font-family:Courier">,</span>&rsquo; (conjunction<!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;conjunction&quot;
  <![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
  style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>in the body of a clause), is a predefined
  operator. The interpretation of operators can be visualised by means of the
  predicate <span style="font-family:Courier">display</span>, which writes a
  term without operators. For instance, <br>
  the query <span style="font-family:Courier">?-display((p:-q,r,s))</span>
  writes <span style="font-family:Courier">:-(p,','(q,','(r,s)))</span>. <br>
  The extra parentheses are needed because <span style="font-family:Courier">:-</span>
  binds very weakly.</p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">The <span style="font-family:Courier">is</span> predicate is a
built-in feature of Prolog, and is declared as an infix operator. Its behaviour
is illustrated by the following queries: </p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.5.4" style="display: block;"
query-text="?- X is 5+7-3. ?- 9 is 5+7-3. ?- 9 is X+7-3. ?- X is 5*3+7/2.">
% Run prolog.
</pre>

<p class="query" style="page-break-after:auto">?-X is 5+7-3<br>
X = 9</p>

<p class="query" style="page-break-after:auto">?-9 is 5+7-3<br>
Yes</p>

<p class="query" style="page-break-after:auto">?-9 is X+7-3<br>
Error in arithmetic expression</p>

<p class="query" style="margin-bottom:6.0pt;page-break-after:auto">?-X is 5*3+7/2<br>
X = 18.5</p>

<p class="tekst">The last example shows, that arithmetic expressions obey the
usual precedence rules (which can be overruled using parentheses). Also, note
that the <span style="font-family:Courier">is</span> predicate can handle real
numbers.</p>

<p class="sektie">Prolog also provides a built-in predicate <span style="font-family:Courier">=</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->, but this predicate behaves quite
differently from <span style="font-family:Courier">is</span>, since it performs
<i style="mso-bidi-font-style:normal">unification</i><span style="display:none;
mso-hide:all">. evaluation;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;unification</i>: vs. evaluation<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>rather than arithmetic evaluation (see
also section 2.3). The following queries illustrate the operation of <span style="font-family:Courier">=</span>: </p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.5.5" style="display: block;"
query-text="?- X = 5+7-3. ?- 9 = 5+7-3. ?- 9 = X+7-3. ?- X = Y+7-3. ?- X = f(X).">
% Run prolog.
</pre>

<p class="query">?-X = 5+7-3<br>
X = 5+7-3</p>

<p class="query">?-9 = 5+7-3<br>
No</p>

<p class="query">?-9 = X+7-3<br>
No</p>

<p class="query">?-X = Y+7-3<br>
X = _947+7-3<br>
Y = _947</p>

<p class="query" style="margin-bottom:6.0pt">?-X = f(X)<br>
X&nbsp;=&nbsp;f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f<br>
(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(<br>
Error: term being written is too deep</p>

<p class="tekst">The first query just unifies <span style="font-family:Courier">X</span>
with the term <span style="font-family:Courier">5+7-3</span> (i.e. <span style="font-family:Courier">+(5,-(7,3))</span>), which of course succeeds. In
the second and third query, we try to unify a constant with a complex term<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;complex term&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
which fails. The fourth query succeeds, leaving <span style="font-family:Courier">Y</span>
unbound (<span style="font-family:Courier">_947</span> is an internal variable
name, generated by Prolog). </p>

<p class="sektie">The fifth query illustrates that Prolog indeed omits the occur
check (section 2.3) in unification: the query should have failed, but instead
it succeeds, resulting in the circular binding {<span style="font-family:Courier">X</span><span style="font-family:Symbol">&rarr;</span><span style="font-family:Courier">f(X)</span>}.
The problem only becomes apparent when Prolog tries to write the resulting
term, which is infinite. Just to stress that Prolog quite happily constructs
circular bindings, take a look at the following strange program:</p>

<p class="p-el">strange:-X=f(X).</p>

<p class="tekst">The query <span style="font-family:Courier">?-strange</span>
succeeds, and since there is no answer substitution, it is not apparent that
there is a circular binding involved.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.9.</i> Write
a predicate <span style="font-family:Courier">zero(A,B,C,X)</span> which, given
the coefficients <i style="mso-bidi-font-style:normal">a</i>, <i style="mso-bidi-font-style:normal">b</i> and <i style="mso-bidi-font-style:
normal">c</i>, calculates both values of <i style="mso-bidi-font-style:normal">x</i>
for which <i style="mso-bidi-font-style:normal">ax</i><span style="font-size:
7.0pt;mso-bidi-font-size:10.0pt;position:relative;top:-3.0pt;mso-text-raise:
3.0pt">2</span>+<i style="mso-bidi-font-style:normal">bx</i>+<i style="mso-bidi-font-style:normal">c</i>=0.</p>

</div>

<p class="sektie">Finally, we mention that Prolog provides a number of other
useful arithmetic predicates, including the inequality tests <span style="font-family:Courier">&lt;</span> and <span style="font-family:Courier">&gt;</span>,
and their reflexive counterparts <span style="font-family:Courier">=&lt;</span>
and <span style="font-family:Courier">&gt;=</span>. For these tests, both
arguments should be instantiated to numbers.</p>

<h3 id="accumulators">3.6<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Accumulators</h3>

<p class="sektie1">The condition that the righthand-side of <span style="font-family:Courier">is</span> should not contain variables sometimes
determines the ordering of literals in the body of the clause. For instance, in
the program below, which computes the length of a list, the <span style="font-family:Courier">is</span> literal should be placed after the
recursive <span style="font-family:Courier">length</span> call, which
instantiates <span style="font-family:Courier">M</span>. This means that the
resolvent first collects as many <span style="font-family:Courier">is</span>
literals as there are elements in the list, before doing the actual
calculation. Each of these literals contains some &lsquo;local&rsquo; variables that require
some space in memory. The total memory requirements are thus proportional to
the depth of the recursion<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;recursion:memory requirements&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]-->.</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.6.0" style="display: block;"
query-text="?- length([a,b,c],N). ?- length([],N).">
length([],0).
length([_H|T],N):-length(T,M),N is M+1.
</pre>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.10.</i> Draw
the proof tree for the query <span style="font-family:Courier">?-length([a,b,c],N)</span>.</p>

</div>

<p class="sektie">Programs with tail recursion<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;tail
recursion&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>need less memory because they do all the
work on one recursive level before proceeding to the next. There is a common
trick to transform even the <span style="font-family:Courier">length</span>
predicate above into a tail recursive program, using an auxiliary argument
called an <i style="mso-bidi-font-style:normal">accumulator</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;accumulator&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;recursion:transformation into tail
recursion&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.6.1" style="display: block;"
query-text="?- length_acc([],N).">
length_acc(L,N):-length_acc(L,0,N).
length_acc([],N,N).
length_acc([_H|T],N0,N):-N1 is N0+1,length_acc(T,N1,N).
</pre>

<p class="tekst"><span style="font-family:Courier">length_acc(L,N0,N)</span> is
true if <span style="font-family:Courier">N</span> is the number of elements in
<span style="font-family:Courier">L</span> plus <span style="font-family:Courier">N0</span>.
Initialising <span style="font-family:Courier">N0</span> to <span style="font-family:Courier">0</span> results in <span style="font-family:Courier">N</span>
returning the length of <span style="font-family:Courier">L</span>. Note that
the actual counting is done by the second argument: only when the list is empty
is the third argument unified with the second argument. The main point is that,
since the accumulator is given an initial value of <span style="font-family:
Courier">0</span>, it is always instantiated, such that the <span style="font-family:Courier">is</span> literal can be placed before the
recursive call.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.11.</i> Draw
the proof tree for the query <span style="font-family:Courier">?-length_acc([a,b,c],N)</span>.</p>

</div>

<p class="sektie">Accumulators can be used in very many programs. Suppose we want
to reverse the order of elements in a list. We could do this by recursively
reversing the tail of the list, and putting the head at the end of the result:</p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.6.2" style="display: block;"
query-text="?- naive_reverse([a],R).">
naive_reverse([],[]).
naive_reverse([H|T],R):-naive_reverse(T,R1),append(R1,[H],R).
append([],Y,Y).
append([H|T],Y,[H|Z]):-append(T,Y,Z).
</pre>
<p class="tekst">This predicate is called &lsquo;naive&rsquo; because a lot of unnecessary
work is done by the <span style="font-family:Courier">append</span> calls in
the recursive clause. </p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.12.</i> Draw
the proof tree for the query <span style="font-family:Courier">?-naive_reverse([a,b,c],R)</span>.</p>

</div>

<p class="tekst">By using an accumulator, we can get rid of the <span style="font-family:Courier">append</span> predicate, as follows: </p>


<pre class="source swish" data-variant-id="group-2" id="swish.3.6.3" style="display: block;"
query-text="?- reverse([a],R). ?- reverse([a,b,c,d],R).">
reverse(X,Y):- reverse(X,[],Y).
reverse([],Y,Y).
reverse([H|T],Y0,Y):- reverse(T,[H|Y0],Y).
</pre>

<pre class="swish query" id="query3.6.4">?- reverse(X,Y0,Y).</pre><p class="tekst"> is true
if <span style="font-family:Courier">Y</span> consists of the reversal of <span style="font-family:Courier">X</span> followed by <span style="font-family:Courier">Y0</span>.
Initialising <span style="font-family:Courier">Y0</span> to <span style="font-family:Courier">[]</span> results in <span style="font-family:Courier">Y</span>
returning the reversal of <span style="font-family:Courier">X</span>. </p>

<p class="sektie">The use of an accumulator in this more efficient program for
reversing a list is closely related to another programming trick for increasing
the efficiency of list handling. The idea is not to represent a list by a
single term, but instead by a pair of terms <span style="font-family:Courier">L1-L2</span>,
such that the list actually represented is the <b style="mso-bidi-font-weight:
normal">difference</b> between <span style="font-family:Courier">L1</span> and <span style="font-family:Courier">L2</span>. The term <span style="font-family:Courier">L1-L2</span>
is appropriately called a <i style="mso-bidi-font-style:normal">difference list</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;difference list&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->;
<span style="font-family:Courier">L1</span> is called the <i style="mso-bidi-font-style:
normal">plus list</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;plus list&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and <span style="font-family:Courier">L2</span> is called the <i style="mso-bidi-font-style:normal">minus list</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;minus list&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
For instance, the difference list <span style="font-family:Courier">[a,b,c,d]-[d]</span>
represents the simple list <span style="font-family:Courier">[a,b,c]</span>, as
does the difference list <span style="font-family:Courier">[a,b,c,1234,5678]-[1234,5678]</span>,
and even the difference list <span style="font-family:Courier">[a,b,c|X]-X</span>.
The last difference list can be seen as summarising every possible difference
list representing the same simple list, by introducing a variable for the part
which is not contained in the simple list. </p>

<p class="sektie">As was remarked above, <span style="font-family:Courier">reverse(X,Y0,Y)</span>
is true if <span style="font-family:Courier">Y</span> consists of the reversal
of <span style="font-family:Courier">X</span> followed by <span style="font-family:Courier">Y0</span>. Another way to say the same thing is
that the reversal of <span style="font-family:Courier">X</span> is the
difference between <span style="font-family:Courier">Y</span> and <span style="font-family:Courier">Y0</span>. That is, the reversal of <span style="font-family:Courier">X</span> is represented by the difference list <span style="font-family:Courier">Y-Y0</span>! We can make this explicit by a small
syntactic change to <span style="font-family:Courier">reverse</span>, resulting
in the following program:</p>

<p class="pi-el">reverse_dl<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;reverse_dl/2&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(X,Y):-<br>
reverse_dl(X,Y-[]).</p>

<p class="pi">reverse_dl([],Y-Y).</p>

<p class="pi-laatst">reverse_dl([H|T],Y-Y0):-<br>
reverse_dl(T,Y-[H|Y0]).</p>

<p class="tekst">For instance, the third clause in this program says: if the
reversal of <span style="font-family:Courier">T</span> is represented by the
difference list <span style="font-family:Courier">Y-[H|Y0]</span>, then adding <span style="font-family:Courier">H</span> to the head of <span style="font-family:
Courier">T</span> is the same as removing <span style="font-family:Courier">H</span>
from the minus list in the difference list.</p>

<p class="sektie">If the minus list is a variable, it can be used as a pointer to
the end of the represented list. It is this property which makes difference
lists so useful. For instance, if we unify <span style="font-family:Courier">[a,b,c|X]-X</span>
with <span style="font-family:Courier">Y-[d,e]</span>, we get <span style="font-family:Courier">Y=[a,b,c,d,e]</span> &mdash; we have managed to
append two lists together in a single unification step! In this example, the
second term is not a difference list, nor is the result. If we want to append
two difference lists </p>

<p class="p-el">[a,b,c|XMinus]-XMinus </p>

<p class="tekst">and </p>

<p class="p-el">[d,e|YMinus]-YMinus</p>

<p class="tekst">we must unify <span style="font-family:Courier">XMinus</span>
with <span style="font-family:Courier">[d,e|YMinus]</span> (the plus list of
the second difference list), such that the first difference list becomes </p>

<p class="p-el">[a,b,c,d,e|YMinus]-[d,e|YMinus]</p>

<p class="tekst">Combining the plus list of this difference list with <span style="font-family:Courier">YMinus</span>, we get exactly what we want. </p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1047" type="#_x0000_t75"
   style='width:225pt;height:208pt'>
   <v:imagedata src="Part%20I_files/image045.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=50% src="Part%20I_files/image046.svg" v:shapes="_x0000_i1047"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 3.13. </b>Appending
  two difference lists: the &lsquo;length&rsquo; of <span style="font-family:Courier">XMinus</span>
  is adjusted by unification with <span style="font-family:Courier">YPlus</span>,
  the result is given by <span style="font-family:Courier">XPlus-YMinus</span>.</p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">In general, given two difference lists <span style="font-family:
Courier">XPlus-XMinus</span> and <span style="font-family:Courier">YPlus-YMinus</span>,
we unify <span style="font-family:Courier">XMinus</span> with <span style="font-family:Courier">YPlus</span>, and the result is given by <span style="font-family:Courier">XPlus-YMinus</span> (fig. 3.13): </p>

<p class="p-el" style="tab-stops:right 371.0pt">append_dl(XPlus-XMinus,YPlus-YMinus,XPlus-YMinus):-<br>
<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>XMinus=YPlus.</p>

<p class="tekst">or even shorter</p>

<p class="p-el">append_dl<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;append_dl/3&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(XPlus-YPlus,YPlus-YMinus,XPlus-YMinus).</p>

<p class="tekst">Appending a simple list to another simple list of <i style="mso-bidi-font-style:normal">n</i> elements requires <i style="mso-bidi-font-style:
normal">n</i> resolution steps; appending two difference lists requires no
resolution at all, just one unification. Using difference lists is almost
always a good idea if you have to do a lot of list processing.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.13.</i> In
the <span style="font-family:Courier">naive_reverse</span> predicate, represent
the reversed list by a difference list, use <span style="font-family:Courier">append_dl</span>
instead of <span style="font-family:Courier">append</span>, and show that this
results in the predicate <span style="font-family:Courier">reverse_dl</span> by
unfolding the definition of <span style="font-family:Courier">append_dl</span>.</p>

</div>

<h3 id="second_order_predicates">3.7<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Second-order
predicates</h3>

<p class="sektie1">Suppose we need a program to determine, given two lists of
persons of equal length, whether a person in the first list is the parent of
the corresponding person in the second list. The following program will do the
job:</p>

<p class="pi-eerst">parents([],[]).</p>

<p class="pi-laatst">parents([P|Ps],[C|Cs]):-<br>
parent(P,C),<br>
parents(Ps,Cs).</p>

<p class="tekst">We can generalise this program by including the relation which
must hold between corresponding elements of the two lists as a parameter:</p>

<p class="pi-eerst">rel<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;rel/3&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(R,[],[]).</p>

<p class="pi-laatst">rel(R,[X|Xs],[Y|Ys]):-<br>
R(X,Y),<br>
rel(R,Xs,Ys).</p>

<p class="tekst">A term like <span style="font-family:Courier">R(X,Y)</span> is
allowed at the position of an atom in the body of a clause, as long as it is
correctly instantiated at the time it is called. <!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span><span
style="mso-spacerun:yes">&nbsp;</span>XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;variable:in functor position&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="sektie">Some Prolog interpreters don&rsquo;t allow this, in which case you
must explicitly construct the literal by means of the built-in predicate &lsquo;<span style="font-family:Courier">=..</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=../2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->&rsquo; (sometimes called <i style="mso-bidi-font-style:
normal">univ</i>). It is a fully declarative predicate, which can both be used
to construct a term from a list of arguments preceded by a functor, or to
decompose a term into its constituents: </p>

<p class="query" style="page-break-after:auto">?-Term =.. [parent,X,peter]<br>
Term = parent(X,peter)</p>

<p class="query" style="margin-bottom:6.0pt">?-parent(maria,Y) =.. List<br>
List = [parent,maria,Y]</p>

<p class="tekst">&lsquo;<span style="font-family:Courier">=..</span>&rsquo; is declared as an
infix operator in Prolog. </p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.14.</i>
Rewrite the program for <span style="font-family:Courier">rel</span>, using <span style="font-family:Courier">=..</span></p>

</div>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border:solid windowtext 1.0pt;
  mso-border-alt:solid windowtext .25pt;padding:14.0pt 14.0pt 14.0pt 14.0pt;
  background:#E5E5E5;mso-shading:windowtext;mso-pattern:gray-10 auto;
  margin-left:1.0cm;margin-right:1.0cm">
  <p class="inter-title" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  6.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Global datastructures in Prolog<!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
  XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:global
  datastructures&quot; <![endif]--><!--[if supportFields]><span
  style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>
  <p class="intermezzo" style="margin-top:0cm;margin-right:0cm;margin-bottom:
  18.0pt;margin-left:0cm;background:#E5E5E5;mso-shading:windowtext;mso-pattern:
  gray-10 auto">Since Prolog variables do not have a scope outside the clause
  in which they occur (section 2.2), pure Prolog does not provide any support
  for global datastructures. However, Prolog provides access to its internal
  database where it stores the program clauses, by means of the built-in
  predicates <span style="font-family:Courier">assert</span><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-begin'></span> XE </span><span style='font-family:Courier'><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;assert/1&quot; </span><![endif]--><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>and <span style="font-family:Courier">retract</span><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-begin'></span> XE </span><span style='font-family:Courier'><span
  style="mso-spacerun:yes">&nbsp;</span>&quot;retract/1&quot; </span><![endif]--><!--[if supportFields]><span
  style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
  field-end'></span></span><![endif]-->. The query <span style="font-family:
  Courier">?-assert(Clause)</span> results in the addition of <span style="font-family:Courier">Clause</span> (which must be instantiated to a
  valid Prolog clause) to your program; the query <span style="font-family:
  Courier">?&#8209;retract(Clause)</span> removes the first clause which
  unifies with <span style="font-family:Courier">Clause</span> from your
  program. These predicates are fairly low-level, and should be used with care.
  </p>
  </div>
  </td>
 </tr>
</tbody></table>

</div>

<p class="sektie">The predicate <span style="font-family:Courier">rel</span> is
called a <i style="mso-bidi-font-style:normal">second-order</i> predicate<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;second-order</i> predicate<i
style='mso-bidi-font-style:normal'>&quot; </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
because it takes a (first-order) predicate as an argument<abar><a style="mso-footnote-id:
ftn11" href="#_ftn11" name="_ftnref11" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[11]</span></span><!--[endif]--></span></span></span></a></abar>.
We can now define the <span style="font-family:Courier">parents</span>
predicate as</p>

<p class="p-el">parents(Ps,Cs):-rel(parent,Ps,Cs).</p>

<p class="tekst">Suppose now you have the following facts in your program, and
you want to collect all the children of a particular parent in a list: </p>


<pre class="source swish temp" data-variant-id="group-2" id="swish.3.7.1" style="display: block;">
parent(john,peter).
parent(john,paul).
parent(john,mary).
parent(mick,davy).
parent(mick,dee).
parent(mick,dozy).
</pre>

<p class="tekst">Of course, it is easy to generate all the children upon
backtracking; the problem is to collect them in a global list. To this end,
Prolog provides the second-order predicates <span style="font-family:Courier">findall</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;findall/3&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->, <span style="font-family:Courier">bagof</span>,
and <span style="font-family:Courier">setof</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;setof/3&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->. For instance, we could use the following
program and query:</p>

<pre class="source swish inherit" data-variant-id="group-2" id="swish.3.7.2" inherit-id="swish.3.7.1" style="display: block;">
children(Parent,Children):- findall(C,parent(Parent,C),Children).
</pre>

<pre class="swish query" id="query3.7.1">
?- children(john,Children).
</pre>
<p class="query" style="margin-top:0cm;margin-right:0cm;margin-bottom:6.0pt;
margin-left:28.9pt;page-break-after:auto">?-children(john,Children).<br>
Children = [peter,paul,mary]</p>

<p class="tekst">In general, the query </p>

<p class="p-el">?-findall(X,Goal,ListofX) </p>

<p class="tekst">generates all the possible solutions of the query <span style="font-family:Courier">?&#8209;Goal</span>, recording the substitutions
for <span style="font-family:Courier">X</span> for each of these solutions in
the list <span style="font-family:Courier">ListofX</span> (<span style="font-family:Courier">Goal</span> must be instantiated to a term representing
a Prolog goal). </p>

<p class="sektie">The <span style="font-family:Courier">bagof</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;bagof/3&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>predicate acts similarly. However, its
behaviour is different when the goal contains free variables. Consider the
query </p><p class="query"> ?- bagof(C,parent(P,C),L)</p><p class="tekst">in which the variable <span style="font-family:Courier">P</span>
is unbound. This query has two possible interpretations: &lsquo;find a parent and a
list of his children&rsquo;, and &lsquo;find the list of children <i style="mso-bidi-font-style:
normal">that have a parent</i>&rsquo;. In the first case, we get a possible value for
<span style="font-family:Courier">P</span> and a list of <span style="font-family:Courier">P</span>&rsquo;s children, which means that there are two
solutions: </p>

<pre class="swish query" id="query3.7.2" source-id="swish.3.7.1" >
?- bagof(C,parent(P,C),L).
</pre>

<p class="query">
C = _951<br>
P = john<br>
L = [peter,paul,mary];</p>

<p class="query" style="margin-bottom:6.0pt;text-indent:-.9pt">C = _951<br>
P = mick<br>
L = [davy,dee,dozy]</p>

<p class="tekst">In the second case, the goal to prove is &lsquo;there exists a <span style="font-family:Courier">P</span> such that <span style="font-family:Courier">parent(P,C)</span>
is true&rsquo;, which means that the variable <span style="font-family:Courier">P</span>
is existentially quantified. This is signalled by prefixing the goal with <span style="font-family:Courier">P^</span>:</p>

<pre class="swish query" id="query3.7.3" source-id="swish.3.7.1" >
?- bagof(C,P^parent(P,C),L).
</pre>
<p class="query" style="margin-bottom:6.0pt">
C = _957<br>
P = _958<br>
L = [peter,paul,mary,davy,dee,dozy]</p>


<p class="tekst">The query </p>
<pre class="swish query" id="query3.7.4" source-id="swish.3.7.1" >
?- findall(C,parent(P,C),L).</span>
</pre>
<p class="tekst">
(without existential quantification) can only generate this second solution. </p>

<p class="sektie">Finally, Prolog provides the predicate <span style="font-family:
Courier">setof</span>, which acts just like <span style="font-family:Courier">bagof</span>,
except that the resulting list is sorted and does not contain duplicates. Thus,
<span style="font-family:Courier">setof</span> is slightly less efficient than <span style="font-family:Courier">bagof</span>, and the latter is preferred in cases
where the list of solutions is known not to contain duplicates.<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;sorting a
list&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.15.</i> Write
a program which sorts and removes duplicates from a list, using <span style="font-family:Courier">setof</span>.</p>

</div>

<h3 id="meta_programs">3.8<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>Meta-programs</h3>

<p class="sektie1">Prolog represents a clause <span style="font-family:Courier">Head:-Body</span>
in the same way as a term <span style="font-family:Courier">:-(Head,Body)</span>.
Thus, it is easy to write programs that manipulate clauses. In the first case,
&lsquo;<span style="font-family:Courier">:-</span>&rsquo; is treated as a predicate, and in
the second case it is treated as a functor. The combination of these two
interpretations occurs frequently in Prolog programs, and can be applied to any
predicate <span style="font-family:Courier">p</span>. Such programs are called <i style="mso-bidi-font-style:normal">meta-program</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-program&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><i style="mso-bidi-font-style:normal">s</i>; the interpretation of <span style="font-family:Courier">p</span> as a predicate occurs on the <i style="mso-bidi-font-style:normal">object-level</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;object-level&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and the interpretation as a functor occurs on the <i style="mso-bidi-font-style:
normal">meta-level</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-level&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
(Note that the difference between meta-predicates and higher-order predicates
is that meta-predicates take object-level <i style="mso-bidi-font-style:normal">clauses</i>
as arguments, while the latter take lower-order <i style="mso-bidi-font-style:
normal">predicates</i> as arguments.) <span style="display:none;mso-hide:all">.
higher-order predicate;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-predicate:vs. higher-order predicate&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--></p>

<p class="sektie">For instance, suppose we have the following biological
knowledge, expressed as propositional if-then rules:</p>

<pre class="source swish temp" data-variant-id="group-2" id="swish.3.8.1" style="display: block;" 
query-text="?- if tweety then is_bird. ?- if tweety then lays_eggs.">
% if A and B then C means if(then(and(A,B),C))
:-op(900,fx,if).
:-op(800,xfx,then).
:-op(700,yfx,and).
% object-level rules
if has_feathers and lays_eggs then is_bird.
if has_gills and lays_eggs then is_fish.
if tweety then has_feathers.
if tweety then lays_eggs.
</pre>

<p class="tekst">Suppose we want to prove that Tweety is a bird. That is, we want
to show that the rule</p>

<p class="p-el">if tweety then is_bird</p>

<p class="tekst">follows logically from the given rules This can be done by a
meta-program, which manipulates the rules on the object-level: </p>

<pre class="source swish inherit" data-variant-id="group-2" id="swish.3.8.2" inherit-id="swish.3.8.1" style="display: block;" 
query-text="?- derive(if tweety then is_bird). ?- derive(if tweety then lays_eggs).">
% meta-program
derive(if Assumptions then Goal):- if Body then Goal,
derive(if Assumptions then Body).
derive(if Assumptions then Goal1 and Goal2):- derive(if Assumptions then Goal1), derive(if Assumptions then Goal2).
derive(if Assumptions then Goal):- assumed(Goal,Assumptions).
assumed(A,A).
assumed(A,A and _As).
assumed(A,_B and As):- assumed(A,As).
</pre>

<p class="tekst" style="page-break-after:avoid">The three clauses for the <span style="font-family:Courier">derive</span> predicate represent the three
possible cases:</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>a goal matches the head of a
rule, in which case we should proceed <br>
with the body;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>a goal is a conjunction<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;conjunction&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(for instance, because it was produced in
<br>
the previous step), of which each conjunct is derived separately;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iii</i>)<span style="mso-tab-count:1">&nbsp; </span>a goal is among the assumptions.</p>

<p class="tekst">As explained above, <span style="font-family:Courier">if</span>
is a predicate on the object-level, and a functor on the meta-level.</p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.16.</i> Draw
the SLD-tree for the query <br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">?-derive(if tweety then is_bird)</span>.</p>

</div>

<p class="sektie">Since propositional definite clauses are similar to the above
if-then rules, one could view this program as a propositional Prolog simulator.
In fact, it is possible to push the resemblance closer, by adopting the
Prolog-representation of clauses at the object-level. One minor complication is
that the clause constructor &lsquo;<span style="font-family:Courier">:-</span>&rsquo; is
not directly available as an object-level predicate. Instead, Prolog provides
the built-in predicate <span style="font-family:Courier">clause</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;clause/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]-->: a query <span style="font-family:Courier">?&#8209;clause(H,B)</span>
succeeds if <span style="font-family:Courier">H:-B</span> unifies with a clause
in the internal Prolog database (if <span style="font-family:Courier">H</span>
unifies with a fact, <span style="font-family:Courier">B</span> is unified with
<span style="font-family:Courier">true</span>). A further modification with
respect to the above program is that Prolog queries do not have the form <span style="font-family:Courier">if Assumptions then Goal</span>; instead, the <span style="font-family:Courier">Assumptions</span> are added to the object-level
program, from which a proof of <span style="font-family:Courier">Goal</span> is
attempted. </p>

<p class="sektie">Following these observations, the predicate <span style="font-family:Courier">derive</span> is changed as follows: </p>

<p class="pi-eerst">prove(Goal):-<br>
clause(Goal,Body),<br>
prove(Body).</p>

<p class="pi">prove((Goal1,Goal2)):-<br>
prove(Goal1),<br>
prove(Goal2).</p>

<p class="pi-laatst">prove(true).</p>

<p class="tekst">This program nicely reflects the process of constructing a
resolution proof: </p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>if the resolvent contains a
single atom, find a clause with that atom in the head and proceed with its
body;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>if the resolvent contains various
atoms, start with the first and proceed with the rest;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iii</i>)<span style="mso-tab-count:1">&nbsp; </span>if the resolvent is empty, we&rsquo;re done.</p>

<p class="tekst">Some Prolog interpreters have problems if <span style="font-family:Courier">clause</span> is called with the first argument
instantiated to <span style="font-family:Courier">true</span> or a conjunction,
because <span style="font-family:Courier">true</span> and &lsquo;<span style="font-family:Courier">,</span>&rsquo; (comma) are built-in predicates. To avoid
these problems, we should add the conditions <span style="font-family:Courier">not
A=true</span> and <span style="font-family:Courier">not A=(X,Y)</span> to the
first clause. A less declarative solution is to reorder the clauses and use
cuts: </p>

<p class="pi-eerst">prove<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;prove/1&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(true):-!.</p>

<p class="pi">prove((A,B)):-!,<br>
prove(A),<br>
prove(B).</p>

<p class="pi-laatst">prove(A):-<br>
/* not A=true, not A=(X,Y) */<br>
clause(A,B),<br>
prove(B).</p>

<p class="tekst">We will adopt this less declarative version for pragmatic
reasons: it is the one usually found in the literature. As this program
illustrates, whenever you use cuts it is normally a good idea to add a
declarative description of their effect between comment brackets. </p>

<p class="sektie">A meta-program interpreting programs in the same language in
which it is written is called a <i style="mso-bidi-font-style:normal">meta-interpreter</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;meta-interpreter&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.
In order to &lsquo;lift&rsquo; this propositional meta-interpreter to clauses containing
variables, it is necessary to incorporate unification<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;unification&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>into the third clause. Suppose we are
equipped with predicates <span style="font-family:Courier">unify</span> and <span style="font-family:Courier">apply</span>, such that <span style="font-family:
Courier">unify(T1,T2,MGU,T)</span> is <b style="mso-bidi-font-weight:normal">true</b>
if <span style="font-family:Courier">T</span> is the result of unifying <span style="font-family:Courier">T1</span> and <span style="font-family:Courier">T2</span>
with most general unifier <span style="font-family:Courier">MGU</span>, and <span style="font-family:Courier">apply(T,Sub,TS)</span> is <b style="mso-bidi-font-weight:
normal">true</b> if <span style="font-family:Courier">TS</span> is the term
obtained from <span style="font-family:Courier">T</span> by applying
substitution <span style="font-family:Courier">Sub</span>. The meta-interpreter
would then look like this:</p>

<p class="pi-eerst">prove_var<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;prove_var/1&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(true):-!.</p>

<p class="pi">prove_var((A,B)):-!,<br>
prove(A),<br>
prove(B).</p>

<p class="pi-laatst">prove_var(A):-<br>
clause(Head,Body),<br>
unify(A,Head,MGU,Result),<br>
apply(Body,MGU,NewBody),<br>
prove_var(NewBody).</p>

<p class="tekst">Prolog&rsquo;s own unification predicate <span style="font-family:
Courier">=</span><!--[if supportFields]><span style='font-family:Courier;
display:none;mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;=/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>does not return the most general unifier
explicitly, but rather unifies the two original terms implicitly. Therefore, if
we want to use the built-in unification algorithm in our meta-interpreter, we
do not need the <span style="font-family:Courier">apply</span> predicate, and
we can write the third clause as</p>

<p class="pi-el">prove_var(A):-<br>
clause(Head,Body),<br>
A=Head,<br>
prove_var(Body)</p>

<div style="mso-element:frame;mso-element-wrap:auto;mso-height-rule:exactly">

<table cellspacing="0" cellpadding="0" hspace="0" vspace="0" align="center">
 <tbody><tr>
  <td valign="top" align="left" style="padding-top:9.0pt;padding-right:9.0pt;
  padding-bottom:9.0pt;padding-left:9.0pt">
  <div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
  mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
  padding:12.0pt 0cm 12.0pt 0cm">
  <p class="figure"><!--[if gte vml 1]><v:shape id="_x0000_i1048" type="#_x0000_t75"
   style='width:327pt;height:150pt'>
   <v:imagedata src="Part%20I_files/image047.emz" o:title=""/>
  </v:shape><![endif]--><!--[if !vml]--><img width=60% src="Part%20I_files/image048.svg" v:shapes="_x0000_i1048"><!--[endif]--></p>
  </div>
  <p class="caption"><b style="mso-bidi-font-weight:normal">Figure 3.14.</b> The <span style="font-family:Courier">prove</span> meta-interpreter embodies a
  declarative implementation of the resolution proof procedure, making use of
  built-in unification. </p>
  </td>
 </tr>
</tbody></table>

</div>

<p class="tekst">If we now change the explicit unification in the body of this
clause to an implicit unification in the head, we actually obtain the
propositional meta-interpreter again! That is, while this program is read <b style="mso-bidi-font-weight:normal">declaratively</b> as a meta-interpreter for
propositional programs, it nevertheless operates <b style="mso-bidi-font-weight:
normal">procedurally</b> as an interpreter of first-order clauses (fig. 3.14). </p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm;tab-stops:48.0pt 113.0pt"><i style="mso-bidi-font-style:normal">Exercise
3.17.</i> Draw the SLD-tree for the query <span style="font-family:Courier">?-prove(is_bird(X))</span>,
given the following clauses:<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family:Courier">is_bird(X):-has_feathers(X),lays_eggs(X).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>is_fish(X):-has_gills(X),lays_eggs(X).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>has_feathers(tweety).<br>
<span style="mso-tab-count:2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lays_eggs(tweety).<o:p></o:p></span></p>

</div>

<p class="tekst">Note that this meta-interpreter is able to handle only &lsquo;pure&rsquo;
Prolog programs, without system predicates like cut or <span style="font-family:
Courier">is</span>, since there are no explicit clauses for such predicates. </p>

<p class="sektie">A variety of meta-interpreters will be encountered in this
book. Each of them is a variation of the above &lsquo;canonical&rsquo; meta-interpreter in
one of the following senses:</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>application of a different
search strategy;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>application of a different proof
procedure;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iii</i>)<span style="mso-tab-count:1">&nbsp; </span>enlargement of the set of clauses that
can be handled;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">iv</i>)<span style="mso-tab-count:1">&nbsp; </span>extraction of additional information from
the proof process.</p>

<p class="tekst">The first variation will be illustrated in section 5.3, where
the meta-interpreter adopts a breadth-first search strategy. In the same
section, this meta-interpreter is changed to an interpreter for full clausal
logic (<i style="mso-bidi-font-style:normal">iii</i>). Different proof
procedures are extensively used in Chapters 8 and 9. Here, we will give two
example variations. In the first example, we change the meta-interpreter in
order to handle general clauses by means of negation as failure (<i style="mso-bidi-font-style:normal">iii</i>). All we have to do is to add the
following clause:</p>

<p class="pi-el">prove(not A):-<br>
not prove(A)</p>

<p class="tekst">This clause gives a declarative description of negation as
failure<!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;negation as failure:declarative
description of&quot; <![endif]--><!--[if supportFields]><span style='display:
none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->.</p>

<p class="sektie">The second variation extracts additional information from the
SLD proof procedure by means of a proof tree<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;proof tree:construction
of&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>(<i style="mso-bidi-font-style:normal">iv</i>).
To this end, we need to make a slight change to the meta-interpreter given
above. The reason for this is that the second clause of the original
meta-interpreter breaks up the current resolvent if it is a conjunction,
whereas in a proof tree we want the complete resolvent to appear. </p>

<p class="pi-eerst">% meta-interpreter with complete resolvent</p>

<p class="pi">prove_r<!--[if supportFields]><span style='display:none;mso-hide:
all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;prove_r/1&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->(true):-!.</p>

<p class="pi">prove_r((A,B)):-!,<br>
clause(A,C),<br>
conj_append(C,B,D),<br>
prove_r(D).</p>

<p class="pi-laatst">prove_r(A):-<br>
clause(A,B),<br>
prove_r(B).</p>

<p class="pi-laatst">%%% conj_append/3: see Appendix A.2</p>

<p class="tekst">We now extend <span style="font-family:Courier">prove_r/1</span>
with a second argument, which returns the proof tree as a list of pairs <span style="font-family:Courier">p(Resolvent,Clause)</span>: </p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.8.2" style="display: block;" 
query-text="?- prove_p(student_of(S,T))."
source-text-start="
:-op(900,fy,not).
"
source-text-end="
conj_append(true,Ys,Ys).
conj_append(X,Ys,(X,Ys)):-not X=true,not X=(One,TheOther).
conj_append((X,Xs),Ys,(X,Zs)):-conj_append(Xs,Ys,Zs).

student_of(S,T):-teaches(T,C),follows(S,C).
teaches(peter,cs).
teaches(peter,ai).
follows(maria,cs).
follows(paul,ai).
"
>
% display a proof tree
prove_p(A):-prove_p(A,P),write_proof(P).

% prove_p(A,P) <- P is proof tree of A
prove_p(true,[]):-!.
prove_p((A,B),[p((A,B),(A:-C))|Proof]):-!,clause(A,C),conj_append(C,B,D),prove_p(D,Proof).
prove_p(A,[p(A,(A:-B))|Proof]):-clause(A,B),prove_p(B,Proof).

write_proof([]):-write('               []'),nl.
write_proof([p(A,B)|Proof]):-write((:-A)),nl,write('     |'),write(          B),
	nl,write('     |'),write('                    /'),nl,write_proof(Proof).
</pre>

<p class="tekst">For instance, given the following clauses: </p>

<p class="p-el">student_of(S,T):-teaches(T,C),follows(S,C).<br>
teaches(peter,cs).<br>
teaches(peter,ai).<br>
follows(maria,cs).<br>
follows(paul,ai).</p>

<p class="tekst">and the query <span style="font-family:Courier">?-prove_p(student_of(S,T))</span>,
the program writes the following proof trees:</p>

<p class="p-eerst">:-student_of(peter,maria)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>student_of(peter,maria):-teaches(peter,cs),follows(maria,cs)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>/</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt">:-(teaches(peter,cs),follows(maria,cs))</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>teaches(peter,cs):-true</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>/</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt">:-follows(maria,cs)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>follows(maria,cs):-true</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>/</p>

<p class="p-laatst"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>[]</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt">:-student_of(peter,paul)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp; </span><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>student_of(peter,paul):-teaches(peter,ai),follows(paul,ai)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>/</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt">:-(teaches(peter,ai),follows(paul,ai))</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>teaches(peter,ai):-true</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>/</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt">:-follows(paul,ai)</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>follows(paul,ai):-true</p>

<p class="programma" style="margin-left:143.0pt;text-indent:-126.0pt"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>|<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>/</p>

<p class="p-laatst"><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>[]</p>

<p class="sektie">Note that these are propositional proof trees, in the sense
that all substitutions needed for the proof have already been applied. If we
want to collect the uninstantiated program clauses in the proof tree then we
should make a copy of each clause, before it is used in the proof:</p>

<p class="pi-el" style="tab-stops:206.0pt">prove_p((A,B),[p((A,B),Clause)|Proof]):-!,<br>
clause(A,C),<br>
copy_term((A:-C),Clause),<span style="mso-tab-count:1">&nbsp; </span>% make
copy of the clause<br>
conj_append(C,B,D),<br>
prove_p(D,Proof)</p>

<p class="tekst">The predicate <span style="font-family:Courier">copy_term/2</span><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-begin'></span> XE </span><span style='font-family:Courier'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;copy_term/2&quot; </span><![endif]--><!--[if supportFields]><span
style='font-family:Courier;display:none;mso-hide:all'><span style='mso-element:
field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>makes a copy of a term, with all
variables replaced by new ones. It is a built-in predicate in many Prolog
interpreters, but could be defined by means of <span style="font-family:Courier">assert/2</span>
and <span style="font-family:Courier">retract/2</span> (see Appendix A.2 for
details).</p>

<h3 id="a_methodology_of_prolog_programming">3.9<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>A methodology of
Prolog programming</h3>

<p class="sektie1">At the end of this chapter, we spend a few words on the <i style="mso-bidi-font-style:normal">methodology</i> of writing Prolog<!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Prolog:programming
methodology&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>programs. Given a problem to solve, how
do I obtain the program solving the problem? This is the fundamental problem of
software engineering. Here, we can only scratch the surface of this question:
we will concentrate on the subtask of writing relatively simple predicates
which use no more than two other predicates. </p>

<p class="sektie">Consider the following problem: define a predicate which, given
a number <i style="mso-bidi-font-style:normal">n</i>, partitions a list of
numbers into two lists: one containing numbers smaller than <i style="mso-bidi-font-style:normal">n</i>, and the other containing the rest. So
we need a predicate <span style="font-family:Courier">partition/4</span>:</p>

<p class="oms-eerst" style="margin-bottom:6.0pt;page-break-after:auto">%
partition(L,N,Littles,Bigs) &lt;- Littles contains numbers <br>
%<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span><span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;</span>in L
smaller than N, <br>
%<span style="mso-spacerun:yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Bigs contains the rest</p>

<p class="tekst">Since the only looping structure of Prolog is recursion, simple
predicates like this will typically be recursive. This means that</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>there is a <i style="mso-bidi-font-style:normal">base case</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;base case&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
and one or more recursive clauses;</p>

<p class="opsomming">(<i style="mso-bidi-font-style:normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>there is a <i style="mso-bidi-font-style:
normal">recursion argument</i><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><i
style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;recursion argument&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>distinguishing between the base case and
the recursive clauses.</p>

<p class="tekst">For list predicates, the recursion argument is typically a list,
and the distinction is typically between empty and non-empty lists. For the <span style="font-family:Courier">partition/4</span> predicate, the recursion
argument is the first list. The base case is easily identified: the empty list
is partitioned in two empty lists, no matter the value of <span style="font-family:Courier">N</span>. This gives us the following <i style="mso-bidi-font-style:normal">skeleton</i><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><i style='mso-bidi-font-style:normal'><span
style="mso-spacerun:yes">&nbsp;</span>&quot;skeleton&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->:
</p>

<p class="pi-eerst">partition([],N,[],[]).</p>

<p class="pi-laatst">partition([Head|Tail],N,?Littles,?Bigs):-<br>
/* do something with Head */<br>
partition(Tail,N,Littles,Bigs).</p>

<p class="tekst">The question marks denote <i style="mso-bidi-font-style:normal">output
arguments</i><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-begin'></span> XE </span><i style='mso-bidi-font-style:
normal'><span style="mso-spacerun:yes">&nbsp;</span>&quot;output
arguments&quot; \b </i><![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]-->,
whose relation to the variables in the recursive call still has to be decided.
It should be noted that not all predicates are tail recursive, so it is not yet
known whether the recursive call will be last indeed.<a name="bk1"> Notice also
that the output arguments in the recursive call have been given meaningful
names, which is, in general, a good idea. </a></p>

<p class="sektie"><span style="mso-bookmark:bk1">Once we have &lsquo;chopped off&rsquo; the
first number in the list, we have to do something with it. Depending on whether
it is smaller than </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">N</span> or not, it has to be added to the </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Littles</span> or
the </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Bigs</span>.
Suppose </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Head</span>
is smaller than </span><span style="mso-bookmark:bk1"><span style="font-family:
Courier">N</span>:</span></p>

<p class="pi-el"><span style="mso-bookmark:bk1">partition([Head|Tail],N,?Littles,?Bigs):-<br>
Head &lt; N,<br>
partition(Tail,N,Littles,Bigs)</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">Thus, </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Head</span> must be
added to </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Littles</span>.
In this case, it does not matter in which position it is added: obviously, the
most simple way is to add it to the head of the list:</span></p>

<p class="pi-el"><span style="mso-bookmark:bk1">?Littles = [Head|Littles]</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">In such cases, where output
arguments are simply constructed by unification, the unification is performed
implicitly in the head of the clause (the fourth argument remains unchanged): </span></p>

<p class="pi-el"><span style="mso-bookmark:bk1">partition([Head|Tail],N,[Head|Littles],Bigs):-<br>
Head &lt; N,<br>
partition(Tail,N,Littles,Bigs)</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">A second recursive clause is
needed to cover the case that </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Head</span> is larger than or equal to </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">N</span>, in which
case it must be added to </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Bigs</span>. The final program looks as follows: </span></p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.9.1" style="display: block;" 
query-text="?- partition([1,9,6,3,5],5,Littles,Bigs). ?- partition([11,7,5],5,Littles,Bigs).">
% partition(L,N,Littles,Bigs) <- Littles contains numbers 
%                                in L smaller than N, 
%                                Bigs contains the rest
partition([],_N,[],[]).
partition([Head|Tail],N,[Head|Littles],Bigs):- Head < N, partition(Tail,N,Littles,Bigs).
partition([Head|Tail],N,Littles,[Head|Bigs]):- Head >= N, partition(Tail,N,Littles,Bigs).
</pre>

<p class="sektie"><span style="mso-bookmark:bk1">The approach taken here can be
formulated as a general strategy for writing Prolog predicates. The steps to be
performed according to this strategy are summarised below: </span></p>

<p class="opsomming" style="margin-top:6.0pt"><span style="mso-bookmark:bk1">(<i style="mso-bidi-font-style:normal">i</i>)<span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp; </span>write
down a declarative specification; </span></p>

<p class="opsomming"><span style="mso-bookmark:bk1">(<i style="mso-bidi-font-style:
normal">ii</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>identify the
recursion argument, and the output arguments; </span></p>

<p class="opsomming"><span style="mso-bookmark:bk1">(<i style="mso-bidi-font-style:
normal">iii</i>)<span style="mso-tab-count:1">&nbsp; </span>write down a
skeleton; </span></p>

<p class="opsomming"><span style="mso-bookmark:bk1">(<i style="mso-bidi-font-style:
normal">iv</i>)<span style="mso-tab-count:1">&nbsp; </span>complete the bodies
of the clauses;</span></p>

<p class="opsomming" style="margin-bottom:6.0pt"><span style="mso-bookmark:bk1">(<i style="mso-bidi-font-style:normal">v</i>)<span style="mso-tab-count:1">&nbsp;&nbsp; </span>fill
in the output arguments. </span></p>

<p class="tekst"><span style="mso-bookmark:bk1">Notice that step (<i style="mso-bidi-font-style:normal">iv</i>) comprises most of the work, while
the other steps are meant to make this work as easy as possible. </span></p>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><span style="mso-bookmark:bk1"><i style="mso-bidi-font-style:
normal">Exercise 3.18.</i> Implement a predicate </span><span style="mso-bookmark:
bk1"><span style="font-family:Courier">permutation/2</span>, such that </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">permutation(L,P)</span>
is true if </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">P</span>
contains the same elements as the list </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">L</span> but (possibly) in a different order,
following these steps. (One auxiliary predicate is needed.)</span></p>

</div>

<p class="sektie"><span style="mso-bookmark:bk1">As a second example, consider
the problem of sorting a list</span><!--[if supportFields]><span
style='mso-bookmark:bk1'></span><span style='mso-element:field-begin'></span><span
style='mso-bookmark:bk1'><span style='display:none;mso-hide:all'> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;sorting a list&quot; </span><![endif]--><span style="mso-bookmark:bk1"></span><!--[if supportFields]><span style='mso-bookmark:
bk1'></span><span style='mso-element:field-end'></span><![endif]--><span style="mso-bookmark:bk1"><span style="mso-spacerun:yes">&nbsp;</span>of
numbers. The declarative specification is as follows:</span></p>

<p class="oms-eerst" style="margin-bottom:6.0pt"><span style="mso-bookmark:bk1">%
sort(L,S) &lt;- S is a sorted permutation of list L</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">Note that this specification can
immediately be translated to Prolog:</span></p>

<p class="pi-el"><span style="mso-bookmark:bk1">sort(L,S):-<br>
permutation(L,S),<br>
sorted(S).</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">This program first guesses a
permutation of </span><span style="mso-bookmark:bk1"><span style="font-family:
Courier">L</span>, and then checks if the permutation happens to be sorted.
Declaratively, this program is correct; procedurally, it is extremely
inefficent since there are <i style="mso-bidi-font-style:normal">n</i>!
different permutations of a list of length <i style="mso-bidi-font-style:normal">n</i>.
Thus, we have to think of a more efficient algorithm. </span></p>

<p class="sektie"><span style="mso-bookmark:bk1">The recursion and output
arguments are easily identified as the first and second argument, respectively.
The base case states that the empty list is already sorted, while the recursive
clause states that a non-empty list is sorted by sorting its tail separately: </span></p>

<p class="pi-eerst"><span style="mso-bookmark:bk1">sort([],[]).</span></p>

<p class="pi-laatst"><span style="mso-bookmark:bk1">sort([Head|Tail],?Sorted):-<br>
/* do something with Head */<br>
sort(Tail,Sorted).</span></p>

<p class="tekst"><span style="mso-bookmark:bk1">It remains to decide what the
relation is between </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">?Sorted</span>, </span><span style="mso-bookmark:
bk1"><span style="font-family:Courier">Head</span> and </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Sorted</span>.
Obviously, </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Head</span>
cannot be simply added to the front of </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Sorted</span>, but has to be inserted in the proper
place. We thus need an auxiliary predicate </span><span style="mso-bookmark:
bk1"><span style="font-family:Courier">insert/3</span>, to add </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Head</span> at the
proper position in </span><span style="mso-bookmark:bk1"><span style="font-family:Courier">Sorted</span>. Note that tail recursion</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;tail
recursion&quot; \r &quot;bk1&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>is not applicable in this case, since we
have to insert <span style="font-family:Courier">Head</span> in an already
sorted list. We thus arrive at the following definition:</p>


<pre class="source swish" data-variant-id="group-2" id="swish.3.9.2" style="display: block;" 
query-text="?- sort([3,6,2,8,1],Sorted). ?- sort([6,5,4,3,2,1],Sorted)."
source-text-end="
insert(X,[],[X]).
insert(X,[Head|Tail],[Head|Inserted]):- X > Head, insert(X,Tail,Inserted).
insert(X,[Head|Tail],[X,Head|Tail]):- X =< Head."
>
sort([],[]).
sort([Head|Tail],WholeSorted):- sort(Tail,Sorted), insert(Head,Sorted,WholeSorted).
</pre>

<p class="sektie">In order to implement <span style="font-family:Courier">insert/3</span>,
we follow the same steps. The second argument is the recursion argument, and
the third is the output argument. This gives the following skeleton: </p>

<p class="pi-eerst">insert(X,[],?Inserted).</p>

<p class="pi-laatst">insert(X,[Head|Tail],?Inserted):-<br>
/* do something with Head */<br>
insert(X,Tail,Inserted).</p>

<p class="tekst">The base case is simple: <span style="font-family:Courier">?Inserted
= [X]</span>. In the recursive clause, we have to compare <span style="font-family:Courier">X</span> and <span style="font-family:Courier">Head</span>.
Suppose <span style="font-family:Courier">X</span> is greater than <span style="font-family:Courier">Head</span>: </p>

<p class="pi-el">insert(X,[Head|Tail],?Inserted):-<br>
X &gt; Head,<br>
insert(X,Tail,Inserted)</p>

<p class="tekst">We have to construct the output argument <span style="font-family:
Courier">?Inserted</span>. Since <span style="font-family:Courier">X</span> has
already been properly inserted to <span style="font-family:Courier">Tail</span>,
it remains to add <span style="font-family:Courier">Head</span> to the front of
<span style="font-family:Courier">Inserted</span>: </p>

<p class="pi-el">?Inserted = [Head|Inserted]</p>

<p class="tekst">A third clause is needed if <span style="font-family:Courier">X</span>
is not greater than <span style="font-family:Courier">Head</span> (note that
this clause, being non-recursive, is a second base case): </p>

<p class="pi-el">insert(X,[Head|Tail],?Inserted):-<br>
X =&lt; Head</p>

<p class="tekst">In this case, <span style="font-family:Courier">X</span> should
be added before <span style="font-family:Courier">Head</span>: </p>

<p class="p-el">?Inserted = [X,Head|Tail]</p>

<p class="tekst">The complete program is given below: </p>

<pre class="source swish" data-variant-id="group-2" id="swish.3.9.3" style="display: block;" 
query-text="?- insert(4,[2,3,5,7],Inserted). ?- insert(1,[2,3,5,7],Inserted). ?- insert(8,[2,3,5,7],Inserted).">
insert(X,[],[X]).
insert(X,[Head|Tail],[Head|Inserted]):- X &gt; Head, insert(X,Tail,Inserted).
insert(X,[Head|Tail],[X,Head|Tail]):- X =&lt; Head.
</pre>

<div style="mso-element:para-border-div;border-top:solid windowtext 1.0pt;
border-left:none;border-bottom:solid windowtext 1.0pt;border-right:none;
mso-border-top-alt:solid windowtext .25pt;mso-border-bottom-alt:solid windowtext .25pt;
padding:6.0pt 0cm 6.0pt 0cm;margin-left:1.0cm;margin-right:1.0cm">

<p class="exercise" style="margin-top:18.0pt;margin-right:0cm;margin-bottom:18.0pt;
margin-left:0cm"><i style="mso-bidi-font-style:normal">Exercise 3.19.</i>
Implement an alternative to this sorting method by using the <span style="font-family:Courier">partition/4</span> predicate. </p>

</div>

<h3 id="further_reading_3">Further reading</h3>

<p class="sektie1">There are many introductory and advanced textbooks on Prolog
programming. (Bratko, 1990) is a particularly practical introduction. (Sterling
&amp; Shapiro, 1986) offers a slightly more advanced presentation. (Nilsson
&amp; Maluszynski, 1990) is one of the few books dealing with both the
theoretical and practical aspects of programming in Prolog. (Ross, 1989) and
(O&rsquo;Keefe, 1990) discuss advanced issues in the practice of Prolog programming. </p>

<p class="sektie">Those eager to learn more about the implementation of Prolog
interpreters are referred to (Maier &amp; Warren, 1988). (Bowen &amp; Kowalski,
1982) is an early source on meta-programs in Logic Programming. The slogan
Algorithm = Logic + Control<!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Algorithm = Logic + Control&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="mso-spacerun:yes">&nbsp;</span>was put forward by Kowalski (1979). A
discussion of the relation between declarative and procedural programming can
be found in (Kowalski, 1993). </p>

<p class="referenties"><span style="font-variant:small-caps">K.A. Bowen &amp;
R.A. Kowalski (</span>1982)<span style="font-variant:small-caps">,</span>
&lsquo;Amalgamating language and metalanguage in Logic Programming&rsquo;. In <i style="mso-bidi-font-style:normal">Logic Programming</i>, K.L. Clark &amp; S.
T&auml;rnlund (eds.), Academic Press.<span style="display:none;mso-hide:all">.A.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Bowen, K.A.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.A.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Kowalski,
R.A.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">I. Bratko (</span>1990)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Prolog
Programming for Artificial Intelligence</i>, Addison-Wesley, <br>
second edition.<span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Bratko, I.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">R.A. Kowalski (</span>1979)<span style="font-variant:small-caps">,</span> &lsquo;Algorithm = Logic + Control&rsquo;, <i style="mso-bidi-font-style:normal">Communications of the ACM</i> <b style="mso-bidi-font-weight:normal">22</b>(7): 424-436.<span style="display:
none;mso-hide:all">.A.;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Kowalski, R.A.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">R.A. Kowalski (</span>1993)<span style="font-variant:small-caps">,</span> &lsquo;Logic Programming&rsquo;. In <i style="mso-bidi-font-style:normal">Encyclopedia of Computer Science</i>, <br>
A. Ralston &amp; E.D. Reilly (eds), pp. 778-783, Van Nostrand Reinhold, <br>
third edition.<span style="display:none;mso-hide:all">.A.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Kowalski,
R.A.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">D. Maier &amp; D.S.
Warren (</span>1988)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Computing with Logic: Logic Programming with
Prolog</i>, Benjamin/Cummings.<span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Maier, D.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.S.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Warren, D.S.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">U. Nilsson &amp; J.
Maluszynski (</span>1990)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Logic, Programming and Prolog</i>, John
Wiley.<span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Nilsson, U.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Maluszynski,
J.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">R.A. O&rsquo;Keefe (</span>1990)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">The
Craft of Prolog</i>, MIT Press.<span style="display:none;mso-hide:all">.A.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;O&rsquo;Keefe,
R.A.\;&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">P. Ross (</span>1989)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">Advanced
Prolog: Techniques and Examples</i>, Addison-Wesley.<span style="display:none;
mso-hide:all">.;</span><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-begin'></span> XE </span><span
style="mso-spacerun:yes">&nbsp;</span>&quot;Ross,P.&quot; <![endif]--><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--></p>

<p class="referenties"><span style="font-variant:small-caps">L.S. Sterling &amp;
E.Y. Shapiro (</span>1986)<span style="font-variant:small-caps">,</span> <i style="mso-bidi-font-style:normal">The Art of Prolog</i>, MIT Press.<span style="display:none;mso-hide:all">.S.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Sterling,
L.S.&quot; <![endif]--><!--[if supportFields]><span style='display:none;
mso-hide:all'><span style='mso-element:field-end'></span></span><![endif]--><span style="display:none;mso-hide:all">.Y.;</span><!--[if supportFields]><span
style='display:none;mso-hide:all'><span style='mso-element:field-begin'></span>
XE </span><span style="mso-spacerun:yes">&nbsp;</span>&quot;Shapiro, E.Y.&quot;
<![endif]--><!--[if supportFields]><span style='display:none;mso-hide:all'><span
style='mso-element:field-end'></span></span><![endif]--></p>

</div>

<div style="mso-element:footnote-list"><!--[if !supportFootnotes]--><br clear="all">

<hr align="left" size="1" width="33%">

<!--[endif]-->

<div style="mso-element:footnote" id="ftn1">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn1" href="#_ftnref1" name="_ftn1" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[1]</span></span><!--[endif]--></span></span></span></a></abar>If
we take Prolog&rsquo;s procedural behaviour into account, there are alternatives to
recursive loops such as the so-called <i style="mso-bidi-font-style:normal">failure-driven
loop</i> (see Exercise 7.5). </p>

</div>

<div style="mso-element:footnote" id="ftn2">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn2" href="#_ftnref2" name="_ftn2" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[2]</span></span><!--[endif]--></span></span></span></a></abar>It
is often more convenient to read a clause in the opposite direction: <br>
&lsquo;<b style="mso-bidi-font-weight:normal">if</b> somebody is a man <b style="mso-bidi-font-weight:normal">and</b> an adult <b style="mso-bidi-font-weight:
normal">then</b> he is married <b style="mso-bidi-font-weight:normal">or</b> a
bachelor&rsquo;.</p>

</div>

<div style="mso-element:footnote" id="ftn3">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn3" href="#_ftnref3" name="_ftn3" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[3]</span></span><!--[endif]--></span></span></span></a></abar><span style="font-family:Extra;mso-hansi-font-family:Extra;mso-bidi-font-family:&quot;Times New Roman&quot;"><span style='font-size: 250%; position: relative; top: 6px; line-height: 0%;'>&#x25A1;</span></span>
is called the empty clause because it has empty body and head, and therefore it
is not satisfiable by any interpretation.</p>

</div>

<div style="mso-element:footnote" id="ftn4">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn4" href="#_ftnref4" name="_ftn4" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[4]</span></span><!--[endif]--></span></span></span></a></abar>In
relational clausal logic, ground terms are necessarily constants. However, this
is not the case in full clausal logic, as we will see in section 2.3. </p>

</div>

<div style="mso-element:footnote" id="ftn5">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn5" href="#_ftnref5" name="_ftn5" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[5]</span></span><!--[endif]--></span></span></span></a></abar>We
will have more to say about the generality of clauses in Chapter 9.</p>

</div>

<div style="mso-element:footnote" id="ftn6">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn6" href="#_ftnref6" name="_ftn6" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[6]</span></span><!--[endif]--></span></span></span></a></abar>For
definite clauses this method of bottom-up model construction always yields the
unique minimal model of the program.</p>

</div>

<div style="mso-element:footnote" id="ftn7">

<p class="MsoFootnoteText" style="margin-right:20.0pt"><abar><a style="mso-footnote-id:
ftn7" href="#_ftnref7" name="_ftn7" title=""><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:
footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:10.0pt;font-family:Times;mso-fareast-font-family:
&quot;Times New Roman&quot;;mso-bidi-font-family:&quot;Times New Roman&quot;;mso-ansi-language:
EN-GB;mso-fareast-language:EN-US;mso-bidi-language:AR-SA;mso-no-proof:yes">[7]</span></span><!--[endif]--></span></span></span></a></abar>The
efficiency and completeness of search strategies will be discussed in Chapters
5 and 6.</p>

</div>

<div style="mso-element:footnote" id="ftn8">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn8" href="#_ftnref8" name="_ftn8" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[8]</span></span><!--[endif]--></span></span></span></a></abar>Written
this way to distinguish them from the arrows <span style="font-family:Courier">=&gt;</span>
and <span style="font-family:Courier">&lt;=</span>.</p>

</div>

<div style="mso-element:footnote" id="ftn9">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn9" href="#_ftnref9" name="_ftn9" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[9]</span></span><!--[endif]--></span></span></span></a></abar>This
is not allowed by every Prolog interpreter.</p>

</div>

<div style="mso-element:footnote" id="ftn10">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn10" href="#_ftnref10" name="_ftn10" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[10]</span></span><!--[endif]--></span></span></span></a></abar>Since
efficiency is an implementation issue, it is suggested that <span style="font-family:Courier">not</span> is replaced by <span style="font-family:
Courier">!</span> only in the final stage of program development.</p>

</div>

<div style="mso-element:footnote" id="ftn11">

<p class="MsoFootnoteText"><abar><a style="mso-footnote-id:ftn11" href="#_ftnref11" name="_ftn11" title=""><span class="MsoFootnoteReference"><span style="font-size:
8.0pt;mso-bidi-font-size:10.0pt"><span style="mso-special-character:footnote"><!--[if !supportFootnotes]--><span class="MsoFootnoteReference"><span style="font-size:8.0pt;mso-bidi-font-size:
10.0pt;font-family:Times;mso-fareast-font-family:&quot;Times New Roman&quot;;mso-bidi-font-family:
&quot;Times New Roman&quot;;mso-ansi-language:EN-GB;mso-fareast-language:EN-US;
mso-bidi-language:AR-SA;mso-no-proof:yes">[11]</span></span><!--[endif]--></span></span></span></a></abar>Recall
the discussion about the order of a logic in section 2.5.</p>

</div>

</div>



<script>$(function() { $(".swish").LPN({swish:"http://swish.swi-prolog.org/"}); });</script>
<!-- </body></html> -->
