---
resource: text
id: 1.1.3_2
type: long
---

As argued in the previous section, we prefer the recursive definition of the reachability relation, in which case we use functors in a somewhat different way.

{{ code['1.2.2_2'] }}

At first sight, there does not seem to be a big difference between this and the use of functors in the non-recursive program. However, the query

```Prolog
?-reachable(oxford_circus,charing_cross,R)
```

now has the following answers:

```text
{ R → route(tottenham_court_road,
            route(leicester_square,noroute)
           ) }
{ R → route(piccadilly_circus,noroute) }
{ R → route(piccadilly_circus,
            route(leicester_square,noroute)
           ) }
```

The functor `route` is now also recursive in nature: its first argument is a station, but *its second argument is again a route*. For instance, the object

```Prolog
route(tottenham_court_road,route(leicester_square,noroute))
```

can be pictured as in fig. 1.6. Such a figure is called a *tree* (we will have a lot more to say about trees in chapter 4). In order to find out the route represented by this complex object, we read the leaves of this tree from left to right, until we reach the &lsquo;terminator&rsquo; `noroute`. This would result in a linear notation like

```Prolog
[tottenham_court_road,leicester_square].
```

{{ figure['1.7'] }}
