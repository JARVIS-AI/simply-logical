---
resource: text
id: 1.1.1_2
type: long
---

The steps in fig. 1.2 follow a very general reasoning pattern:

> to answer a query `?-` $\textit{Q}_1$ `,` $\textit{Q}_2$ `,` &hellip; `,` $\textit{Q}_n$, find a rule *A* `:-` $\textit{B}_1$ `,` &hellip; `,` $\textit{B}_m$ such that *A* matches with $\textit{Q}_1$, and answer the query `?-` $\textit{B}_1$ `,` &hellip; `,` $\textit{B}_m$ `,` $\textit{Q}_2$ `,` &hellip; `,` $\textit{Q}_n$.

 This reasoning pattern is called *resolution*, and we will study it extensively in Chapters 2 and 3. Resolution adds a **procedural interpretation** to logical formulas, besides their declarative interpretation (they can be either true or false). Due to this procedural interpretation, logic can be used as a programming language. In an ideal logic programming system, the procedural interpretation would exactly match the declarative interpretation: everything that is calculated procedurally is declaratively true, and *vice versa*. In such an ideal system, the programmer would just bother about the declarative interpretation of the formulas she writes down, and leave the procedural interpretation to the computer. Unfortunately, in current logic programming systems the procedural interpretation does **not** exactly match the declarative interpretation: for example, some things that are declaratively true are not calculated at all, because the system enters an infinite loop. Therefore, the programmer should also be aware of the procedural interpretation given by the computer to her logical formulas.
